{
  "version": 3,
  "sources": ["../../../src/lib/const/tools.ts"],
  "sourcesContent": ["import { isDataItem, type Dataitem } from '../classes/data-item';\nimport type {\n    ColorEntryType,\n    ColorEntryTypeBooleanStandard,\n    IconEntryType,\n    MessageItem,\n    PageItemLightDataItems,\n    ScaledNumberType,\n    TextEntryType,\n    TextEntryType2,\n    TextSizeEntryType,\n    ValueEntryType,\n} from '../types/type-pageItem';\nimport type { Library } from '../classes/library';\nimport { Color, type RGB } from '../const/Color';\nimport { Icons } from './icon_mapping';\nimport type { ChangeTypeOfKeys } from '../types/pages';\nimport {\n    type IconColorElement,\n    isIconColorScaleElement,\n    isPartialColorScaleElement,\n    isPartialIconSelectScaleElement,\n    isValueDateFormat,\n} from '../types/types';\n\nexport const messageItemDefault: MessageItem = {\n    type: 'input_sel',\n    intNameEntity: '',\n    icon: '',\n    iconColor: '',\n    displayName: '',\n    optionalValue: '',\n};\nexport function ifValueEntryIs(\n    i: ChangeTypeOfKeys<ValueEntryType, Dataitem | undefined>,\n    type: ioBroker.CommonType,\n): boolean {\n    if (i && i.value && i.value.type) {\n        return i.value.type === type;\n    }\n    return false;\n}\n\nexport async function setValueEntry(\n    i: ChangeTypeOfKeys<ValueEntryType, Dataitem | undefined>,\n    value: number | boolean | string,\n    sca: boolean = true,\n): Promise<void> {\n    if (!i || !i.value) {\n        return;\n    }\n\n    let res: number | boolean | string = value;\n    if (typeof value === 'number') {\n        res = value / ((i.factor && (await i.factor.getNumber())) ?? 1);\n        if (sca && i.minScale !== undefined && i.maxScale !== undefined) {\n            const min = await i.minScale.getNumber();\n            const max = await i.maxScale.getNumber();\n            if (min !== null && max !== null) {\n                res = Math.round(Color.scale(res, 0, 100, min, max));\n            }\n        }\n    }\n    if (i.set && i.set.writeable) {\n        await i.set.setState(res);\n    } else if (i.value.writeable) {\n        await i.value.setState(res);\n    } else if (i.set || i.value) {\n        const t = i.set || i.value;\n        t.log.warn(t.name || '???' + ' is not writeable');\n    }\n}\nexport async function getValueEntryNumber(\n    i: ChangeTypeOfKeys<ValueEntryType | ScaledNumberType, Dataitem | undefined>,\n    s: boolean = true,\n    options?: { ignoreDecimal?: boolean },\n): Promise<number | null> {\n    if (!i) {\n        return null;\n    }\n    const nval = i.value && (await i.value.getNumber());\n    if (nval !== null && nval !== undefined) {\n        let res = nval * ((i.factor && (await i.factor.getNumber())) ?? 1);\n        if (s && i.minScale !== undefined && i.maxScale !== undefined) {\n            const min = await i.minScale.getNumber();\n            const max = await i.maxScale.getNumber();\n            if (min !== null && max !== null) {\n                res = Color.scale(res, min, max, 0, 100);\n            }\n        }\n        const d = ('decimal' in i && i.decimal && (await i.decimal.getNumber())) ?? null;\n        if (!options?.ignoreDecimal && d !== null && d !== false) {\n            res = Math.round(res * 10 ** d) / 10 ** d;\n        }\n        if ('negate' in i && i.negate) {\n            const reverse = await i.negate.getBoolean();\n            if (reverse != null && reverse) {\n                res = -res;\n            }\n        }\n        return res;\n    }\n    return null;\n}\nfunction getScaledNumberRaw(\n    n: number,\n    min: number | null,\n    max: number | null,\n    oldValue: number | null | false = null,\n): number {\n    if (min !== null && max !== null) {\n        if (oldValue === null) {\n            n = Math.round(Color.scale(n, min, max, 0, 100));\n        } else {\n            n = Color.scale(n, min, max, 0, 100);\n            /*if (oldValue !== false) {\n                if (oldValue > n) {\n                    n = Math.floor(n);\n                } else {\n                    n = Math.ceil(n);\n                }\n            } else */ {\n                n = Math.round(n);\n            }\n        }\n    }\n    return n;\n}\n\nexport async function getScaledNumber(\n    i: ChangeTypeOfKeys<ScaledNumberType, Dataitem | undefined>,\n): Promise<number | null> {\n    if (!i) {\n        return null;\n    }\n    let value = i.value && (await i.value.getNumber());\n    if (value != null) {\n        value = value * ((i.factor && (await i.factor.getNumber())) ?? 1);\n        if (i.minScale !== undefined && i.maxScale !== undefined) {\n            const min = await i.minScale.getNumber();\n            const max = await i.maxScale.getNumber();\n            value = getScaledNumberRaw(value, min, max);\n        }\n\n        if ('negate' in i && i.negate) {\n            const reverse = await i.negate.getBoolean();\n            if (reverse != null && reverse) {\n                value = -value;\n            }\n        }\n        return value;\n    }\n    return null;\n}\n\nexport async function getTemperaturColorFromValue(\n    i: ChangeTypeOfKeys<ScaledNumberType, Dataitem | undefined>,\n    dimmer: number = 100,\n): Promise<string | null> {\n    if (!i) {\n        return null;\n    }\n    const nval = i.value && (await i.value.getNumber());\n    const mode = i.mode && (await i.mode.getString());\n    let kelvin = 3500;\n    if (nval !== null && nval !== undefined) {\n        if (mode === 'mired') {\n            kelvin = 10 ** 6 / nval;\n        } else {\n            kelvin = nval;\n        }\n\n        //kelvin = kelvin > 6500 ? 6500 : kelvin < 2200 ? 2200 : kelvin;\n\n        let r = Color.kelvinToRGB[Math.trunc(kelvin / 100) * 100];\n        if (r) {\n            r = Color.brightness(r, Color.scale(dimmer, 0, 100, 0.3, 1));\n        }\n        return r ? String(Color.rgb_dec565(r)) : null;\n    }\n    return null;\n}\n\nexport async function getSliderCTFromValue(\n    i: ChangeTypeOfKeys<ScaledNumberType, Dataitem | undefined>,\n): Promise<string | null> {\n    if (!i) {\n        return null;\n    }\n    const nval = i.value && (await i.value.getNumber());\n    const mode = i.mode && (await i.mode.getString());\n    let r = 3500;\n    if (nval !== null && nval !== undefined) {\n        if (i.minScale !== undefined && i.maxScale !== undefined) {\n            const min = await i.minScale.getNumber();\n            const max = await i.maxScale.getNumber();\n            if (min !== null && max !== null) {\n                if (mode === 'mired') {\n                    r = Math.round(Color.scale(nval, min, max, 0, 100));\n                } else {\n                    r = Math.round(Color.scale(nval, min, max, 100, 0));\n                }\n            }\n        } else if (i.value && i.value.common && i.value.common.min !== undefined && i.value.common.max !== undefined) {\n            if (mode === 'mired') {\n                r = Math.round(Color.scale(nval, i.value.common.min, i.value.common.max, 0, 100));\n            } else {\n                r = Math.round(Color.scale(nval, i.value.common.min, i.value.common.max, 100, 0));\n            }\n        } else {\n            if (mode === 'mired') {\n                r = Math.round(Color.scale(nval, 153, 500, 0, 100));\n            } else {\n                r = Math.round(Color.scale(nval, 2200, 6500, 100, 0));\n            }\n        }\n\n        return r !== null ? String(r) : null;\n    }\n    return null;\n}\nexport async function setSliderCTFromValue(\n    i: ChangeTypeOfKeys<ScaledNumberType, Dataitem | undefined>,\n    value: number,\n): Promise<void> {\n    if (!i || !i.value) {\n        return;\n    }\n    const mode = i.mode && (await i.mode.getString());\n    //value = 100 - value;\n    let r = value;\n\n    if (i.minScale !== undefined && i.maxScale !== undefined) {\n        const min = await i.minScale.getNumber();\n        const max = await i.maxScale.getNumber();\n        if (min !== null && max !== null) {\n            if (mode === 'mired') {\n                r = Math.round(Color.scale(r, 0, 100, min, max));\n            } else {\n                r = Math.round(Color.scale(r, 0, 100, max, min));\n            }\n        }\n    } else if (i.value && i.value.common && i.value.common.min !== undefined && i.value.common.max !== undefined) {\n        if (mode === 'mired') {\n            r = Math.round(Color.scale(r, 0, 100, i.value.common.max, i.value.common.min));\n        } else {\n            r = Math.round(Color.scale(r, 0, 100, i.value.common.min, i.value.common.max));\n        }\n    } else {\n        if (mode === 'mired') {\n            r = Math.round(Color.scale(r, 0, 100, 153, 500));\n        } else {\n            r = Math.round(Color.scale(r, 0, 100, 6500, 2200));\n        }\n    }\n    if (i.set && i.set.writeable) {\n        await i.value.setState(r);\n    } else {\n        await i.value.setState(r);\n    }\n}\n\nexport async function setScaledNumber(\n    i: ChangeTypeOfKeys<ScaledNumberType, Dataitem | undefined>,\n    value: number,\n): Promise<void> {\n    if (!i || (!i.set && !i.value)) {\n        return;\n    }\n\n    if (i.minScale !== undefined && i.maxScale !== undefined) {\n        value = Color.scale(value, 0, 100, (await i.minScale.getNumber()) ?? 0, (await i.maxScale.getNumber()) ?? 100);\n    }\n    if (i.set?.options.scale) {\n        const scale = i.set.options.scale;\n        value = Color.scale(value, 0, 100, scale.min, scale.max ?? 100);\n    }\n    if (i.set?.writeable) {\n        await i.set.setState(value);\n    } else if (i.value?.writeable) {\n        await i.value.setState(value);\n    }\n}\n\nexport async function getIconEntryValue(\n    i: ChangeTypeOfKeys<IconEntryType, Dataitem | undefined> | undefined,\n    on: boolean | number | null,\n    def: string,\n    defOff: string | null = null,\n    getText: boolean = false,\n): Promise<string> {\n    if (i === undefined) {\n        return '';\n    }\n    on = on ?? true;\n    if (!i) {\n        return Icons.GetIcon(on ? def : defOff || def);\n    }\n\n    const text = getText ? (i.true && i.true.text && (await getValueEntryString(i.true.text))) || null : null;\n    if (text !== null) {\n        const textFalse = (i.false && i.false.text && (await getValueEntryString(i.false.text))) || null;\n        if (typeof on === 'number' && textFalse !== null) {\n            const scale = i.scale && (await i.scale.getObject());\n            if (isPartialColorScaleElement(scale)) {\n                if ((scale.val_min && scale.val_min >= on) || (scale.val_max && scale.val_max <= on)) {\n                    return text;\n                }\n                textFalse;\n            }\n        }\n        if (!on) {\n            return textFalse || text;\n        }\n        return text;\n    }\n    const icon = (i.true && i.true.value && (await i.true.value.getString())) || null;\n    const scaleM = i.scale && (await i.scale.getObject());\n\n    if (typeof on === 'boolean') {\n        const scale = isPartialIconSelectScaleElement(scaleM) ? scaleM : { valIcon_min: 0, valIcon_max: 1 };\n\n        if (scale.valIcon_min === 1 && scale.valIcon_max === 0) {\n            on = !on;\n        }\n        if (scale.valIcon_best !== undefined && scale.valIcon_best == 0) {\n            on = !on;\n        }\n        if (!on) {\n            return Icons.GetIcon(\n                (i.false && i.false.value && (await i.false.value.getString())) || defOff || icon || def,\n            );\n        }\n    } else if (typeof on === 'number') {\n        const scale = isPartialIconSelectScaleElement(scaleM) ? scaleM : { valIcon_min: 0, valIcon_max: 1 };\n        const swap = scale.valIcon_min > scale.valIcon_max;\n        const min = swap ? scale.valIcon_max : scale.valIcon_min;\n        const max = swap ? scale.valIcon_min : scale.valIcon_max;\n        if (min < on && max > on) {\n            return Icons.GetIcon(\n                (i.unstable && i.unstable.value && (await i.unstable.value.getString())) || icon || def,\n            );\n        } else if ((!swap && max > on) || (swap && min < on)) {\n            return Icons.GetIcon(\n                (i.false && i.false.value && (await i.false.value.getString())) || defOff || icon || def,\n            );\n        }\n    }\n    return Icons.GetIcon(icon ?? def);\n}\n\nexport async function getIconEntryColor(\n    i: ChangeTypeOfKeys<ColorEntryTypeBooleanStandard, Dataitem | undefined> | undefined,\n    value: boolean | number | null,\n    def: string | RGB | number,\n    defOff: string | RGB | null = null,\n): Promise<string> {\n    value = value ?? true;\n    if (typeof def === 'number') {\n        def = Color.decToRgb(def);\n    } else if (typeof def === 'string') {\n        def = Color.decToRgb(parseInt(def));\n    }\n\n    if (typeof defOff === 'number') {\n        defOff = Color.decToRgb(defOff);\n    } else if (defOff === null) {\n        defOff = null;\n    } else if (typeof defOff === 'string') {\n        defOff = Color.decToRgb(parseInt(defOff));\n    }\n\n    if (!i) {\n        return String(Color.rgb_dec565(def));\n    }\n    if (typeof value === 'boolean') {\n        const color = i.true && i.true.color && (await i.true.color.getRGBDec());\n        const scale = i.scale && (await i.scale.getObject());\n        if (scale) {\n            if (isIconColorScaleElement(scale)) {\n                if (scale.val_min === 1 && scale.val_max === 0) {\n                    value = !value;\n                }\n                if (scale.val_best !== undefined && scale.val_best == 0) {\n                    value = !value;\n                }\n            }\n        }\n        if (!value) {\n            return (\n                (i.false && i.false.color && (await i.false.color.getRGBDec())) ??\n                (defOff && String(Color.rgb_dec565(defOff))) ??\n                color ??\n                String(Color.rgb_dec565(def))\n            );\n        }\n        return color ?? String(Color.rgb_dec565(def));\n    } else if (typeof value === 'number') {\n        let cto = i.true && i.true.color && (await i.true.color.getRGBValue());\n        let cfrom = i.false && i.false.color && (await i.false.color.getRGBValue());\n        const scale = i.scale && (await i.scale.getObject());\n        if ((!cto || !cfrom) && isIconColorScaleElement(scale)) {\n            switch (scale.mode) {\n                case 'hue':\n                case 'cie':\n                case 'mixed': {\n                    break;\n                }\n                case 'triGrad':\n                case 'triGradAnchor':\n                case 'quadriGrad':\n                case 'quadriGradAnchor': {\n                    cto = cto || Color.HMIOn;\n                    cfrom = cfrom || Color.HMIOff;\n                }\n            }\n        }\n\n        if (cto && cfrom && scale) {\n            let rColor: RGB = cto;\n            if (isIconColorScaleElement(scale)) {\n                let swap = false;\n                let vMin = scale.val_min;\n                let vMax = scale.val_max;\n                if (vMax < vMin) {\n                    const temp = vMax;\n                    vMax = vMin;\n                    vMin = temp;\n                    const temp2 = cto;\n                    cto = cfrom;\n                    cfrom = temp2;\n                    swap = true;\n                }\n                vMin = vMin < value ? vMin : value;\n                vMax = vMax > value ? vMax : value;\n\n                let vBest = scale.val_best ?? undefined;\n                vBest = vBest !== undefined ? Math.min(vMax, Math.max(vMin, vBest)) : undefined;\n                let factor = 1;\n                let func = Color.mixColor;\n                switch (scale.mode) {\n                    case 'hue':\n                        func = Color.mixColorHue;\n                        break;\n                    case 'cie':\n                        func = Color.mixColorCie;\n                        break;\n                    case 'mixed':\n                        func = Color.mixColor;\n                        break;\n                    case 'triGradAnchor':\n                        if (scale.val_best !== undefined) {\n                            func = Color.triGradAnchor;\n                            break;\n                        }\n                    // eslint-disable-next-line no-fallthrough\n                    case 'triGrad':\n                        func = Color.triGradColorScale;\n                        break;\n                    case 'quadriGradAnchor':\n                        if (scale.val_best !== undefined) {\n                            func = Color.quadriGradAnchor;\n                            break;\n                        }\n                    // eslint-disable-next-line no-fallthrough\n                    case 'quadriGrad':\n                        func = Color.quadriGradColorScale;\n                        break;\n                }\n                if (vMin == vMax) {\n                    rColor = cto;\n                } else if (vBest === undefined) {\n                    factor = (value - vMin) / (vMax - vMin);\n                    factor = Math.min(1, Math.max(0, factor));\n                    factor = getLogFromIconScale(scale, factor);\n                    rColor = func(cfrom, cto, factor, { swap });\n                } else if (value >= vBest) {\n                    cfrom = scale.val_best !== undefined && scale.color_best ? scale.color_best : cfrom;\n                    factor = 1 - (value - vBest) / (vMax - vBest);\n                    factor = Math.min(1, Math.max(0, factor));\n                    factor = getLogFromIconScale(scale, factor);\n                    rColor = func(cfrom, cto, factor, { swap, anchorHigh: true });\n                } else {\n                    cto = scale.val_best !== undefined && scale.color_best ? scale.color_best : cto;\n                    factor = (value - vMin) / (vBest - vMin);\n                    factor = Math.min(1, Math.max(0, factor));\n                    factor = 1 - getLogFromIconScale(scale, 1 - factor);\n                    rColor = func(cfrom, cto, factor, { swap });\n                }\n                return String(Color.rgb_dec565(rColor));\n            } else if (isPartialColorScaleElement(scale)) {\n                if ((scale.val_min && scale.val_min >= value) || (scale.val_max && scale.val_max <= value)) {\n                    return String(Color.rgb_dec565(cto));\n                }\n                String(Color.rgb_dec565(cfrom));\n            }\n        }\n        if (value) {\n            if (cto) {\n                return String(Color.rgb_dec565(cto));\n            }\n        } else if (cfrom) {\n            return String(Color.rgb_dec565(cfrom));\n        } else if (cto) {\n            return String(Color.rgb_dec565(cto));\n        }\n    }\n    return String(Color.rgb_dec565(def));\n}\n\nfunction getLogFromIconScale(i: IconColorElement, factor: number): number {\n    if (i.log10 !== undefined) {\n        if (i.log10 === 'max') {\n            factor = factor * (90 / 10) + 1;\n            factor = factor < 1 ? 1 : factor > 10 ? 10 : factor;\n            factor = Math.log10(factor);\n        } else {\n            factor = (1 - factor) * (90 / 10) + 1;\n            factor = factor < 1 ? 1 : factor > 10 ? 10 : factor;\n            factor = Math.log10(factor);\n            factor = 1 - factor;\n        }\n    }\n    return factor;\n}\nexport async function GetIconColor(\n    item: ChangeTypeOfKeys<IconEntryType, Dataitem | undefined> | undefined | RGB,\n    value: boolean | number | null,\n    min: number | null = null,\n    max: number | null = null,\n    offColor: RGB | null = null,\n): Promise<string> {\n    // dimmer\n    if (item === undefined) {\n        return '';\n    }\n    if (Color.isRGB(item)) {\n        const onColor = item;\n        if (typeof value === 'number') {\n            let val: number = typeof value === 'number' ? value : 0;\n            const maxValue = max ?? 100;\n            const minValue = min ?? 0;\n            val = val > maxValue ? maxValue : val;\n            val = val < minValue ? minValue : val;\n            return String(\n                Color.rgb_dec565(\n                    !offColor\n                        ? Color.darken(onColor ? onColor : Color.HMIOn, Color.scale(val, maxValue, minValue, 0, 1))\n                        : Color.Interpolate(\n                              offColor,\n                              onColor ? onColor : Color.HMIOn,\n                              Color.scale(val, maxValue, minValue, 0, 1),\n                          ),\n                ),\n            );\n        }\n        if (value) {\n            return String(Color.rgb_dec565(onColor ? onColor : Color.HMIOn));\n        }\n        return String(Color.rgb_dec565(offColor ? offColor : Color.HMIOff));\n    }\n    const onColor = item.true && item.true.color && (await item.true.color.getRGBValue());\n    offColor = (item.false && item.false.color && (await item.false.color.getRGBValue())) || null;\n    if (typeof value === 'number') {\n        let val: number = typeof value === 'number' ? value : 0;\n        const maxValue = ((item.maxBri && (await item.maxBri.getNumber())) || max) ?? 100;\n        const minValue = ((item.minBri && (await item.minBri.getNumber())) || min) ?? 0;\n        val = val > maxValue ? maxValue : val;\n        val = val < minValue ? minValue : val;\n        return String(\n            Color.rgb_dec565(\n                !offColor\n                    ? Color.darken(onColor ? onColor : Color.HMIOn, Color.scale(val, maxValue, minValue, 0, 1))\n                    : Color.Interpolate(\n                          offColor,\n                          onColor ? onColor : Color.HMIOn,\n                          Color.scale(val, maxValue, minValue, 0, 1),\n                      ),\n            ),\n        );\n    }\n\n    if (value) {\n        return String(Color.rgb_dec565(onColor ? onColor : Color.HMIOn));\n    }\n    return String(Color.rgb_dec565(offColor ? offColor : Color.HMIOff));\n}\n\nexport async function getEntryColor(\n    i: ChangeTypeOfKeys<ColorEntryType, Dataitem | undefined> | undefined,\n    value: boolean | number,\n    def: string | number | RGB,\n): Promise<string> {\n    if (i === undefined) {\n        return '';\n    }\n    if (typeof def === 'number') {\n        def = String(def);\n    } else if (typeof def !== 'string') {\n        def = String(Color.rgb_dec565(def));\n    }\n    if (!i) {\n        return def;\n    }\n    const color = i.true && (await i.true.getRGBDec());\n    if (!value) {\n        return (i.false && (await i.false.getRGBDec())) ?? color ?? def;\n    }\n    return color ?? def;\n}\n\n/**\n * Returns the display text for a boolean-like entry.\n *\n * - Supports both Dataitem and structured entries with `true` / `false` parts.\n * - If `on` is a number, values > 0 are treated as `true`.\n * - If the resolved value is `null` or `undefined`, `null` is returned to signal \"no result\".\n * - When `useCommon` is true, `common.states` is used for mapping state labels.\n *\n * @param i Entry or Dataitem that defines the \"true\" and \"false\" variants.\n * @param on Boolean or number to select side; `null`/`undefined` defaults to \"true\".\n * @param useCommon Whether to resolve values through `common.states` mapping.\n * @returns Resolved display text, or `null` if no meaningful result exists.\n */\nexport async function getEntryTextOnOff(\n    i: ChangeTypeOfKeys<TextEntryType | TextEntryType2, Dataitem | undefined> | undefined | Dataitem,\n    on: boolean | number | null,\n    useCommon: boolean = false,\n): Promise<string | null> {\n    if (!i) {\n        return null;\n    }\n    if (typeof on === 'number') {\n        on = on > 0;\n    }\n    let value = '';\n    let v: string | null = null;\n    if (!isDataItem(i)) {\n        if (isDataItem(i.true)) {\n            v = (i.true && (await i.true.getString())) ?? null;\n            if (useCommon) {\n                const states =\n                    ((i.true && i.true.common && i.true.common.states) as Record<string, string> | string[]) ?? null;\n                if (states && v !== null && typeof states === 'object') {\n                    if (!Array.isArray(states)) {\n                        v = states[v] ?? v;\n                    } else if (!isNaN(Number(v))) {\n                        v = states[Number(v)] ?? v;\n                    }\n                }\n            }\n            value = v ?? '';\n        } else {\n            value = (i.true && i.true.prefix && (await i.true.prefix.getString())) ?? '';\n            v = (i.true && i.true.value && (await i.true.value.getString())) ?? null;\n            value += v ?? '';\n            value += (i.true && i.true.suffix && (await i.true.suffix.getString())) ?? '';\n        }\n\n        if (!(on ?? true)) {\n            let value2 = '';\n            let v2: string | null = null;\n            if (isDataItem(i.false)) {\n                v2 = (i.false && (await i.false.getString())) ?? null;\n                if (useCommon) {\n                    const states =\n                        ((i.false && i.false.common && i.false.common.states) as Record<string, string> | string[]) ??\n                        null;\n                    if (states && v2 !== null && typeof states === 'object') {\n                        if (!Array.isArray(states)) {\n                            v2 = states[v2] ?? v2;\n                        } else if (!isNaN(Number(v2))) {\n                            v2 = states[Number(v2)] ?? v2;\n                        }\n                    }\n                }\n                value2 = v2 ?? '';\n            } else {\n                value2 = (i.false && i.false.prefix && (await i.false.prefix.getString())) ?? '';\n                v2 = (i.false && i.false.value && (await i.false.value.getString())) ?? null;\n                value2 += v2 ?? '';\n                value2 += (i.false && i.false.suffix && (await i.false.suffix.getString())) ?? '';\n            }\n\n            return v2 == null ? (v == null ? null : value) : value2;\n        }\n\n        return v == null ? null : value;\n    }\n    return (await i.getString()) ?? null;\n}\n\nexport async function getValueEntryBoolean(\n    i: ChangeTypeOfKeys<ValueEntryType, Dataitem | undefined> | undefined,\n): Promise<boolean | null> {\n    if (!i) {\n        return null;\n    }\n    const nval = i.value && (await i.value.getBoolean());\n    if (nval !== undefined) {\n        return nval;\n    }\n    return null;\n}\nfunction isTextSizeEntryType(F: any): F is ChangeTypeOfKeys<TextSizeEntryType, Dataitem | undefined> {\n    return 'textSize' in (F as TextSizeEntryType);\n}\nexport async function getValueEntryString(\n    i: ChangeTypeOfKeys<ValueEntryType, Dataitem | undefined> | undefined,\n    v: number | null = null,\n): Promise<string | null> {\n    if (!i || !i.value) {\n        return null;\n    }\n    const nval = v !== null ? v : await getValueEntryNumber(i);\n    const format = ((i.dateFormat && (await i.dateFormat.getObject())) as any) ?? null;\n    const unit = (await i.unit?.getString()) ?? i.value.common.unit ?? '';\n    const prefix = (await i.prefix?.getString()) ?? '';\n    const suffix = (await i.suffix?.getString()) ?? '';\n\n    if (nval !== null && nval !== undefined) {\n        let res = '';\n        if (isValueDateFormat(format)) {\n            if (nval < 0) {\n                return null;\n            }\n            const temp = new Date(nval);\n            if (isValidDate(temp)) {\n                res = temp.toLocaleString(format.local, format.format);\n            }\n        } else {\n            const d = ('decimal' in i && i.decimal && (await i.decimal.getNumber())) ?? null;\n            if (d !== null && d !== false) {\n                res = nval.toLocaleString((format && format.local) ?? 'de-DE', {\n                    minimumFractionDigits: d,\n                    maximumFractionDigits: d,\n                    useGrouping: false,\n                });\n            } else {\n                res = nval.toLocaleString((format && format.local) ?? 'de-DE', {\n                    useGrouping: false,\n                });\n            }\n        }\n\n        res = prefix + res + unit + suffix;\n        let opt = '';\n        if (isTextSizeEntryType(i)) {\n            opt = String((i.textSize && (await i.textSize.getNumber())) ?? '');\n        }\n        return res + (opt ? `\u00AC${opt}` : '');\n    }\n    let res = await i.value.getString();\n\n    if (res != null) {\n        if (isValueDateFormat(format)) {\n            const temp = new Date(res);\n            if (isValidDate(temp)) {\n                res = temp.toLocaleString(format.local, format.format);\n            }\n        }\n\n        res = prefix + res + unit + suffix;\n        let opt = '';\n        if (isTextSizeEntryType(i)) {\n            opt = String((i.textSize && (await i.textSize.getNumber())) ?? '');\n        }\n        res += opt ? `\u00AC${opt}` : '';\n    }\n    return res;\n}\n\n/**\n * Aligns a given text to the specified size and alignment.\n * If the text length is greater than or equal to the specified size,\n * the original text is returned unchanged. Otherwise, the text is padded\n * with spaces to match the desired size and alignment.\n *\n * @param text - The input string to be aligned.\n * @param size - The total size of the resulting string after alignment.\n *               If the input text is shorter than this size, it will be padded with spaces.\n * @param align - The alignment type. Can be one of the following:\n *                - `'left'`: Aligns the text to the left and pads with spaces on the right.\n *                - `'right'`: Aligns the text to the right and pads with spaces on the left.\n *                - `'center'`: Centers the text and pads with spaces equally on both sides.\n *                             If the padding is uneven, the extra space is added to the right.\n * @returns A promise that resolves to the aligned string.\n * @example\n * ```typescript\n * const result = await alignText(\"Hello\", 10, \"left\");\n * console.log(result); // \"Hello     \"\n *\n * const result = await alignText(\"Hello\", 10, \"right\");\n * console.log(result); // \"     Hello\"\n *\n * const result = await alignText(\"Hello\", 10, \"center\");\n * console.log(result); // \"  Hello   \"\n * ```\n */\nexport function alignText(text: string, size: number, align: 'left' | 'right' | 'center'): string {\n    if (text.length >= size) {\n        return text;\n    }\n    let text2 = '';\n    const diff = size - text.length;\n    if (align === 'left') {\n        text2 = text + ' '.repeat(diff);\n    } else if (align === 'right') {\n        text2 = ' '.repeat(diff) + text;\n    } else if (align === 'center') {\n        const right = Math.floor(diff / 2);\n        const left = diff - right;\n        text2 = ' '.repeat(left) + text + ' '.repeat(right);\n    }\n    return text2;\n}\n\nexport const siPrefixes = [\n    // Unterhalb von 0\n    { prefix: 'f', name: 'femto', factor: -5 },\n    { prefix: 'p', name: 'pico', factor: -4 },\n    { prefix: 'n', name: 'nano', factor: -3 },\n    { prefix: '\u03BC', name: 'micro', factor: -2 },\n    { prefix: 'm', name: 'milli', factor: -1 },\n\n    // Oberhalb von 0\n    { prefix: 'k', name: 'kilo', factor: 1 },\n    { prefix: 'M', name: 'mega', factor: 2 },\n    { prefix: 'G', name: 'giga', factor: 3 },\n    { prefix: 'T', name: 'tera', factor: 4 },\n    { prefix: 'P', name: 'peta', factor: 5 },\n];\n/**\n * Converts a numerical value into a human-readable format with an appropriate SI prefix and unit.\n * The function adjusts the value and unit dynamically based on the provided constraints such as space and decimal precision.\n *\n * @param i - An object containing the value entry and associated metadata. It can be undefined.\n * @param v - The numerical value to be formatted. If null, the value is retrieved from the `i` parameter.\n * @param space - The maximum number of characters allowed for the formatted value (excluding the unit).\n * @param unit - The unit of the value. If null, it is inferred from the `i` parameter or the SI prefix.\n * @param startFactor - The starting SI prefix factor (e.g., 0 for base unit, 1 for kilo, -1 for milli). Defaults to 0.\n * @param minFactor - The minimum SI prefix factor allowed. Defaults to 0.\n * @returns A promise that resolves to an object containing:\n * - `value`: The formatted value as a string, adjusted to fit within the specified space.\n * - `unit`: The unit of the value, including the appropriate SI prefix.\n * - `endFactor`: The final SI prefix factor used for formatting.\n * @throws An error if `v` and `unit` are not both null or both defined.\n * - The function uses a predefined list of SI prefixes to determine the appropriate scaling for the value.\n * - If the value cannot be formatted to fit within the specified space, the function attempts to adjust the SI prefix factor.\n * - The function ensures that the formatted value does not exceed the allowed space, including the unit and decimal precision.\n * - If the value is null or undefined, it is retrieved from the `i` parameter using the `getValueEntryNumber` function.\n * - The function supports both positive and negative SI prefixes (e.g., kilo, milli).\n * @example\n * ```typescript\n * const result = await getValueAutoUnit(\n *     someValueEntry,\n *     12345,\n *     6,\n *     null,\n *     0,\n *     -2\n * );\n * console.log(result);\n * // Output: { value: \"12.3k\", unit: \"k\", endFactor: 1 }\n * ```\n */\nexport async function getValueAutoUnit(\n    i: ChangeTypeOfKeys<ValueEntryType, Dataitem | undefined> | undefined,\n    v: number | null,\n    space: number,\n    unit: string | null = null,\n    startFactor: number | null = null,\n    minFactor: number = 0,\n): Promise<{ value?: string; unit?: string | null; endFactor?: number }> {\n    if (!i || !i.value) {\n        return {};\n    }\n\n    if ((v != null && unit == null) || (v == null && unit != null)) {\n        throw new Error('v and unit must be both null or both not null');\n    }\n    let value = v != null ? v : await getValueEntryNumber(i, undefined, { ignoreDecimal: true });\n    const cUnit = ((i.unit && (await i.unit.getString())) ?? i.value.common.unit ?? '').trim();\n    const decimal = ('decimal' in i && i.decimal && (await i.decimal.getNumber())) ?? null;\n    const fits = false;\n    if (minFactor === undefined || minFactor === null) {\n        minFactor = 0;\n        for (const p of siPrefixes) {\n            if (cUnit.startsWith(p.prefix)) {\n                minFactor = p.factor;\n                break;\n            }\n        }\n    }\n    let res = '';\n    //let opt = '';\n    let unitFactor = startFactor == null || startFactor < minFactor ? minFactor : startFactor;\n\n    if (value !== null && value !== undefined) {\n        const isNegativ = value < 0;\n        value = Math.abs(value);\n        let factor = 0;\n        if (unit == null && cUnit !== null) {\n            for (const p of siPrefixes) {\n                if (cUnit.startsWith(p.prefix)) {\n                    unit = cUnit.substring(p.prefix.length);\n                    factor = p.factor;\n                    break;\n                }\n            }\n            if (unit === null) {\n                unit = cUnit;\n            }\n        }\n        value *= 10 ** (3 * factor);\n        let tempValue = value / 10 ** (3 * unitFactor);\n\n        let d = decimal != null && decimal !== false ? decimal : 1;\n        const calSpace = space - (d ? d + 1 : 0);\n        //calSpace = calSpace > 4 ? 4 : calSpace;\n        d = calSpace > 3 ? d : d - (3 - calSpace);\n        d = d < 0 ? 0 : d;\n        let endlessCouter = 0;\n        while (!fits) {\n            if (unitFactor > 5 || unitFactor < minFactor || endlessCouter++ > 10) {\n                res = unitFactor < minFactor ? (value /*/ 10 ** d*/ / 10 ** (3 * ++unitFactor)).toFixed(d) : 'error';\n                break;\n            }\n            tempValue = Math.round(tempValue * 10 ** d) / 10 ** d;\n            if (Math.round(tempValue * 10 ** d) === 0 || tempValue < 1 * 10 ** (Math.floor(calSpace / 2) - 1)) {\n                tempValue = value / 10 ** (3 * --unitFactor);\n                continue;\n            }\n\n            res = tempValue.toFixed(d);\n            if (res.length > space) {\n                if (tempValue >= 10 ** calSpace) {\n                    tempValue = value / 10 ** (3 * ++unitFactor);\n                    continue;\n                }\n            } else {\n                break;\n            }\n        }\n\n        //if (isTextSizeEntryType(i)) {\n        //    opt = String((i.textSize && (await i.textSize.getNumber())) ?? '');\n        //}\n        res = isNegativ ? `-${res}` : res;\n    }\n    const index = siPrefixes.findIndex(a => a.factor === unitFactor);\n    unit = index !== -1 ? siPrefixes[index].prefix + unit : unit;\n\n    return { value: res, unit: unit, endFactor: unitFactor };\n}\n\nexport function getTranslation(library: Library, key1: any, key2?: string): string {\n    let result = key2 ?? key1;\n    if (key2 !== undefined) {\n        result = library.getLocalTranslation(key1, key2);\n    }\n    result = library.getTranslation(result || key1);\n    return result;\n}\n\nexport const getRGBfromRGBThree = async (item: PageItemLightDataItems['data']): Promise<RGB | null> => {\n    if (!item) {\n        return Color.White;\n    }\n    const red = (item.Red && (await item.Red.getNumber())) ?? -1;\n    const green = (item.Green && (await item.Green.getNumber())) ?? -1;\n    const blue = (item.Blue && (await item.Blue.getNumber())) ?? -1;\n    if (red === -1 || blue === -1 || green === -1) {\n        return null;\n    }\n    return { r: red, g: green, b: blue };\n};\nexport const getDecfromRGBThree = async (item: PageItemLightDataItems['data']): Promise<string | null> => {\n    const rgb = await getRGBfromRGBThree(item);\n    if (!rgb) {\n        return null;\n    }\n    return String(Color.rgb_dec565(rgb));\n};\nexport const setRGBThreefromRGB = async (item: PageItemLightDataItems['data'], c: RGB): Promise<void> => {\n    if (!item || !item.Red || !item.Green || !item.Blue) {\n        return;\n    }\n    await item.Red.setState(c.r);\n    await item.Green.setState(c.g);\n    await item.Blue.setState(c.b);\n};\n\nexport const getDecfromHue = async (item: PageItemLightDataItems['data']): Promise<string | null> => {\n    if (!item || !item.hue) {\n        return null;\n    }\n    const hue = await item.hue.getNumber();\n    let saturation = Math.abs((item.saturation && (await item.saturation.getNumber())) ?? 1);\n    if (saturation > 1) {\n        saturation = 1;\n    }\n    if (hue === null) {\n        return null;\n    }\n    const arr = Color.hsv2rgb(hue, saturation, 1);\n    return String(Color.rgb_dec565({ r: arr[0], g: arr[1], b: arr[2] }));\n};\n\nexport const setHuefromRGB = async (item: PageItemLightDataItems['data'], c: RGB): Promise<void> => {\n    if (!item || !item.hue || !Color.isRGB(c)) {\n        return;\n    }\n    if (!item.hue.writeable) {\n        return;\n    }\n    //let saturation = Math.abs((item.saturation && (await item.saturation.getNumber())) ?? 1);\n    //if (saturation > 1) saturation = 1;\n    const hue = Color.getHue(c.r, c.g, c.b);\n    await item.hue.setState(hue);\n};\n\n/**\n * Formatiert Eingabetext (String oder Array) in max. zwei Zeilen mit Limit.\n * - Trennt nach 12 Zeichen f\u00FCr Zeile 1\n * - Zeile 2 ggf. auf 12 Zeichen gek\u00FCrzt, mit \"...\"\n * - ersetzt ?, _ usw. f\u00FCr bessere Lesbarkeit\n *\n * @param text {string | string[] | null | undefined} Eingabetext\n */\nexport function formatInSelText(text: string | string[] | null | undefined): string {\n    if (!text) {\n        return 'error';\n    }\n\n    // Normalisieren \u2192 Array von W\u00F6rtern\n    const words = Array.isArray(text)\n        ? text\n        : text.replaceAll('?', ' ').replaceAll('__', '_').replaceAll('_', ' ').split(/\\s+/);\n\n    const MAX_LINE = 12;\n    const MAX_LINE2 = 12;\n    const TRUNCATE = 9;\n\n    // Zeile 1 aufbauen\n    const line1: string[] = [];\n    let len1 = 0;\n    for (const word of words) {\n        if (len1 + word.length + (line1.length ? 1 : 0) > MAX_LINE) {\n            break;\n        }\n        line1.push(word);\n        len1 += word.length + 1;\n    }\n\n    // Rest in Zeile 2\n    const line2Words = words.slice(line1.length);\n    let line2 = line2Words.join(' ');\n    if (line2.length > MAX_LINE2) {\n        line2 = `${line2.substring(0, TRUNCATE)}...`;\n    }\n\n    return line1.length > 0 ? `${line1.join(' ')}\\r\\n${line2.trim()}` : line2.trim();\n}\n\n/**\n * Create a part of the panel messsage for bottom icons. if event === '' u get '~~~~~~'.\n * default for event: input_sel\n *\n * @param msg {Partial<MessageItem>}\n * @returns string\n */\nexport function getItemMesssage(msg: Partial<MessageItem> | undefined): string {\n    if (!msg || !msg.intNameEntity || !msg.type) {\n        return '~~~~~';\n    }\n    const id: string[] = [];\n    if (msg.mainId) {\n        id.push(msg.mainId);\n    }\n    if (msg.subId) {\n        id.push(msg.subId);\n    }\n    if (msg.intNameEntity) {\n        id.push(msg.intNameEntity);\n    }\n    return getPayload(\n        msg.type ?? messageItemDefault.type,\n        id.join('?') ?? messageItemDefault.intNameEntity,\n        msg.icon ?? messageItemDefault.icon,\n        msg.iconColor ?? messageItemDefault.iconColor,\n        msg.displayName ?? messageItemDefault.displayName,\n        msg.optionalValue ?? messageItemDefault.optionalValue,\n    );\n}\n\nexport function getPayloadArray(s: any[]): string {\n    return s.join('~');\n}\nexport function getPayload(...s: string[]): string {\n    return s.join('~');\n}\n\n// JSON-like value incl. RegExp support\ntype Jsonish = undefined | null | string | number | boolean | RegExp | Jsonish[] | { [k: string]: Jsonish };\n\n/**\n * Strict plain-object check (no arrays, no RegExp, no Date, \u2026).\n *\n * @param v Value to check\n */\nconst isPlainObject = (v: unknown): v is Record<string, unknown> =>\n    Object.prototype.toString.call(v) === '[object Object]';\n\n/**\n * Normalize `null` to `undefined` (your merging rules treat them equally).\n *\n * @param v     Value to normalize\n */\nconst nn = <T extends Jsonish>(v: T): Exclude<T, null> | undefined => (v === null ? undefined : v) as any;\n\n/**\n * Detect DataItemsOptions-like objects that must be treated atomically (no deep merge).\n *\n * Rules (as specified):\n * - If `mode === 'auto'` then the object is atomic when it has at least one of:\n * - `regexp` OR `role` OR `commonType`\n * - If `mode` is NOT present:\n * - atomic if `type === 'const'` AND has `constVal`\n * - atomic if `type === 'state' | 'triggered'` AND has `dp` (string)\n *\n * @param o Value to check\n */\nfunction isAtomicDataItem(o: unknown): boolean {\n    if (!isPlainObject(o)) {\n        return false;\n    }\n\n    const mode = (o as any).mode;\n    const type = (o as any).type;\n\n    if (mode === 'auto') {\n        const hasQualifier = 'regexp' in (o as any) || 'role' in (o as any) || 'commonType' in (o as any);\n        return !!hasQualifier;\n    }\n    if (type === 'const') {\n        return 'constVal' in (o as any);\n    }\n    if (type === 'state' || type === 'triggered') {\n        return typeof (o as any).dp === 'string';\n    }\n\n    return false;\n}\n\n/**\n * Deep-assign for JSON-like structures with special rules:\n * - `null` \u2192 `undefined`\n * - `source` overrides `def`; if `source === undefined`, keep `def` (clone)\n * - Plain objects deep-merge, EXCEPT atomic DataItemsOptions (replace whole object)\n * - Arrays: source replaces def\n * - Non-mutating; recursion depth guard\n *\n * @param def Default/base object\n * @param source Source object to merge on top\n * @param level Recursion level (for internal use)\n */\nexport function deepAssign(def: Record<any, any>, source: Record<any, any>, level: number = 0): any {\n    if (level > 20) {\n        throw new Error('Max level reached! Possible circular structure.');\n    }\n\n    def = nn(def) as Record<any, any>;\n    source = nn(source) as Record<any, any>;\n\n    if (source === undefined) {\n        return cloneJson(def);\n    }\n\n    if (isPlainObject(def) && isPlainObject(source)) {\n        // Atomic short-circuit (replace entire object)\n        if (isAtomicDataItem(source) || isAtomicDataItem(def)) {\n            return cloneJson(source ?? def);\n        }\n\n        const out: Record<string, Jsonish> = {};\n        const keys = new Set([...Object.keys(def), ...Object.keys(source)]);\n        for (const k of keys) {\n            const dv = nn((def as Record<string, Jsonish>)[k]);\n            const sv = nn((source as Record<string, Jsonish>)[k]);\n\n            if (sv === undefined) {\n                out[k] = cloneJson(dv);\n            } else if (isPlainObject(dv) && isPlainObject(sv)) {\n                out[k] = deepAssign(dv, sv, level + 1);\n            } else if (Array.isArray(dv) && Array.isArray(sv)) {\n                out[k] = cloneJson(sv); // arrays: replace\n            } else {\n                out[k] = cloneJson(sv);\n            }\n        }\n        return out;\n    }\n\n    // Non-plain or mixed \u2192 source wins\n    return cloneJson(source);\n}\n\n/**\n * Safe deep clone for Jsonish (supports RegExp).\n *\n * @param v Value to clone\n */\nfunction cloneJson<T extends Jsonish>(v: any): any {\n    v = nn(v) as T;\n\n    if (v instanceof RegExp) {\n        return new RegExp(v.source, v.flags) as any as T;\n    }\n    if (Array.isArray(v)) {\n        return v.map(cloneJson) as unknown as T;\n    }\n    if (isPlainObject(v)) {\n        const o: Record<string, Jsonish> = {};\n        for (const k of Object.keys(v)) {\n            o[k] = cloneJson((v as any)[k]);\n        }\n        return o as T;\n    }\n    return v;\n}\n\nexport function getInternalDefaults(\n    type: ioBroker.StateCommon['type'],\n    role: ioBroker.StateCommon['role'],\n    write: boolean = true,\n): ioBroker.StateCommon {\n    return {\n        name: '',\n        type: type,\n        role: role,\n        read: true,\n        write: write,\n    };\n}\n\nexport function setTriggeredToState(theObject: any, exclude: string[]): void {\n    if (theObject instanceof Array) {\n        for (let i = 0; i < theObject.length; i++) {\n            setTriggeredToState(theObject[i], exclude);\n        }\n    } else {\n        for (const prop in theObject) {\n            if (exclude.indexOf(prop) !== -1) {\n                continue;\n            }\n            if (prop == 'type') {\n                if (theObject[prop] === 'triggered') {\n                    theObject[prop] = 'state';\n                }\n            }\n            if (theObject[prop] instanceof Object || theObject[prop] instanceof Array) {\n                setTriggeredToState(theObject[prop], exclude);\n            }\n        }\n    }\n}\n\nexport function getRegExp(input: string, options?: { startsWith?: boolean; endsWith?: boolean }): RegExp | null {\n    if (!input) {\n        return null;\n    }\n    if (input.startsWith('/') && input.lastIndexOf('/') > 0 && input.endsWith('/')) {\n        const last = input.lastIndexOf('/');\n        const pattern = input.slice(1, last);\n        const flags = input.slice(last + 1);\n        return new RegExp(pattern, flags || undefined);\n    }\n\n    // 2) beginnt mit '/', endet aber nicht mit '/' \u2192 als String behandeln + Warnung\n    if (input.startsWith('/')) {\n        console.warn(`getRegExp: string starts with '/' but not closed -> treating as literal string.`);\n        input = input.slice(1); // f\u00FChrenden / wegnehmen, sonst doppelt escaped\n    }\n\n    // 3) normaler String \u2192 escapen + optionale Anchors\n    let pattern = escapeRegex(input);\n\n    // Falls kein expliziter Start/End-Anker verlangt \u2192 .+? einsetzen\n    if (!options?.startsWith) {\n        pattern = `.*?${pattern}`;\n    } else {\n        pattern = `^${pattern}`;\n    }\n\n    if (!options?.endsWith) {\n        pattern = `${pattern}.*?`;\n    } else {\n        pattern = `${pattern}$`;\n    }\n\n    return new RegExp(pattern);\n}\n\nfunction escapeRegex(s: string): string {\n    return s.replace(/[\\\\^$.*+?()[\\]{}|/]/g, '\\\\$&');\n}\n\n/*export function insertLinebreak(text: string, lineLength: number): string {\n    let counter = 0;\n    let a = 0;\n    let olda = a;\n    while (counter++ < 30) {\n        if (a + lineLength >= text.length) {\n            break;\n        }\n        const n = text.lastIndexOf('\\n', lineLength + a);\n        if (n > a) {\n            a = n;\n            continue;\n        }\n        a = text.lastIndexOf(' ', lineLength + a);\n        if (olda === a) {\n            break;\n        }\n        olda = a;\n        text = `${text.slice(0, a)}\\n${text.slice(++a)}`;\n    }\n    return text;\n}*/\nexport function insertLinebreak(text: string, lineLength: number): string {\n    if (lineLength <= 0 || !text) {\n        return text;\n    }\n\n    const result: string[] = [];\n    const lines = text.split('\\n'); // vorhandene Zeilen beibehalten\n\n    for (const line of lines) {\n        if (line.length <= lineLength) {\n            result.push(line);\n            continue;\n        }\n\n        let start = 0;\n        const len = line.length;\n\n        while (start < len) {\n            const end = Math.min(start + lineLength, len);\n\n            // Wenn wir am Zeilenende sind -> einfach pushen\n            if (end === len) {\n                result.push(line.slice(start));\n                break;\n            }\n\n            // Versuche, an der letzten Leerstelle vor end zu umbrechen\n            const breakPos = line.lastIndexOf(' ', end);\n            if (breakPos <= start) {\n                // Kein Leerzeichen im Bereich -> harter Umbruch\n                result.push(line.slice(start, end));\n                start = end;\n            } else {\n                // Weiches Wrapping an Leerzeichen\n                result.push(line.slice(start, breakPos));\n                start = breakPos + 1; // Leerzeichen \u00FCberspringen\n            }\n        }\n    }\n\n    return result.join('\\n');\n}\n\nexport function isValidDate(d: Date): d is Date {\n    if (!d) {\n        return false;\n    }\n    return d instanceof Date && !isNaN(d.getTime());\n}\n\nexport function getVersionAsNumber(version: string): number {\n    return version\n        .split('.')\n        .map((item, i) => parseInt(item) * Math.pow(1000, 2 - i))\n        .reduce((a, b) => a + b);\n}\n\nexport function isVersionGreaterOrEqual(a: string, b: string): boolean {\n    const aNum = getVersionAsNumber(a);\n    const bNum = getVersionAsNumber(b);\n    return aNum >= bNum;\n}\nexport function buildScrollingText(\n    title: string,\n    options: {\n        maxSize?: number;\n        prefix?: string;\n        suffix?: string;\n        sep?: string;\n        rightFixed?: string;\n        gap?: string;\n        pos?: number;\n        anchorRatio?: number; // 0..1, wo im linken Fenster der Titelanfang initial steht (Default 0.25)\n    } = {},\n): { text: string; nextPos: number } {\n    const {\n        maxSize = 35,\n        prefix = '',\n        suffix = '',\n        sep = ' ',\n        rightFixed,\n        gap = '      ',\n        pos = 0,\n        anchorRatio = 0.38,\n    } = options;\n\n    const right = rightFixed ?? suffix ?? '';\n    const useSep = right.length > 0 ? sep : '';\n    const leftAvailable = maxSize - prefix.length - useSep.length - right.length;\n\n    if (leftAvailable <= 0) {\n        const fixed = `${prefix}${useSep}${right}`;\n        return { text: fixed.slice(-maxSize), nextPos: pos };\n    }\n\n    // Kurz: mittig ausrichten\n    if (title.length <= leftAvailable) {\n        const extra = leftAvailable - title.length;\n        const leftPad = Math.floor(extra / 2);\n        const rightPad = extra - leftPad;\n        const left = ' '.repeat(leftPad) + title + ' '.repeat(rightPad);\n        return { text: `${prefix}${left}${useSep}${right}`, nextPos: pos };\n    }\n\n    // Lang: Anfang des Titels bei ~anchorRatio der Fensterbreite platzieren\n    // Zyklus: L\u00FCcke links + Titel + L\u00FCcke rechts\n    const cycle = gap + title + gap;\n    const cycleLen = cycle.length;\n    const doubled = cycle + cycle;\n\n    const titleStart = gap.length; // Index des ersten Titelzeichens im cycle\n    const anchor = Math.max(0, Math.min(1, anchorRatio));\n    const viewAnchor = Math.floor(leftAvailable * anchor); // Position im Fenster f\u00FCr den Titelanfang\n    const baseOff = (titleStart - viewAnchor + cycleLen) % cycleLen;\n\n    const posNorm = (pos + baseOff) % cycleLen;\n    const left = doubled.substr(posNorm, leftAvailable);\n\n    const full = `${prefix}${left}${useSep}${right}`;\n    const nextPos = (pos + 1) % cycleLen;\n\n    return { text: full, nextPos };\n}\n\n/**\n * Convert a duration in milliseconds to a human-readable time string.\n *\n * Format rules:\n * - Hours: unbounded (0 .. \u221E), no leading zeros (e.g., \"0\", \"1\", \"26\")\n * - Minutes: at least one digit; no leading zero if < 10 (e.g., \"3\", \"12\")\n * - Seconds: always two digits (e.g., \"05\", \"40\")\n * - If hours === 0, the output is \"M:SS\" (e.g., \"1:05\", \"12:00\")\n * - If hours > 0, the output is \"H:MM:SS\" (e.g., \"1:01:40\", \"26:00:00\")\n *\n * Edge cases:\n * - Negative inputs are treated as 0.\n * - Non-finite inputs (NaN, Infinity) result in \"0:00\".\n *\n * @param ms Duration in milliseconds.\n * @returns A time string formatted as \"M:SS\" or \"H:MM:SS\" per the rules above.\n * @example\n * formatHMS(65_000);           // \"1:05\"\n * formatHMS(3_700_000);        // \"1:01:40\"\n * formatHMS(26 * 3_600_000);   // \"26:00:00\"\n * formatHMS(-500);             // \"0:00\"\n * formatHMS(Number.NaN);       // \"0:00\"\n */\nexport function formatHMS(ms: number): string {\n    if (!Number.isFinite(ms) || ms < 0) {\n        ms = 0;\n    }\n\n    const totalSeconds: number = Math.floor(ms / 1000);\n    const hours: number = Math.floor(totalSeconds / 3600);\n    const minutes: number = Math.floor((totalSeconds % 3600) / 60);\n    const seconds: number = totalSeconds % 60;\n\n    const minutesStr = String(minutes); // minutes: no leading zero\n    const secondsStr: string = String(seconds).padStart(2, '0'); // seconds: always 2 digits\n\n    if (hours > 0) {\n        // hours: unbounded, no leading zeros; minutes padded to 2 when hours are present\n        return `${hours}:${minutesStr.padStart(2, '0')}:${secondsStr}`;\n    }\n    // hours === 0 -> \"M:SS\"\n    return `${minutesStr}:${secondsStr}`;\n}\n\nexport function getStringFromStringOrTranslated(\n    adapter: ioBroker.Adapter,\n    input: ioBroker.StringOrTranslated,\n    def?: string,\n): string {\n    if (typeof input === 'string') {\n        return input;\n    }\n    if (adapter.language && input[adapter.language]) {\n        return input[adapter.language] as string;\n    }\n    if (input.en) {\n        return input.en;\n    }\n    return def ?? ``;\n}\n\nexport default formatHMS;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA0C;AAc1C,mBAAgC;AAChC,0BAAsB;AAEtB,mBAMO;AAEA,MAAM,qBAAkC;AAAA,EAC3C,MAAM;AAAA,EACN,eAAe;AAAA,EACf,MAAM;AAAA,EACN,WAAW;AAAA,EACX,aAAa;AAAA,EACb,eAAe;AACnB;AACO,SAAS,eACZ,GACA,MACO;AACP,MAAI,KAAK,EAAE,SAAS,EAAE,MAAM,MAAM;AAC9B,WAAO,EAAE,MAAM,SAAS;AAAA,EAC5B;AACA,SAAO;AACX;AAEA,eAAsB,cAClB,GACA,OACA,MAAe,MACF;AA/CjB;AAgDI,MAAI,CAAC,KAAK,CAAC,EAAE,OAAO;AAChB;AAAA,EACJ;AAEA,MAAI,MAAiC;AACrC,MAAI,OAAO,UAAU,UAAU;AAC3B,UAAM,UAAU,OAAE,UAAW,MAAM,EAAE,OAAO,UAAU,MAAtC,YAA6C;AAC7D,QAAI,OAAO,EAAE,aAAa,UAAa,EAAE,aAAa,QAAW;AAC7D,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,UAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC9B,cAAM,KAAK,MAAM,mBAAM,MAAM,KAAK,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,MACvD;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,EAAE,OAAO,EAAE,IAAI,WAAW;AAC1B,UAAM,EAAE,IAAI,SAAS,GAAG;AAAA,EAC5B,WAAW,EAAE,MAAM,WAAW;AAC1B,UAAM,EAAE,MAAM,SAAS,GAAG;AAAA,EAC9B,WAAW,EAAE,OAAO,EAAE,OAAO;AACzB,UAAM,IAAI,EAAE,OAAO,EAAE;AACrB,MAAE,IAAI,KAAK,EAAE,QAAQ,sBAA2B;AAAA,EACpD;AACJ;AACA,eAAsB,oBAClB,GACA,IAAa,MACb,SACsB;AA5E1B;AA6EI,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,QAAM,OAAO,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AACjD,MAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,QAAI,MAAM,SAAS,OAAE,UAAW,MAAM,EAAE,OAAO,UAAU,MAAtC,YAA6C;AAChE,QAAI,KAAK,EAAE,aAAa,UAAa,EAAE,aAAa,QAAW;AAC3D,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,UAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC9B,cAAM,mBAAM,MAAM,KAAK,KAAK,KAAK,GAAG,GAAG;AAAA,MAC3C;AAAA,IACJ;AACA,UAAM,KAAK,kBAAa,KAAK,EAAE,WAAY,MAAM,EAAE,QAAQ,UAAU,MAA1D,YAAiE;AAC5E,QAAI,EAAC,mCAAS,kBAAiB,MAAM,QAAQ,MAAM,OAAO;AACtD,YAAM,KAAK,MAAM,MAAM,MAAM,CAAC,IAAI,MAAM;AAAA,IAC5C;AACA,QAAI,YAAY,KAAK,EAAE,QAAQ;AAC3B,YAAM,UAAU,MAAM,EAAE,OAAO,WAAW;AAC1C,UAAI,WAAW,QAAQ,SAAS;AAC5B,cAAM,CAAC;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,mBACL,GACA,KACA,KACA,WAAkC,MAC5B;AACN,MAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC9B,QAAI,aAAa,MAAM;AACnB,UAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,KAAK,KAAK,GAAG,GAAG,CAAC;AAAA,IACnD,OAAO;AACH,UAAI,mBAAM,MAAM,GAAG,KAAK,KAAK,GAAG,GAAG;AAOzB;AACN,YAAI,KAAK,MAAM,CAAC;AAAA,MACpB;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AAEA,eAAsB,gBAClB,GACsB;AAnI1B;AAoII,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,MAAI,QAAQ,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AAChD,MAAI,SAAS,MAAM;AACf,YAAQ,UAAU,OAAE,UAAW,MAAM,EAAE,OAAO,UAAU,MAAtC,YAA6C;AAC/D,QAAI,EAAE,aAAa,UAAa,EAAE,aAAa,QAAW;AACtD,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,cAAQ,mBAAmB,OAAO,KAAK,GAAG;AAAA,IAC9C;AAEA,QAAI,YAAY,KAAK,EAAE,QAAQ;AAC3B,YAAM,UAAU,MAAM,EAAE,OAAO,WAAW;AAC1C,UAAI,WAAW,QAAQ,SAAS;AAC5B,gBAAQ,CAAC;AAAA,MACb;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEA,eAAsB,4BAClB,GACA,SAAiB,KACK;AACtB,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,QAAM,OAAO,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AACjD,QAAM,OAAO,EAAE,QAAS,MAAM,EAAE,KAAK,UAAU;AAC/C,MAAI,SAAS;AACb,MAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,QAAI,SAAS,SAAS;AAClB,eAAS,MAAM,IAAI;AAAA,IACvB,OAAO;AACH,eAAS;AAAA,IACb;AAIA,QAAI,IAAI,mBAAM,YAAY,KAAK,MAAM,SAAS,GAAG,IAAI,GAAG;AACxD,QAAI,GAAG;AACH,UAAI,mBAAM,WAAW,GAAG,mBAAM,MAAM,QAAQ,GAAG,KAAK,KAAK,CAAC,CAAC;AAAA,IAC/D;AACA,WAAO,IAAI,OAAO,mBAAM,WAAW,CAAC,CAAC,IAAI;AAAA,EAC7C;AACA,SAAO;AACX;AAEA,eAAsB,qBAClB,GACsB;AACtB,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,QAAM,OAAO,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AACjD,QAAM,OAAO,EAAE,QAAS,MAAM,EAAE,KAAK,UAAU;AAC/C,MAAI,IAAI;AACR,MAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,QAAI,EAAE,aAAa,UAAa,EAAE,aAAa,QAAW;AACtD,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,YAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,UAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC9B,YAAI,SAAS,SAAS;AAClB,cAAI,KAAK,MAAM,mBAAM,MAAM,MAAM,KAAK,KAAK,GAAG,GAAG,CAAC;AAAA,QACtD,OAAO;AACH,cAAI,KAAK,MAAM,mBAAM,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,CAAC;AAAA,QACtD;AAAA,MACJ;AAAA,IACJ,WAAW,EAAE,SAAS,EAAE,MAAM,UAAU,EAAE,MAAM,OAAO,QAAQ,UAAa,EAAE,MAAM,OAAO,QAAQ,QAAW;AAC1G,UAAI,SAAS,SAAS;AAClB,YAAI,KAAK,MAAM,mBAAM,MAAM,MAAM,EAAE,MAAM,OAAO,KAAK,EAAE,MAAM,OAAO,KAAK,GAAG,GAAG,CAAC;AAAA,MACpF,OAAO;AACH,YAAI,KAAK,MAAM,mBAAM,MAAM,MAAM,EAAE,MAAM,OAAO,KAAK,EAAE,MAAM,OAAO,KAAK,KAAK,CAAC,CAAC;AAAA,MACpF;AAAA,IACJ,OAAO;AACH,UAAI,SAAS,SAAS;AAClB,YAAI,KAAK,MAAM,mBAAM,MAAM,MAAM,KAAK,KAAK,GAAG,GAAG,CAAC;AAAA,MACtD,OAAO;AACH,YAAI,KAAK,MAAM,mBAAM,MAAM,MAAM,MAAM,MAAM,KAAK,CAAC,CAAC;AAAA,MACxD;AAAA,IACJ;AAEA,WAAO,MAAM,OAAO,OAAO,CAAC,IAAI;AAAA,EACpC;AACA,SAAO;AACX;AACA,eAAsB,qBAClB,GACA,OACa;AACb,MAAI,CAAC,KAAK,CAAC,EAAE,OAAO;AAChB;AAAA,EACJ;AACA,QAAM,OAAO,EAAE,QAAS,MAAM,EAAE,KAAK,UAAU;AAE/C,MAAI,IAAI;AAER,MAAI,EAAE,aAAa,UAAa,EAAE,aAAa,QAAW;AACtD,UAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,UAAM,MAAM,MAAM,EAAE,SAAS,UAAU;AACvC,QAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC9B,UAAI,SAAS,SAAS;AAClB,YAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,MACnD,OAAO;AACH,YAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,MACnD;AAAA,IACJ;AAAA,EACJ,WAAW,EAAE,SAAS,EAAE,MAAM,UAAU,EAAE,MAAM,OAAO,QAAQ,UAAa,EAAE,MAAM,OAAO,QAAQ,QAAW;AAC1G,QAAI,SAAS,SAAS;AAClB,UAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,GAAG,KAAK,EAAE,MAAM,OAAO,KAAK,EAAE,MAAM,OAAO,GAAG,CAAC;AAAA,IACjF,OAAO;AACH,UAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,GAAG,KAAK,EAAE,MAAM,OAAO,KAAK,EAAE,MAAM,OAAO,GAAG,CAAC;AAAA,IACjF;AAAA,EACJ,OAAO;AACH,QAAI,SAAS,SAAS;AAClB,UAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,IACnD,OAAO;AACH,UAAI,KAAK,MAAM,mBAAM,MAAM,GAAG,GAAG,KAAK,MAAM,IAAI,CAAC;AAAA,IACrD;AAAA,EACJ;AACA,MAAI,EAAE,OAAO,EAAE,IAAI,WAAW;AAC1B,UAAM,EAAE,MAAM,SAAS,CAAC;AAAA,EAC5B,OAAO;AACH,UAAM,EAAE,MAAM,SAAS,CAAC;AAAA,EAC5B;AACJ;AAEA,eAAsB,gBAClB,GACA,OACa;AAzQjB;AA0QI,MAAI,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC,EAAE,OAAQ;AAC5B;AAAA,EACJ;AAEA,MAAI,EAAE,aAAa,UAAa,EAAE,aAAa,QAAW;AACtD,YAAQ,mBAAM,MAAM,OAAO,GAAG,MAAM,WAAM,EAAE,SAAS,UAAU,MAA3B,YAAiC,IAAI,WAAM,EAAE,SAAS,UAAU,MAA3B,YAAiC,GAAG;AAAA,EACjH;AACA,OAAI,OAAE,QAAF,mBAAO,QAAQ,OAAO;AACtB,UAAM,QAAQ,EAAE,IAAI,QAAQ;AAC5B,YAAQ,mBAAM,MAAM,OAAO,GAAG,KAAK,MAAM,MAAK,WAAM,QAAN,YAAa,GAAG;AAAA,EAClE;AACA,OAAI,OAAE,QAAF,mBAAO,WAAW;AAClB,UAAM,EAAE,IAAI,SAAS,KAAK;AAAA,EAC9B,YAAW,OAAE,UAAF,mBAAS,WAAW;AAC3B,UAAM,EAAE,MAAM,SAAS,KAAK;AAAA,EAChC;AACJ;AAEA,eAAsB,kBAClB,GACA,IACA,KACA,SAAwB,MACxB,UAAmB,OACJ;AACf,MAAI,MAAM,QAAW;AACjB,WAAO;AAAA,EACX;AACA,OAAK,kBAAM;AACX,MAAI,CAAC,GAAG;AACJ,WAAO,0BAAM,QAAQ,KAAK,MAAM,UAAU,GAAG;AAAA,EACjD;AAEA,QAAM,OAAO,UAAW,EAAE,QAAQ,EAAE,KAAK,QAAS,MAAM,oBAAoB,EAAE,KAAK,IAAI,KAAO,OAAO;AACrG,MAAI,SAAS,MAAM;AACf,UAAM,YAAa,EAAE,SAAS,EAAE,MAAM,QAAS,MAAM,oBAAoB,EAAE,MAAM,IAAI,KAAO;AAC5F,QAAI,OAAO,OAAO,YAAY,cAAc,MAAM;AAC9C,YAAM,QAAQ,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AAClD,cAAI,yCAA2B,KAAK,GAAG;AACnC,YAAK,MAAM,WAAW,MAAM,WAAW,MAAQ,MAAM,WAAW,MAAM,WAAW,IAAK;AAClF,iBAAO;AAAA,QACX;AACA;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,CAAC,IAAI;AACL,aAAO,aAAa;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACA,QAAM,OAAQ,EAAE,QAAQ,EAAE,KAAK,SAAU,MAAM,EAAE,KAAK,MAAM,UAAU,KAAO;AAC7E,QAAM,SAAS,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AAEnD,MAAI,OAAO,OAAO,WAAW;AACzB,UAAM,YAAQ,8CAAgC,MAAM,IAAI,SAAS,EAAE,aAAa,GAAG,aAAa,EAAE;AAElG,QAAI,MAAM,gBAAgB,KAAK,MAAM,gBAAgB,GAAG;AACpD,WAAK,CAAC;AAAA,IACV;AACA,QAAI,MAAM,iBAAiB,UAAa,MAAM,gBAAgB,GAAG;AAC7D,WAAK,CAAC;AAAA,IACV;AACA,QAAI,CAAC,IAAI;AACL,aAAO,0BAAM;AAAA,QACR,EAAE,SAAS,EAAE,MAAM,SAAU,MAAM,EAAE,MAAM,MAAM,UAAU,KAAO,UAAU,QAAQ;AAAA,MACzF;AAAA,IACJ;AAAA,EACJ,WAAW,OAAO,OAAO,UAAU;AAC/B,UAAM,YAAQ,8CAAgC,MAAM,IAAI,SAAS,EAAE,aAAa,GAAG,aAAa,EAAE;AAClG,UAAM,OAAO,MAAM,cAAc,MAAM;AACvC,UAAM,MAAM,OAAO,MAAM,cAAc,MAAM;AAC7C,UAAM,MAAM,OAAO,MAAM,cAAc,MAAM;AAC7C,QAAI,MAAM,MAAM,MAAM,IAAI;AACtB,aAAO,0BAAM;AAAA,QACR,EAAE,YAAY,EAAE,SAAS,SAAU,MAAM,EAAE,SAAS,MAAM,UAAU,KAAO,QAAQ;AAAA,MACxF;AAAA,IACJ,WAAY,CAAC,QAAQ,MAAM,MAAQ,QAAQ,MAAM,IAAK;AAClD,aAAO,0BAAM;AAAA,QACR,EAAE,SAAS,EAAE,MAAM,SAAU,MAAM,EAAE,MAAM,MAAM,UAAU,KAAO,UAAU,QAAQ;AAAA,MACzF;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,0BAAM,QAAQ,sBAAQ,GAAG;AACpC;AAEA,eAAsB,kBAClB,GACA,OACA,KACA,SAA8B,MACf;AApWnB;AAqWI,UAAQ,wBAAS;AACjB,MAAI,OAAO,QAAQ,UAAU;AACzB,UAAM,mBAAM,SAAS,GAAG;AAAA,EAC5B,WAAW,OAAO,QAAQ,UAAU;AAChC,UAAM,mBAAM,SAAS,SAAS,GAAG,CAAC;AAAA,EACtC;AAEA,MAAI,OAAO,WAAW,UAAU;AAC5B,aAAS,mBAAM,SAAS,MAAM;AAAA,EAClC,WAAW,WAAW,MAAM;AACxB,aAAS;AAAA,EACb,WAAW,OAAO,WAAW,UAAU;AACnC,aAAS,mBAAM,SAAS,SAAS,MAAM,CAAC;AAAA,EAC5C;AAEA,MAAI,CAAC,GAAG;AACJ,WAAO,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,EACvC;AACA,MAAI,OAAO,UAAU,WAAW;AAC5B,UAAM,QAAQ,EAAE,QAAQ,EAAE,KAAK,SAAU,MAAM,EAAE,KAAK,MAAM,UAAU;AACtE,UAAM,QAAQ,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AAClD,QAAI,OAAO;AACP,cAAI,sCAAwB,KAAK,GAAG;AAChC,YAAI,MAAM,YAAY,KAAK,MAAM,YAAY,GAAG;AAC5C,kBAAQ,CAAC;AAAA,QACb;AACA,YAAI,MAAM,aAAa,UAAa,MAAM,YAAY,GAAG;AACrD,kBAAQ,CAAC;AAAA,QACb;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,CAAC,OAAO;AACR,cACK,mBAAE,SAAS,EAAE,MAAM,SAAU,MAAM,EAAE,MAAM,MAAM,UAAU,MAA3D,YACA,UAAU,OAAO,mBAAM,WAAW,MAAM,CAAC,MADzC,YAED,UAFC,YAGD,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,IAEpC;AACA,WAAO,wBAAS,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,EAChD,WAAW,OAAO,UAAU,UAAU;AAClC,QAAI,MAAM,EAAE,QAAQ,EAAE,KAAK,SAAU,MAAM,EAAE,KAAK,MAAM,YAAY;AACpE,QAAI,QAAQ,EAAE,SAAS,EAAE,MAAM,SAAU,MAAM,EAAE,MAAM,MAAM,YAAY;AACzE,UAAM,QAAQ,EAAE,SAAU,MAAM,EAAE,MAAM,UAAU;AAClD,SAAK,CAAC,OAAO,CAAC,cAAU,sCAAwB,KAAK,GAAG;AACpD,cAAQ,MAAM,MAAM;AAAA,QAChB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK,SAAS;AACV;AAAA,QACJ;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK,oBAAoB;AACrB,gBAAM,OAAO,mBAAM;AACnB,kBAAQ,SAAS,mBAAM;AAAA,QAC3B;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,OAAO,SAAS,OAAO;AACvB,UAAI,SAAc;AAClB,cAAI,sCAAwB,KAAK,GAAG;AAChC,YAAI,OAAO;AACX,YAAI,OAAO,MAAM;AACjB,YAAI,OAAO,MAAM;AACjB,YAAI,OAAO,MAAM;AACb,gBAAM,OAAO;AACb,iBAAO;AACP,iBAAO;AACP,gBAAM,QAAQ;AACd,gBAAM;AACN,kBAAQ;AACR,iBAAO;AAAA,QACX;AACA,eAAO,OAAO,QAAQ,OAAO;AAC7B,eAAO,OAAO,QAAQ,OAAO;AAE7B,YAAI,SAAQ,WAAM,aAAN,YAAkB;AAC9B,gBAAQ,UAAU,SAAY,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,KAAK,CAAC,IAAI;AACtE,YAAI,SAAS;AACb,YAAI,OAAO,mBAAM;AACjB,gBAAQ,MAAM,MAAM;AAAA,UAChB,KAAK;AACD,mBAAO,mBAAM;AACb;AAAA,UACJ,KAAK;AACD,mBAAO,mBAAM;AACb;AAAA,UACJ,KAAK;AACD,mBAAO,mBAAM;AACb;AAAA,UACJ,KAAK;AACD,gBAAI,MAAM,aAAa,QAAW;AAC9B,qBAAO,mBAAM;AACb;AAAA,YACJ;AAAA;AAAA,UAEJ,KAAK;AACD,mBAAO,mBAAM;AACb;AAAA,UACJ,KAAK;AACD,gBAAI,MAAM,aAAa,QAAW;AAC9B,qBAAO,mBAAM;AACb;AAAA,YACJ;AAAA;AAAA,UAEJ,KAAK;AACD,mBAAO,mBAAM;AACb;AAAA,QACR;AACA,YAAI,QAAQ,MAAM;AACd,mBAAS;AAAA,QACb,WAAW,UAAU,QAAW;AAC5B,oBAAU,QAAQ,SAAS,OAAO;AAClC,mBAAS,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,MAAM,CAAC;AACxC,mBAAS,oBAAoB,OAAO,MAAM;AAC1C,mBAAS,KAAK,OAAO,KAAK,QAAQ,EAAE,KAAK,CAAC;AAAA,QAC9C,WAAW,SAAS,OAAO;AACvB,kBAAQ,MAAM,aAAa,UAAa,MAAM,aAAa,MAAM,aAAa;AAC9E,mBAAS,KAAK,QAAQ,UAAU,OAAO;AACvC,mBAAS,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,MAAM,CAAC;AACxC,mBAAS,oBAAoB,OAAO,MAAM;AAC1C,mBAAS,KAAK,OAAO,KAAK,QAAQ,EAAE,MAAM,YAAY,KAAK,CAAC;AAAA,QAChE,OAAO;AACH,gBAAM,MAAM,aAAa,UAAa,MAAM,aAAa,MAAM,aAAa;AAC5E,oBAAU,QAAQ,SAAS,QAAQ;AACnC,mBAAS,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,MAAM,CAAC;AACxC,mBAAS,IAAI,oBAAoB,OAAO,IAAI,MAAM;AAClD,mBAAS,KAAK,OAAO,KAAK,QAAQ,EAAE,KAAK,CAAC;AAAA,QAC9C;AACA,eAAO,OAAO,mBAAM,WAAW,MAAM,CAAC;AAAA,MAC1C,eAAW,yCAA2B,KAAK,GAAG;AAC1C,YAAK,MAAM,WAAW,MAAM,WAAW,SAAW,MAAM,WAAW,MAAM,WAAW,OAAQ;AACxF,iBAAO,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,QACvC;AACA,eAAO,mBAAM,WAAW,KAAK,CAAC;AAAA,MAClC;AAAA,IACJ;AACA,QAAI,OAAO;AACP,UAAI,KAAK;AACL,eAAO,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,MACvC;AAAA,IACJ,WAAW,OAAO;AACd,aAAO,OAAO,mBAAM,WAAW,KAAK,CAAC;AAAA,IACzC,WAAW,KAAK;AACZ,aAAO,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,IACvC;AAAA,EACJ;AACA,SAAO,OAAO,mBAAM,WAAW,GAAG,CAAC;AACvC;AAEA,SAAS,oBAAoB,GAAqB,QAAwB;AACtE,MAAI,EAAE,UAAU,QAAW;AACvB,QAAI,EAAE,UAAU,OAAO;AACnB,eAAS,UAAU,KAAK,MAAM;AAC9B,eAAS,SAAS,IAAI,IAAI,SAAS,KAAK,KAAK;AAC7C,eAAS,KAAK,MAAM,MAAM;AAAA,IAC9B,OAAO;AACH,gBAAU,IAAI,WAAW,KAAK,MAAM;AACpC,eAAS,SAAS,IAAI,IAAI,SAAS,KAAK,KAAK;AAC7C,eAAS,KAAK,MAAM,MAAM;AAC1B,eAAS,IAAI;AAAA,IACjB;AAAA,EACJ;AACA,SAAO;AACX;AACA,eAAsB,aAClB,MACA,OACA,MAAqB,MACrB,MAAqB,MACrB,WAAuB,MACR;AAnhBnB;AAqhBI,MAAI,SAAS,QAAW;AACpB,WAAO;AAAA,EACX;AACA,MAAI,mBAAM,MAAM,IAAI,GAAG;AACnB,UAAMA,WAAU;AAChB,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAc,OAAO,UAAU,WAAW,QAAQ;AACtD,YAAM,WAAW,oBAAO;AACxB,YAAM,WAAW,oBAAO;AACxB,YAAM,MAAM,WAAW,WAAW;AAClC,YAAM,MAAM,WAAW,WAAW;AAClC,aAAO;AAAA,QACH,mBAAM;AAAA,UACF,CAAC,WACK,mBAAM,OAAOA,WAAUA,WAAU,mBAAM,OAAO,mBAAM,MAAM,KAAK,UAAU,UAAU,GAAG,CAAC,CAAC,IACxF,mBAAM;AAAA,YACF;AAAA,YACAA,WAAUA,WAAU,mBAAM;AAAA,YAC1B,mBAAM,MAAM,KAAK,UAAU,UAAU,GAAG,CAAC;AAAA,UAC7C;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,OAAO;AACP,aAAO,OAAO,mBAAM,WAAWA,WAAUA,WAAU,mBAAM,KAAK,CAAC;AAAA,IACnE;AACA,WAAO,OAAO,mBAAM,WAAW,WAAW,WAAW,mBAAM,MAAM,CAAC;AAAA,EACtE;AACA,QAAM,UAAU,KAAK,QAAQ,KAAK,KAAK,SAAU,MAAM,KAAK,KAAK,MAAM,YAAY;AACnF,aAAY,KAAK,SAAS,KAAK,MAAM,SAAU,MAAM,KAAK,MAAM,MAAM,YAAY,KAAO;AACzF,MAAI,OAAO,UAAU,UAAU;AAC3B,QAAI,MAAc,OAAO,UAAU,WAAW,QAAQ;AACtD,UAAM,YAAa,UAAK,UAAW,MAAM,KAAK,OAAO,UAAU,KAAO,QAAnD,YAA2D;AAC9E,UAAM,YAAa,UAAK,UAAW,MAAM,KAAK,OAAO,UAAU,KAAO,QAAnD,YAA2D;AAC9E,UAAM,MAAM,WAAW,WAAW;AAClC,UAAM,MAAM,WAAW,WAAW;AAClC,WAAO;AAAA,MACH,mBAAM;AAAA,QACF,CAAC,WACK,mBAAM,OAAO,UAAU,UAAU,mBAAM,OAAO,mBAAM,MAAM,KAAK,UAAU,UAAU,GAAG,CAAC,CAAC,IACxF,mBAAM;AAAA,UACF;AAAA,UACA,UAAU,UAAU,mBAAM;AAAA,UAC1B,mBAAM,MAAM,KAAK,UAAU,UAAU,GAAG,CAAC;AAAA,QAC7C;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAEA,MAAI,OAAO;AACP,WAAO,OAAO,mBAAM,WAAW,UAAU,UAAU,mBAAM,KAAK,CAAC;AAAA,EACnE;AACA,SAAO,OAAO,mBAAM,WAAW,WAAW,WAAW,mBAAM,MAAM,CAAC;AACtE;AAEA,eAAsB,cAClB,GACA,OACA,KACe;AAhlBnB;AAilBI,MAAI,MAAM,QAAW;AACjB,WAAO;AAAA,EACX;AACA,MAAI,OAAO,QAAQ,UAAU;AACzB,UAAM,OAAO,GAAG;AAAA,EACpB,WAAW,OAAO,QAAQ,UAAU;AAChC,UAAM,OAAO,mBAAM,WAAW,GAAG,CAAC;AAAA,EACtC;AACA,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,QAAM,QAAQ,EAAE,QAAS,MAAM,EAAE,KAAK,UAAU;AAChD,MAAI,CAAC,OAAO;AACR,YAAQ,aAAE,SAAU,MAAM,EAAE,MAAM,UAAU,MAApC,YAA2C,UAA3C,YAAoD;AAAA,EAChE;AACA,SAAO,wBAAS;AACpB;AAeA,eAAsB,kBAClB,GACA,IACA,YAAqB,OACC;AApnB1B;AAqnBI,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,MAAI,OAAO,OAAO,UAAU;AACxB,SAAK,KAAK;AAAA,EACd;AACA,MAAI,QAAQ;AACZ,MAAI,IAAmB;AACvB,MAAI,KAAC,6BAAW,CAAC,GAAG;AAChB,YAAI,6BAAW,EAAE,IAAI,GAAG;AACpB,WAAK,OAAE,QAAS,MAAM,EAAE,KAAK,UAAU,MAAlC,YAAyC;AAC9C,UAAI,WAAW;AACX,cAAM,UACA,OAAE,QAAQ,EAAE,KAAK,UAAU,EAAE,KAAK,OAAO,WAAzC,YAA0F;AAChG,YAAI,UAAU,MAAM,QAAQ,OAAO,WAAW,UAAU;AACpD,cAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AACxB,iBAAI,YAAO,CAAC,MAAR,YAAa;AAAA,UACrB,WAAW,CAAC,MAAM,OAAO,CAAC,CAAC,GAAG;AAC1B,iBAAI,YAAO,OAAO,CAAC,CAAC,MAAhB,YAAqB;AAAA,UAC7B;AAAA,QACJ;AAAA,MACJ;AACA,cAAQ,gBAAK;AAAA,IACjB,OAAO;AACH,eAAS,OAAE,QAAQ,EAAE,KAAK,UAAW,MAAM,EAAE,KAAK,OAAO,UAAU,MAA1D,YAAiE;AAC1E,WAAK,OAAE,QAAQ,EAAE,KAAK,SAAU,MAAM,EAAE,KAAK,MAAM,UAAU,MAAxD,YAA+D;AACpE,eAAS,gBAAK;AACd,gBAAU,OAAE,QAAQ,EAAE,KAAK,UAAW,MAAM,EAAE,KAAK,OAAO,UAAU,MAA1D,YAAiE;AAAA,IAC/E;AAEA,QAAI,EAAE,kBAAM,OAAO;AACf,UAAI,SAAS;AACb,UAAI,KAAoB;AACxB,cAAI,6BAAW,EAAE,KAAK,GAAG;AACrB,cAAM,OAAE,SAAU,MAAM,EAAE,MAAM,UAAU,MAApC,YAA2C;AACjD,YAAI,WAAW;AACX,gBAAM,UACA,OAAE,SAAS,EAAE,MAAM,UAAU,EAAE,MAAM,OAAO,WAA5C,YACF;AACJ,cAAI,UAAU,OAAO,QAAQ,OAAO,WAAW,UAAU;AACrD,gBAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AACxB,oBAAK,YAAO,EAAE,MAAT,YAAc;AAAA,YACvB,WAAW,CAAC,MAAM,OAAO,EAAE,CAAC,GAAG;AAC3B,oBAAK,YAAO,OAAO,EAAE,CAAC,MAAjB,YAAsB;AAAA,YAC/B;AAAA,UACJ;AAAA,QACJ;AACA,iBAAS,kBAAM;AAAA,MACnB,OAAO;AACH,kBAAU,OAAE,SAAS,EAAE,MAAM,UAAW,MAAM,EAAE,MAAM,OAAO,UAAU,MAA7D,YAAoE;AAC9E,cAAM,OAAE,SAAS,EAAE,MAAM,SAAU,MAAM,EAAE,MAAM,MAAM,UAAU,MAA3D,YAAkE;AACxE,kBAAU,kBAAM;AAChB,mBAAW,OAAE,SAAS,EAAE,MAAM,UAAW,MAAM,EAAE,MAAM,OAAO,UAAU,MAA7D,YAAoE;AAAA,MACnF;AAEA,aAAO,MAAM,OAAQ,KAAK,OAAO,OAAO,QAAS;AAAA,IACrD;AAEA,WAAO,KAAK,OAAO,OAAO;AAAA,EAC9B;AACA,UAAQ,WAAM,EAAE,UAAU,MAAlB,YAAwB;AACpC;AAEA,eAAsB,qBAClB,GACuB;AACvB,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,QAAM,OAAO,EAAE,SAAU,MAAM,EAAE,MAAM,WAAW;AAClD,MAAI,SAAS,QAAW;AACpB,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,oBAAoB,GAAwE;AACjG,SAAO,cAAe;AAC1B;AACA,eAAsB,oBAClB,GACA,IAAmB,MACG;AAtsB1B;AAusBI,MAAI,CAAC,KAAK,CAAC,EAAE,OAAO;AAChB,WAAO;AAAA,EACX;AACA,QAAM,OAAO,MAAM,OAAO,IAAI,MAAM,oBAAoB,CAAC;AACzD,QAAM,UAAW,OAAE,cAAe,MAAM,EAAE,WAAW,UAAU,MAA9C,YAA6D;AAC9E,QAAM,QAAQ,mBAAM,OAAE,SAAF,mBAAQ,iBAAd,YAA8B,EAAE,MAAM,OAAO,SAA7C,YAAqD;AACnE,QAAM,UAAU,aAAM,OAAE,WAAF,mBAAU,iBAAhB,YAAgC;AAChD,QAAM,UAAU,aAAM,OAAE,WAAF,mBAAU,iBAAhB,YAAgC;AAEhD,MAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,QAAIC,OAAM;AACV,YAAI,gCAAkB,MAAM,GAAG;AAC3B,UAAI,OAAO,GAAG;AACV,eAAO;AAAA,MACX;AACA,YAAM,OAAO,IAAI,KAAK,IAAI;AAC1B,UAAI,YAAY,IAAI,GAAG;AACnB,QAAAA,OAAM,KAAK,eAAe,OAAO,OAAO,OAAO,MAAM;AAAA,MACzD;AAAA,IACJ,OAAO;AACH,YAAM,KAAK,kBAAa,KAAK,EAAE,WAAY,MAAM,EAAE,QAAQ,UAAU,MAA1D,YAAiE;AAC5E,UAAI,MAAM,QAAQ,MAAM,OAAO;AAC3B,QAAAA,OAAM,KAAK,gBAAgB,eAAU,OAAO,UAAjB,YAA2B,SAAS;AAAA,UAC3D,uBAAuB;AAAA,UACvB,uBAAuB;AAAA,UACvB,aAAa;AAAA,QACjB,CAAC;AAAA,MACL,OAAO;AACH,QAAAA,OAAM,KAAK,gBAAgB,eAAU,OAAO,UAAjB,YAA2B,SAAS;AAAA,UAC3D,aAAa;AAAA,QACjB,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,IAAAA,OAAM,SAASA,OAAM,OAAO;AAC5B,QAAI,MAAM;AACV,QAAI,oBAAoB,CAAC,GAAG;AACxB,YAAM,QAAQ,OAAE,YAAa,MAAM,EAAE,SAAS,UAAU,MAA1C,YAAiD,EAAE;AAAA,IACrE;AACA,WAAOA,QAAO,MAAM,OAAI,GAAG,KAAK;AAAA,EACpC;AACA,MAAI,MAAM,MAAM,EAAE,MAAM,UAAU;AAElC,MAAI,OAAO,MAAM;AACb,YAAI,gCAAkB,MAAM,GAAG;AAC3B,YAAM,OAAO,IAAI,KAAK,GAAG;AACzB,UAAI,YAAY,IAAI,GAAG;AACnB,cAAM,KAAK,eAAe,OAAO,OAAO,OAAO,MAAM;AAAA,MACzD;AAAA,IACJ;AAEA,UAAM,SAAS,MAAM,OAAO;AAC5B,QAAI,MAAM;AACV,QAAI,oBAAoB,CAAC,GAAG;AACxB,YAAM,QAAQ,OAAE,YAAa,MAAM,EAAE,SAAS,UAAU,MAA1C,YAAiD,EAAE;AAAA,IACrE;AACA,WAAO,MAAM,OAAI,GAAG,KAAK;AAAA,EAC7B;AACA,SAAO;AACX;AA6BO,SAAS,UAAU,MAAc,MAAc,OAA4C;AAC9F,MAAI,KAAK,UAAU,MAAM;AACrB,WAAO;AAAA,EACX;AACA,MAAI,QAAQ;AACZ,QAAM,OAAO,OAAO,KAAK;AACzB,MAAI,UAAU,QAAQ;AAClB,YAAQ,OAAO,IAAI,OAAO,IAAI;AAAA,EAClC,WAAW,UAAU,SAAS;AAC1B,YAAQ,IAAI,OAAO,IAAI,IAAI;AAAA,EAC/B,WAAW,UAAU,UAAU;AAC3B,UAAM,QAAQ,KAAK,MAAM,OAAO,CAAC;AACjC,UAAM,OAAO,OAAO;AACpB,YAAQ,IAAI,OAAO,IAAI,IAAI,OAAO,IAAI,OAAO,KAAK;AAAA,EACtD;AACA,SAAO;AACX;AAEO,MAAM,aAAa;AAAA;AAAA,EAEtB,EAAE,QAAQ,KAAK,MAAM,SAAS,QAAQ,GAAG;AAAA,EACzC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,GAAG;AAAA,EACxC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,GAAG;AAAA,EACxC,EAAE,QAAQ,UAAK,MAAM,SAAS,QAAQ,GAAG;AAAA,EACzC,EAAE,QAAQ,KAAK,MAAM,SAAS,QAAQ,GAAG;AAAA;AAAA,EAGzC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,EAAE;AAAA,EACvC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,EAAE;AAAA,EACvC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,EAAE;AAAA,EACvC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,EAAE;AAAA,EACvC,EAAE,QAAQ,KAAK,MAAM,QAAQ,QAAQ,EAAE;AAC3C;AAmCA,eAAsB,iBAClB,GACA,GACA,OACA,OAAsB,MACtB,cAA6B,MAC7B,YAAoB,GACiD;AAz2BzE;AA02BI,MAAI,CAAC,KAAK,CAAC,EAAE,OAAO;AAChB,WAAO,CAAC;AAAA,EACZ;AAEA,MAAK,KAAK,QAAQ,QAAQ,QAAU,KAAK,QAAQ,QAAQ,MAAO;AAC5D,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACnE;AACA,MAAI,QAAQ,KAAK,OAAO,IAAI,MAAM,oBAAoB,GAAG,QAAW,EAAE,eAAe,KAAK,CAAC;AAC3F,QAAM,UAAU,aAAE,QAAS,MAAM,EAAE,KAAK,UAAU,MAAlC,YAAyC,EAAE,MAAM,OAAO,SAAxD,YAAgE,IAAI,KAAK;AACzF,QAAM,WAAW,kBAAa,KAAK,EAAE,WAAY,MAAM,EAAE,QAAQ,UAAU,MAA1D,YAAiE;AAClF,QAAM,OAAO;AACb,MAAI,cAAc,UAAa,cAAc,MAAM;AAC/C,gBAAY;AACZ,eAAW,KAAK,YAAY;AACxB,UAAI,MAAM,WAAW,EAAE,MAAM,GAAG;AAC5B,oBAAY,EAAE;AACd;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,MAAM;AAEV,MAAI,aAAa,eAAe,QAAQ,cAAc,YAAY,YAAY;AAE9E,MAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,UAAM,YAAY,QAAQ;AAC1B,YAAQ,KAAK,IAAI,KAAK;AACtB,QAAI,SAAS;AACb,QAAI,QAAQ,QAAQ,UAAU,MAAM;AAChC,iBAAW,KAAK,YAAY;AACxB,YAAI,MAAM,WAAW,EAAE,MAAM,GAAG;AAC5B,iBAAO,MAAM,UAAU,EAAE,OAAO,MAAM;AACtC,mBAAS,EAAE;AACX;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,SAAS,MAAM;AACf,eAAO;AAAA,MACX;AAAA,IACJ;AACA,aAAS,OAAO,IAAI;AACpB,QAAI,YAAY,QAAQ,OAAO,IAAI;AAEnC,QAAI,IAAI,WAAW,QAAQ,YAAY,QAAQ,UAAU;AACzD,UAAM,WAAW,SAAS,IAAI,IAAI,IAAI;AAEtC,QAAI,WAAW,IAAI,IAAI,KAAK,IAAI;AAChC,QAAI,IAAI,IAAI,IAAI;AAChB,QAAI,gBAAgB;AACpB,WAAO,CAAC,MAAM;AACV,UAAI,aAAa,KAAK,aAAa,aAAa,kBAAkB,IAAI;AAClE,cAAM,aAAa,aAAa,QAAsB,OAAO,IAAI,EAAE,aAAa,QAAQ,CAAC,IAAI;AAC7F;AAAA,MACJ;AACA,kBAAY,KAAK,MAAM,YAAY,MAAM,CAAC,IAAI,MAAM;AACpD,UAAI,KAAK,MAAM,YAAY,MAAM,CAAC,MAAM,KAAK,YAAY,IAAI,OAAO,KAAK,MAAM,WAAW,CAAC,IAAI,IAAI;AAC/F,oBAAY,QAAQ,OAAO,IAAI,EAAE;AACjC;AAAA,MACJ;AAEA,YAAM,UAAU,QAAQ,CAAC;AACzB,UAAI,IAAI,SAAS,OAAO;AACpB,YAAI,aAAa,MAAM,UAAU;AAC7B,sBAAY,QAAQ,OAAO,IAAI,EAAE;AACjC;AAAA,QACJ;AAAA,MACJ,OAAO;AACH;AAAA,MACJ;AAAA,IACJ;AAKA,UAAM,YAAY,IAAI,GAAG,KAAK;AAAA,EAClC;AACA,QAAM,QAAQ,WAAW,UAAU,OAAK,EAAE,WAAW,UAAU;AAC/D,SAAO,UAAU,KAAK,WAAW,KAAK,EAAE,SAAS,OAAO;AAExD,SAAO,EAAE,OAAO,KAAK,MAAY,WAAW,WAAW;AAC3D;AAEO,SAAS,eAAe,SAAkB,MAAW,MAAuB;AAC/E,MAAI,SAAS,sBAAQ;AACrB,MAAI,SAAS,QAAW;AACpB,aAAS,QAAQ,oBAAoB,MAAM,IAAI;AAAA,EACnD;AACA,WAAS,QAAQ,eAAe,UAAU,IAAI;AAC9C,SAAO;AACX;AAEO,MAAM,qBAAqB,OAAO,SAA8D;AAr8BvG;AAs8BI,MAAI,CAAC,MAAM;AACP,WAAO,mBAAM;AAAA,EACjB;AACA,QAAM,OAAO,UAAK,OAAQ,MAAM,KAAK,IAAI,UAAU,MAAtC,YAA6C;AAC1D,QAAM,SAAS,UAAK,SAAU,MAAM,KAAK,MAAM,UAAU,MAA1C,YAAiD;AAChE,QAAM,QAAQ,UAAK,QAAS,MAAM,KAAK,KAAK,UAAU,MAAxC,YAA+C;AAC7D,MAAI,QAAQ,MAAM,SAAS,MAAM,UAAU,IAAI;AAC3C,WAAO;AAAA,EACX;AACA,SAAO,EAAE,GAAG,KAAK,GAAG,OAAO,GAAG,KAAK;AACvC;AACO,MAAM,qBAAqB,OAAO,SAAiE;AACtG,QAAM,MAAM,MAAM,mBAAmB,IAAI;AACzC,MAAI,CAAC,KAAK;AACN,WAAO;AAAA,EACX;AACA,SAAO,OAAO,mBAAM,WAAW,GAAG,CAAC;AACvC;AACO,MAAM,qBAAqB,OAAO,MAAsC,MAA0B;AACrG,MAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,CAAC,KAAK,SAAS,CAAC,KAAK,MAAM;AACjD;AAAA,EACJ;AACA,QAAM,KAAK,IAAI,SAAS,EAAE,CAAC;AAC3B,QAAM,KAAK,MAAM,SAAS,EAAE,CAAC;AAC7B,QAAM,KAAK,KAAK,SAAS,EAAE,CAAC;AAChC;AAEO,MAAM,gBAAgB,OAAO,SAAiE;AAj+BrG;AAk+BI,MAAI,CAAC,QAAQ,CAAC,KAAK,KAAK;AACpB,WAAO;AAAA,EACX;AACA,QAAM,MAAM,MAAM,KAAK,IAAI,UAAU;AACrC,MAAI,aAAa,KAAK,KAAK,UAAK,cAAe,MAAM,KAAK,WAAW,UAAU,MAApD,YAA2D,CAAC;AACvF,MAAI,aAAa,GAAG;AAChB,iBAAa;AAAA,EACjB;AACA,MAAI,QAAQ,MAAM;AACd,WAAO;AAAA,EACX;AACA,QAAM,MAAM,mBAAM,QAAQ,KAAK,YAAY,CAAC;AAC5C,SAAO,OAAO,mBAAM,WAAW,EAAE,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC;AACvE;AAEO,MAAM,gBAAgB,OAAO,MAAsC,MAA0B;AAChG,MAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,CAAC,mBAAM,MAAM,CAAC,GAAG;AACvC;AAAA,EACJ;AACA,MAAI,CAAC,KAAK,IAAI,WAAW;AACrB;AAAA,EACJ;AAGA,QAAM,MAAM,mBAAM,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AACtC,QAAM,KAAK,IAAI,SAAS,GAAG;AAC/B;AAUO,SAAS,gBAAgB,MAAoD;AAChF,MAAI,CAAC,MAAM;AACP,WAAO;AAAA,EACX;AAGA,QAAM,QAAQ,MAAM,QAAQ,IAAI,IAC1B,OACA,KAAK,WAAW,KAAK,GAAG,EAAE,WAAW,MAAM,GAAG,EAAE,WAAW,KAAK,GAAG,EAAE,MAAM,KAAK;AAEtF,QAAM,WAAW;AACjB,QAAM,YAAY;AAClB,QAAM,WAAW;AAGjB,QAAM,QAAkB,CAAC;AACzB,MAAI,OAAO;AACX,aAAW,QAAQ,OAAO;AACtB,QAAI,OAAO,KAAK,UAAU,MAAM,SAAS,IAAI,KAAK,UAAU;AACxD;AAAA,IACJ;AACA,UAAM,KAAK,IAAI;AACf,YAAQ,KAAK,SAAS;AAAA,EAC1B;AAGA,QAAM,aAAa,MAAM,MAAM,MAAM,MAAM;AAC3C,MAAI,QAAQ,WAAW,KAAK,GAAG;AAC/B,MAAI,MAAM,SAAS,WAAW;AAC1B,YAAQ,GAAG,MAAM,UAAU,GAAG,QAAQ,CAAC;AAAA,EAC3C;AAEA,SAAO,MAAM,SAAS,IAAI,GAAG,MAAM,KAAK,GAAG,CAAC;AAAA,EAAO,MAAM,KAAK,CAAC,KAAK,MAAM,KAAK;AACnF;AASO,SAAS,gBAAgB,KAA+C;AAhjC/E;AAijCI,MAAI,CAAC,OAAO,CAAC,IAAI,iBAAiB,CAAC,IAAI,MAAM;AACzC,WAAO;AAAA,EACX;AACA,QAAM,KAAe,CAAC;AACtB,MAAI,IAAI,QAAQ;AACZ,OAAG,KAAK,IAAI,MAAM;AAAA,EACtB;AACA,MAAI,IAAI,OAAO;AACX,OAAG,KAAK,IAAI,KAAK;AAAA,EACrB;AACA,MAAI,IAAI,eAAe;AACnB,OAAG,KAAK,IAAI,aAAa;AAAA,EAC7B;AACA,SAAO;AAAA,KACH,SAAI,SAAJ,YAAY,mBAAmB;AAAA,KAC/B,QAAG,KAAK,GAAG,MAAX,YAAgB,mBAAmB;AAAA,KACnC,SAAI,SAAJ,YAAY,mBAAmB;AAAA,KAC/B,SAAI,cAAJ,YAAiB,mBAAmB;AAAA,KACpC,SAAI,gBAAJ,YAAmB,mBAAmB;AAAA,KACtC,SAAI,kBAAJ,YAAqB,mBAAmB;AAAA,EAC5C;AACJ;AAEO,SAAS,gBAAgB,GAAkB;AAC9C,SAAO,EAAE,KAAK,GAAG;AACrB;AACO,SAAS,cAAc,GAAqB;AAC/C,SAAO,EAAE,KAAK,GAAG;AACrB;AAUA,MAAM,gBAAgB,CAAC,MACnB,OAAO,UAAU,SAAS,KAAK,CAAC,MAAM;AAO1C,MAAM,KAAK,CAAoB,MAAwC,MAAM,OAAO,SAAY;AAchG,SAAS,iBAAiB,GAAqB;AAC3C,MAAI,CAAC,cAAc,CAAC,GAAG;AACnB,WAAO;AAAA,EACX;AAEA,QAAM,OAAQ,EAAU;AACxB,QAAM,OAAQ,EAAU;AAExB,MAAI,SAAS,QAAQ;AACjB,UAAM,eAAe,YAAa,KAAa,UAAW,KAAa,gBAAiB;AACxF,WAAO,CAAC,CAAC;AAAA,EACb;AACA,MAAI,SAAS,SAAS;AAClB,WAAO,cAAe;AAAA,EAC1B;AACA,MAAI,SAAS,WAAW,SAAS,aAAa;AAC1C,WAAO,OAAQ,EAAU,OAAO;AAAA,EACpC;AAEA,SAAO;AACX;AAcO,SAAS,WAAW,KAAuB,QAA0B,QAAgB,GAAQ;AAChG,MAAI,QAAQ,IAAI;AACZ,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACrE;AAEA,QAAM,GAAG,GAAG;AACZ,WAAS,GAAG,MAAM;AAElB,MAAI,WAAW,QAAW;AACtB,WAAO,UAAU,GAAG;AAAA,EACxB;AAEA,MAAI,cAAc,GAAG,KAAK,cAAc,MAAM,GAAG;AAE7C,QAAI,iBAAiB,MAAM,KAAK,iBAAiB,GAAG,GAAG;AACnD,aAAO,UAAU,0BAAU,GAAG;AAAA,IAClC;AAEA,UAAM,MAA+B,CAAC;AACtC,UAAM,OAAO,oBAAI,IAAI,CAAC,GAAG,OAAO,KAAK,GAAG,GAAG,GAAG,OAAO,KAAK,MAAM,CAAC,CAAC;AAClE,eAAW,KAAK,MAAM;AAClB,YAAM,KAAK,GAAI,IAAgC,CAAC,CAAC;AACjD,YAAM,KAAK,GAAI,OAAmC,CAAC,CAAC;AAEpD,UAAI,OAAO,QAAW;AAClB,YAAI,CAAC,IAAI,UAAU,EAAE;AAAA,MACzB,WAAW,cAAc,EAAE,KAAK,cAAc,EAAE,GAAG;AAC/C,YAAI,CAAC,IAAI,WAAW,IAAI,IAAI,QAAQ,CAAC;AAAA,MACzC,WAAW,MAAM,QAAQ,EAAE,KAAK,MAAM,QAAQ,EAAE,GAAG;AAC/C,YAAI,CAAC,IAAI,UAAU,EAAE;AAAA,MACzB,OAAO;AACH,YAAI,CAAC,IAAI,UAAU,EAAE;AAAA,MACzB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAGA,SAAO,UAAU,MAAM;AAC3B;AAOA,SAAS,UAA6B,GAAa;AAC/C,MAAI,GAAG,CAAC;AAER,MAAI,aAAa,QAAQ;AACrB,WAAO,IAAI,OAAO,EAAE,QAAQ,EAAE,KAAK;AAAA,EACvC;AACA,MAAI,MAAM,QAAQ,CAAC,GAAG;AAClB,WAAO,EAAE,IAAI,SAAS;AAAA,EAC1B;AACA,MAAI,cAAc,CAAC,GAAG;AAClB,UAAM,IAA6B,CAAC;AACpC,eAAW,KAAK,OAAO,KAAK,CAAC,GAAG;AAC5B,QAAE,CAAC,IAAI,UAAW,EAAU,CAAC,CAAC;AAAA,IAClC;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEO,SAAS,oBACZ,MACA,MACA,QAAiB,MACG;AACpB,SAAO;AAAA,IACH,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN;AAAA,EACJ;AACJ;AAEO,SAAS,oBAAoB,WAAgB,SAAyB;AACzE,MAAI,qBAAqB,OAAO;AAC5B,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,0BAAoB,UAAU,CAAC,GAAG,OAAO;AAAA,IAC7C;AAAA,EACJ,OAAO;AACH,eAAW,QAAQ,WAAW;AAC1B,UAAI,QAAQ,QAAQ,IAAI,MAAM,IAAI;AAC9B;AAAA,MACJ;AACA,UAAI,QAAQ,QAAQ;AAChB,YAAI,UAAU,IAAI,MAAM,aAAa;AACjC,oBAAU,IAAI,IAAI;AAAA,QACtB;AAAA,MACJ;AACA,UAAI,UAAU,IAAI,aAAa,UAAU,UAAU,IAAI,aAAa,OAAO;AACvE,4BAAoB,UAAU,IAAI,GAAG,OAAO;AAAA,MAChD;AAAA,IACJ;AAAA,EACJ;AACJ;AAEO,SAAS,UAAU,OAAe,SAAuE;AAC5G,MAAI,CAAC,OAAO;AACR,WAAO;AAAA,EACX;AACA,MAAI,MAAM,WAAW,GAAG,KAAK,MAAM,YAAY,GAAG,IAAI,KAAK,MAAM,SAAS,GAAG,GAAG;AAC5E,UAAM,OAAO,MAAM,YAAY,GAAG;AAClC,UAAMC,WAAU,MAAM,MAAM,GAAG,IAAI;AACnC,UAAM,QAAQ,MAAM,MAAM,OAAO,CAAC;AAClC,WAAO,IAAI,OAAOA,UAAS,SAAS,MAAS;AAAA,EACjD;AAGA,MAAI,MAAM,WAAW,GAAG,GAAG;AACvB,YAAQ,KAAK,iFAAiF;AAC9F,YAAQ,MAAM,MAAM,CAAC;AAAA,EACzB;AAGA,MAAI,UAAU,YAAY,KAAK;AAG/B,MAAI,EAAC,mCAAS,aAAY;AACtB,cAAU,MAAM,OAAO;AAAA,EAC3B,OAAO;AACH,cAAU,IAAI,OAAO;AAAA,EACzB;AAEA,MAAI,EAAC,mCAAS,WAAU;AACpB,cAAU,GAAG,OAAO;AAAA,EACxB,OAAO;AACH,cAAU,GAAG,OAAO;AAAA,EACxB;AAEA,SAAO,IAAI,OAAO,OAAO;AAC7B;AAEA,SAAS,YAAY,GAAmB;AACpC,SAAO,EAAE,QAAQ,wBAAwB,MAAM;AACnD;AAwBO,SAAS,gBAAgB,MAAc,YAA4B;AACtE,MAAI,cAAc,KAAK,CAAC,MAAM;AAC1B,WAAO;AAAA,EACX;AAEA,QAAM,SAAmB,CAAC;AAC1B,QAAM,QAAQ,KAAK,MAAM,IAAI;AAE7B,aAAW,QAAQ,OAAO;AACtB,QAAI,KAAK,UAAU,YAAY;AAC3B,aAAO,KAAK,IAAI;AAChB;AAAA,IACJ;AAEA,QAAI,QAAQ;AACZ,UAAM,MAAM,KAAK;AAEjB,WAAO,QAAQ,KAAK;AAChB,YAAM,MAAM,KAAK,IAAI,QAAQ,YAAY,GAAG;AAG5C,UAAI,QAAQ,KAAK;AACb,eAAO,KAAK,KAAK,MAAM,KAAK,CAAC;AAC7B;AAAA,MACJ;AAGA,YAAM,WAAW,KAAK,YAAY,KAAK,GAAG;AAC1C,UAAI,YAAY,OAAO;AAEnB,eAAO,KAAK,KAAK,MAAM,OAAO,GAAG,CAAC;AAClC,gBAAQ;AAAA,MACZ,OAAO;AAEH,eAAO,KAAK,KAAK,MAAM,OAAO,QAAQ,CAAC;AACvC,gBAAQ,WAAW;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,OAAO,KAAK,IAAI;AAC3B;AAEO,SAAS,YAAY,GAAoB;AAC5C,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,SAAO,aAAa,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC;AAClD;AAEO,SAAS,mBAAmB,SAAyB;AACxD,SAAO,QACF,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,MAAM,SAAS,IAAI,IAAI,KAAK,IAAI,KAAM,IAAI,CAAC,CAAC,EACvD,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC;AAC/B;AAEO,SAAS,wBAAwB,GAAW,GAAoB;AACnE,QAAM,OAAO,mBAAmB,CAAC;AACjC,QAAM,OAAO,mBAAmB,CAAC;AACjC,SAAO,QAAQ;AACnB;AACO,SAAS,mBACZ,OACA,UASI,CAAC,GAC4B;AA53CrC;AA63CI,QAAM;AAAA,IACF,UAAU;AAAA,IACV,SAAS;AAAA,IACT,SAAS;AAAA,IACT,MAAM;AAAA,IACN;AAAA,IACA,MAAM;AAAA,IACN,MAAM;AAAA,IACN,cAAc;AAAA,EAClB,IAAI;AAEJ,QAAM,SAAQ,uCAAc,WAAd,YAAwB;AACtC,QAAM,SAAS,MAAM,SAAS,IAAI,MAAM;AACxC,QAAM,gBAAgB,UAAU,OAAO,SAAS,OAAO,SAAS,MAAM;AAEtE,MAAI,iBAAiB,GAAG;AACpB,UAAM,QAAQ,GAAG,MAAM,GAAG,MAAM,GAAG,KAAK;AACxC,WAAO,EAAE,MAAM,MAAM,MAAM,CAAC,OAAO,GAAG,SAAS,IAAI;AAAA,EACvD;AAGA,MAAI,MAAM,UAAU,eAAe;AAC/B,UAAM,QAAQ,gBAAgB,MAAM;AACpC,UAAM,UAAU,KAAK,MAAM,QAAQ,CAAC;AACpC,UAAM,WAAW,QAAQ;AACzB,UAAMC,QAAO,IAAI,OAAO,OAAO,IAAI,QAAQ,IAAI,OAAO,QAAQ;AAC9D,WAAO,EAAE,MAAM,GAAG,MAAM,GAAGA,KAAI,GAAG,MAAM,GAAG,KAAK,IAAI,SAAS,IAAI;AAAA,EACrE;AAIA,QAAM,QAAQ,MAAM,QAAQ;AAC5B,QAAM,WAAW,MAAM;AACvB,QAAM,UAAU,QAAQ;AAExB,QAAM,aAAa,IAAI;AACvB,QAAM,SAAS,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,WAAW,CAAC;AACnD,QAAM,aAAa,KAAK,MAAM,gBAAgB,MAAM;AACpD,QAAM,WAAW,aAAa,aAAa,YAAY;AAEvD,QAAM,WAAW,MAAM,WAAW;AAClC,QAAM,OAAO,QAAQ,OAAO,SAAS,aAAa;AAElD,QAAM,OAAO,GAAG,MAAM,GAAG,IAAI,GAAG,MAAM,GAAG,KAAK;AAC9C,QAAM,WAAW,MAAM,KAAK;AAE5B,SAAO,EAAE,MAAM,MAAM,QAAQ;AACjC;AAyBO,SAAS,UAAU,IAAoB;AAC1C,MAAI,CAAC,OAAO,SAAS,EAAE,KAAK,KAAK,GAAG;AAChC,SAAK;AAAA,EACT;AAEA,QAAM,eAAuB,KAAK,MAAM,KAAK,GAAI;AACjD,QAAM,QAAgB,KAAK,MAAM,eAAe,IAAI;AACpD,QAAM,UAAkB,KAAK,MAAO,eAAe,OAAQ,EAAE;AAC7D,QAAM,UAAkB,eAAe;AAEvC,QAAM,aAAa,OAAO,OAAO;AACjC,QAAM,aAAqB,OAAO,OAAO,EAAE,SAAS,GAAG,GAAG;AAE1D,MAAI,QAAQ,GAAG;AAEX,WAAO,GAAG,KAAK,IAAI,WAAW,SAAS,GAAG,GAAG,CAAC,IAAI,UAAU;AAAA,EAChE;AAEA,SAAO,GAAG,UAAU,IAAI,UAAU;AACtC;AAEO,SAAS,gCACZ,SACA,OACA,KACM;AACN,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO;AAAA,EACX;AACA,MAAI,QAAQ,YAAY,MAAM,QAAQ,QAAQ,GAAG;AAC7C,WAAO,MAAM,QAAQ,QAAQ;AAAA,EACjC;AACA,MAAI,MAAM,IAAI;AACV,WAAO,MAAM;AAAA,EACjB;AACA,SAAO,oBAAO;AAClB;AAEA,IAAO,gBAAQ;",
  "names": ["onColor", "res", "pattern", "left"]
}
