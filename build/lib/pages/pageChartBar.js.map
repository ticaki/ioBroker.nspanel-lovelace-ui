{
  "version": 3,
  "sources": ["../../../src/lib/pages/pageChartBar.ts"],
  "sourcesContent": ["import { type PageInterface } from '../classes/PageInterface';\nimport type * as pages from '../types/pages';\nimport { isChartDetailsExternal, PageChart } from './pageChart';\n\n/**\n * Klasse zur Darstellung von Balkendiagrammen (Bar Charts)\n * Erweitert die PageChart-Klasse um spezifische Funktionalit\u00E4t f\u00FCr Balkendiagramme\n */\nexport class PageChartBar extends PageChart {\n    constructor(config: PageInterface, options: pages.PageBase) {\n        // Aufruf des Konstruktors der Basisklasse\n        super(config, options);\n    }\n\n    /**\n     * Initialisiert die Balkendiagramm-Seite\n     * - Verarbeitet die Konfiguration (Auto-Modus \u00FCber Enums oder dpInit)\n     * - Erstellt die Datenelemente\n     * - Pr\u00FCft ob DB-Details vorhanden sind und setzt ggf. die DB-Datenabruf-Methode\n     */\n    async init(): Promise<void> {\n        const config = structuredClone(this.config);\n\n        // Suche nach States f\u00FCr den Auto-Modus (\u00FCber Enums oder dpInit)\n        const tempConfig: Partial<pages.cardChartDataItemOptions> =\n            this.enums || this.dpInit\n                ? await this.basePanel.statesControler.getDataItemsFromAuto(this.dpInit, config, undefined, this.enums)\n                : config;\n\n        // Erstelle die Datenelemente aus der Konfiguration\n        const tempItem: Partial<pages.cardChartDataItems> = await this.basePanel.statesControler.createDataItems(\n            tempConfig,\n            this,\n        );\n        if (tempItem) {\n            tempItem.card = this.card as 'cardChart';\n            this.log.debug(`init Card: ${this.card}`);\n        }\n        this.items = tempItem as pages.cardChartDataItems;\n\n        // Wenn DB-Details vorhanden sind, getChartData auf getChartDataDB setzen\n        // Dies ist notwendig, da PageChart die Methode getChartDataScript als Standardmethode hat\n        if (this.items && this.items.data && this.items.data.dbData) {\n            const dbDetails = await this.items.data.dbData.getObject();\n            if (isChartDetailsExternal(dbDetails)) {\n                this.dbDetails = dbDetails;\n                this.getChartData = this.getChartDataDB;\n            }\n        }\n        await super.init();\n    }\n\n    /**\n     * Holt Diagrammdaten aus der Datenbank und bereitet sie f\u00FCr die Darstellung auf\n     * \u00DCberschreibt die Standard-Methode aus PageChart f\u00FCr den Fall, dass DB-Details konfiguriert sind\n     *\n     * @param ticksChart - Array f\u00FCr die Y-Achsen-Beschriftung (Standard: ['~'])\n     * @param valuesChart - String mit den Diagrammwerten (Standard: '~')\n     * @returns Objekt mit ticksChart (Y-Achsen-Ticks) und valuesChart (Datenpunkte mit optionalen Zeitangaben)\n     */\n    async getChartDataDB(\n        ticksChart: string[] = ['~'],\n        valuesChart = '~',\n    ): Promise<{ ticksChart: string[]; valuesChart: string }> {\n        if (this.dbDetails) {\n            const items = this.dbDetails;\n\n            // Konfigurationsparameter aus den DB-Details extrahieren\n            const rangeHours = items.hours || 24; // Zeitbereich in Stunden\n            const stateValue = items.state || ''; // State-ID f\u00FCr die Daten\n            const instance = items.instance || ''; // DB-Instanz\n            const maxXAxisLabels = items.maxLabels || 4; // Maximale Anzahl der X-Achsen-Beschriftungen\n            const factor = items.factor || 1; // Umrechnungsfaktor f\u00FCr die Werte\n            const tempScale: number[] = []; // Tempor\u00E4res Array f\u00FCr die Skalierung\n\n            try {\n                // Daten aus der Datenbank abrufen\n                const dbDaten = await this.getDataFromDB(stateValue, rangeHours, instance);\n                if (dbDaten && Array.isArray(dbDaten) && dbDaten.length > 0) {\n                    this.log.debug(`Data from DB: ${JSON.stringify(dbDaten)}`);\n\n                    // Berechne den Abstand zwischen X-Achsen-Beschriftungen\n                    //const stepXAchsis = rangeHours / maxXAxisLabels;\n\n                    valuesChart = '';\n                    // Iteriere \u00FCber jede Stunde im Zeitbereich\n                    for (let i = 0; i < rangeHours; i++) {\n                        const deltaHour = rangeHours - i;\n                        const targetDate = new Date(Date.now() - deltaHour * 3600 * 1000);\n\n                        // Suche den passenden Wert f\u00FCr die aktuelle Stunde in den DB-Daten\n                        for (let j = 0, targetValue = 0; j < dbDaten.length; j++) {\n                            const valueDate = new Date(dbDaten[j].ts);\n                            const value = Math.round((dbDaten[j].val / factor) * 10);\n                            tempScale.push(value);\n\n                            // Wenn der DB-Eintrag nach der Zielzeit liegt\n                            if (valueDate > targetDate) {\n                                // F\u00FCge Zeitangabe hinzu, wenn es ein Label-Schritt ist\n                                //if (targetDate.getHours() % stepXAchsis == 0) {\n                                if (targetDate.getHours() % maxXAxisLabels == 0) {\n                                    valuesChart += `${targetValue}^${targetDate.getHours()}:00~`;\n                                } else {\n                                    valuesChart += `${targetValue}~`;\n                                }\n                                break;\n                            } else {\n                                targetValue = value;\n                            }\n                        }\n                    }\n\n                    // Entferne das letzte Trennzeichen\n                    valuesChart = valuesChart.substring(0, valuesChart.length - 1);\n\n                    // Erstelle die Y-Achsen-Skalierung (Ticks)\n                    const max = Math.max(...tempScale);\n                    const min = 0;\n                    const fixIntervall = max > 50 ? 10 : max > 20 ? 5 : 2;\n                    const intervall = Math.max(Number(((max - min) / 5).toFixed()), fixIntervall);\n\n                    this.log.debug(`Scale Min: ${min}, Max: ${max} Intervall: ${intervall}`);\n\n                    // Erstelle Tick-Array f\u00FCr Y-Achse\n                    const tempTickChart: string[] = [];\n                    let currentTick = min;\n                    while (currentTick < max + intervall) {\n                        tempTickChart.push(String(currentTick));\n                        currentTick += intervall;\n                    }\n                    tempTickChart.push(String(currentTick));\n                    ticksChart = tempTickChart;\n                } else {\n                    this.log.warn(`No data found for state ${stateValue} in the last ${rangeHours} hours`);\n                }\n            } catch (error) {\n                this.log.error(`Error fetching data from DB: ${error as string}`);\n            }\n        }\n\n        return { ticksChart, valuesChart };\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
