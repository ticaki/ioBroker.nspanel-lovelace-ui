{
  "version": 3,
  "sources": ["../../../src/lib/pages/pageChartBar.ts"],
  "sourcesContent": ["import { PageChart } from './pageChart';\nimport { type PageInterface } from '../classes/PageInterface';\nimport type * as pages from '../types/pages';\n\nexport class PageChartBar extends PageChart {\n    constructor(config: PageInterface, options: pages.PageBase) {\n        // Aufruf des Konstruktors der Basisklasse\n        super(config, options);\n    }\n\n    async init(): Promise<void> {\n        const config = structuredClone(this.config);\n        // search states for mode auto\n        const tempConfig: Partial<pages.cardChartDataItemOptions> =\n            this.enums || this.dpInit\n                ? await this.basePanel.statesControler.getDataItemsFromAuto(this.dpInit, config, undefined, this.enums)\n                : config;\n        // create Dataitems\n        //this.log.debug(JSON.stringify(tempConfig));\n        const tempItem: Partial<pages.cardChartDataItems> = await this.basePanel.statesControler.createDataItems(\n            tempConfig,\n            this,\n        );\n        if (tempItem) {\n            tempItem.card = this.card as 'cardChart';\n            this.log.debug(`init Card: ${this.card}`);\n        }\n        this.items = tempItem as pages.cardChartDataItems;\n        await super.init();\n    }\n\n    // \u00DCberschreiben der getChartData-Methode\n    async getChartData(): Promise<{ ticksChart: string[]; valuesChart: string }> {\n        let ticksChart: string[] = ['~'];\n        let valuesChart = '~';\n\n        if (this.items) {\n            const items = this.items;\n            const dataSource =\n                this.items.data.instanceDataSource && (await this.items.data.instanceDataSource.getNumber());\n\n            switch (dataSource) {\n                case 0: {\n                    // oldScriptVersion bleibt unver\u00E4ndert\n                    const tempTicks = (items.data.ticks && (await items.data.ticks.getObject())) ?? ['~'];\n                    const tempValues = (items.data.value && (await items.data.value.getString())) ?? '~';\n                    if (tempTicks && Array.isArray(tempTicks) && tempTicks.length > 0) {\n                        ticksChart = tempTicks;\n                    }\n                    if (tempValues && typeof tempValues === 'string' && tempValues.length > 0) {\n                        valuesChart = tempValues;\n                    }\n                    break;\n                }\n                case 1: {\n                    // AdapterVersion\n\n                    const rangeHours = (items.data.rangeHours && (await items.data.rangeHours.getNumber())) || 24;\n                    const stateValue = (items.data.setStateForDB && (await items.data.setStateForDB.getString())) || '';\n                    const instance = (items.data.dbInstance && (await items.data.dbInstance.getString())) || '';\n                    const maxXAxisLabels =\n                        (items.data.maxXAxisLabels && (await items.data.maxXAxisLabels.getNumber())) || 4;\n                    const factor = (items.data.factorCardChart && (await items.data.factorCardChart.getNumber())) || 1;\n                    const tempScale: number[] = [];\n\n                    try {\n                        const dbDaten = await this.getDataFromDB(stateValue, rangeHours, instance);\n                        if (dbDaten && Array.isArray(dbDaten) && dbDaten.length > 0) {\n                            this.log.debug(`Data from DB: ${JSON.stringify(dbDaten)}`);\n\n                            const stepXAchsis = rangeHours / maxXAxisLabels;\n\n                            valuesChart = '';\n                            for (let i = 0; i < rangeHours; i++) {\n                                const deltaHour = rangeHours - i;\n                                const targetDate = new Date(Date.now() - deltaHour * 3600 * 1000);\n\n                                //Check history items for requested hours\n                                for (let j = 0, targetValue = 0; j < dbDaten.length; j++) {\n                                    const valueDate = new Date(dbDaten[j].ts);\n                                    const value = Math.round((dbDaten[j].val / factor) * 10);\n                                    tempScale.push(value);\n\n                                    if (valueDate > targetDate) {\n                                        if (targetDate.getHours() % stepXAchsis == 0) {\n                                            valuesChart += `${targetValue}^${targetDate.getHours()}:00` + `~`;\n                                        } else {\n                                            valuesChart += `${targetValue}~`;\n                                        }\n                                        break;\n                                    } else {\n                                        targetValue = value;\n                                    }\n                                }\n                            }\n\n                            valuesChart = valuesChart.substring(0, valuesChart.length - 1);\n\n                            // create ticks\n                            const max = Math.max(...tempScale);\n                            const min = 0;\n                            const intervall = Math.max(Number(((max - min) / 5).toFixed()), 10);\n\n                            this.log.debug(`Scale Min: ${min}, Max: ${max} Intervall: ${intervall}`);\n\n                            const tempTickChart: string[] = [];\n                            let currentTick = min;\n                            while (currentTick < max + intervall) {\n                                tempTickChart.push(String(currentTick));\n                                currentTick += intervall;\n                            }\n                            ticksChart = tempTickChart;\n                        } else {\n                            this.log.warn(`No data found for state ${stateValue} in the last ${rangeHours} hours`);\n                        }\n                    } catch (error) {\n                        this.log.error(`Error fetching data from DB: ${error as string}`);\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        return { ticksChart, valuesChart };\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
