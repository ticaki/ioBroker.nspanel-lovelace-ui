{
  "version": 3,
  "sources": ["../../../src/lib/pages/pageChartLine.ts"],
  "sourcesContent": ["import { PageChart } from './pageChart';\nimport { type PageInterface } from '../classes/PageInterface';\nimport type * as pages from '../types/pages';\n\nexport class PageChartLine extends PageChart {\n    constructor(config: PageInterface, options: pages.PageBaseConfig) {\n        // Aufruf des Konstruktors der Basisklasse\n        super(config, options);\n    }\n\n    async init(): Promise<void> {\n        const config = structuredClone(this.config);\n        // search states for mode auto\n        const tempConfig: Partial<pages.cardChartDataItemOptions> =\n            this.enums || this.dpInit\n                ? await this.panel.statesControler.getDataItemsFromAuto(this.dpInit, config, undefined, this.enums)\n                : config;\n        // create Dataitems\n        //this.log.debug(JSON.stringify(tempConfig));\n        const tempItem: Partial<pages.cardChartDataItems> = await this.panel.statesControler.createDataItems(\n            tempConfig,\n            this,\n        );\n        if (tempItem) {\n            tempItem.card = this.card as 'cardChart';\n            this.log.debug(`init Card: ${this.card}`);\n        }\n        this.items = tempItem as pages.cardChartDataItems;\n        await super.init();\n    }\n\n    // \u00DCberschreiben der getChartData-Methode\n    async getChartData(): Promise<{ ticksChart: string[]; valuesChart: string }> {\n        let ticksChart: string[] = [];\n        let valuesChart = '';\n\n        if (this.items && this.adminConfig != null) {\n            const items = this.items;\n\n            switch (this.adminConfig.selInstanceDataSource) {\n                case 0: {\n                    // oldScriptVersion bleibt unver\u00E4ndert\n                    const tempTicks = (items.data.ticks && (await items.data.ticks.getObject())) ?? [];\n                    const tempValues = (items.data.value && (await items.data.value.getString())) ?? '';\n                    if (tempTicks && Array.isArray(tempTicks)) {\n                        ticksChart = tempTicks;\n                    }\n                    if (tempValues && typeof tempValues === 'string') {\n                        valuesChart = tempValues;\n                    }\n                    break;\n                }\n                case 1: {\n                    // AdapterVersion\n\n                    const rangeHours = this.adminConfig.rangeHours;\n                    const stateValue = this.adminConfig.setStateForValues;\n                    const instance = this.adminConfig.selInstance;\n                    const maxXAxisTicks = this.adminConfig.maxXAxisTicks;\n                    //const factor = this.adminConfig.factorCardChart;\n                    const tempScale: number[] = [];\n\n                    try {\n                        const dbDaten = await this.getDataFromDB(stateValue, rangeHours, instance);\n                        if (dbDaten && Array.isArray(dbDaten)) {\n                            this.log.debug(`Data from DB: ${JSON.stringify(dbDaten)}`);\n\n                            let coordinates = '';\n                            for (let r = 0; r < dbDaten.length; r++) {\n                                const list: string[] = [];\n                                const numValues = dbDaten[r].length;\n\n                                for (let i = 0; i < numValues; i++) {\n                                    const time = Math.round(dbDaten[r][i]._rtime / 1000 / 1000 / 1000 / 60);\n                                    const value = Math.round(dbDaten[r][i]._value * 10);\n                                    list.push(`${time}:${value}`);\n                                    tempScale.push(value);\n                                }\n                                coordinates = list.join('~');\n                                this.log.debug(coordinates);\n                            }\n\n                            const ticksAndLabelsList: string[] = [];\n                            const date = new Date();\n                            date.setMinutes(0, 0, 0);\n                            const ts = Math.round(date.getTime() / 1000);\n                            const tsYesterday = ts - rangeHours * 3600;\n\n                            this.log.debug(`Iterate from ${tsYesterday} to ${ts} stepsize=${maxXAxisTicks * 60}`);\n\n                            for (let x = tsYesterday, i = 0; x < ts; x += maxXAxisTicks * 60, i += maxXAxisTicks) {\n                                if (i % maxXAxisTicks) {\n                                    ticksAndLabelsList.push(`${i}`);\n                                } else {\n                                    const currentDate = new Date(x * 1000);\n                                    // Hours part from the timestamp\n                                    const hours = `0${String(currentDate.getHours())}`;\n                                    // Minutes part from the timestamp\n                                    const minutes = `0${String(currentDate.getMinutes())}`;\n                                    const formattedTime = `${hours.slice(-2)}:${minutes.slice(-2)}`;\n\n                                    ticksAndLabelsList.push(`${String(i)}^${formattedTime}`);\n                                }\n                            }\n\n                            this.log.debug(`Ticks & Label: ${JSON.stringify(ticksAndLabelsList)}`);\n                            this.log.debug(`Coordinates: ${coordinates}`);\n\n                            valuesChart = `${ticksAndLabelsList.join('+')}~${coordinates}`;\n\n                            // create ticks\n                            let max = 0;\n                            let min = 0;\n                            let intervall = 0;\n\n                            max = Math.max(...tempScale);\n                            min = Math.min(...tempScale);\n                            this.log.debug(`Scale Min: ${min}, Max: ${max}`);\n\n                            intervall = Math.round(max / 4);\n                            ticksChart.push(String(min));\n\n                            for (let count = 0; count < 4; count++) {\n                                min = Math.round(min + intervall);\n                                ticksChart.push(String(min));\n                            }\n                        }\n                    } catch (error) {\n                        this.log.error(`Error fetching data from DB: ${error as string}`);\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        return { ticksChart, valuesChart };\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA0B;AAInB,MAAM,sBAAsB,2BAAU;AAAA,EACzC,YAAY,QAAuB,SAA+B;AAE9D,UAAM,QAAQ,OAAO;AAAA,EACzB;AAAA,EAEA,MAAM,OAAsB;AACxB,UAAM,SAAS,gBAAgB,KAAK,MAAM;AAE1C,UAAM,aACF,KAAK,SAAS,KAAK,SACb,MAAM,KAAK,MAAM,gBAAgB,qBAAqB,KAAK,QAAQ,QAAQ,QAAW,KAAK,KAAK,IAChG;AAGV,UAAM,WAA8C,MAAM,KAAK,MAAM,gBAAgB;AAAA,MACjF;AAAA,MACA;AAAA,IACJ;AACA,QAAI,UAAU;AACV,eAAS,OAAO,KAAK;AACrB,WAAK,IAAI,MAAM,cAAc,KAAK,IAAI,EAAE;AAAA,IAC5C;AACA,SAAK,QAAQ;AACb,UAAM,MAAM,KAAK;AAAA,EACrB;AAAA;AAAA,EAGA,MAAM,eAAuE;AAhCjF;AAiCQ,QAAI,aAAuB,CAAC;AAC5B,QAAI,cAAc;AAElB,QAAI,KAAK,SAAS,KAAK,eAAe,MAAM;AACxC,YAAM,QAAQ,KAAK;AAEnB,cAAQ,KAAK,YAAY,uBAAuB;AAAA,QAC5C,KAAK,GAAG;AAEJ,gBAAM,aAAa,WAAM,KAAK,SAAU,MAAM,MAAM,KAAK,MAAM,UAAU,MAAtD,YAA6D,CAAC;AACjF,gBAAM,cAAc,WAAM,KAAK,SAAU,MAAM,MAAM,KAAK,MAAM,UAAU,MAAtD,YAA6D;AACjF,cAAI,aAAa,MAAM,QAAQ,SAAS,GAAG;AACvC,yBAAa;AAAA,UACjB;AACA,cAAI,cAAc,OAAO,eAAe,UAAU;AAC9C,0BAAc;AAAA,UAClB;AACA;AAAA,QACJ;AAAA,QACA,KAAK,GAAG;AAGJ,gBAAM,aAAa,KAAK,YAAY;AACpC,gBAAM,aAAa,KAAK,YAAY;AACpC,gBAAM,WAAW,KAAK,YAAY;AAClC,gBAAM,gBAAgB,KAAK,YAAY;AAEvC,gBAAM,YAAsB,CAAC;AAE7B,cAAI;AACA,kBAAM,UAAU,MAAM,KAAK,cAAc,YAAY,YAAY,QAAQ;AACzE,gBAAI,WAAW,MAAM,QAAQ,OAAO,GAAG;AACnC,mBAAK,IAAI,MAAM,iBAAiB,KAAK,UAAU,OAAO,CAAC,EAAE;AAEzD,kBAAI,cAAc;AAClB,uBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,sBAAM,OAAiB,CAAC;AACxB,sBAAM,YAAY,QAAQ,CAAC,EAAE;AAE7B,yBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAChC,wBAAM,OAAO,KAAK,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,MAAO,MAAO,MAAO,EAAE;AACtE,wBAAM,QAAQ,KAAK,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE;AAClD,uBAAK,KAAK,GAAG,IAAI,IAAI,KAAK,EAAE;AAC5B,4BAAU,KAAK,KAAK;AAAA,gBACxB;AACA,8BAAc,KAAK,KAAK,GAAG;AAC3B,qBAAK,IAAI,MAAM,WAAW;AAAA,cAC9B;AAEA,oBAAM,qBAA+B,CAAC;AACtC,oBAAM,OAAO,oBAAI,KAAK;AACtB,mBAAK,WAAW,GAAG,GAAG,CAAC;AACvB,oBAAM,KAAK,KAAK,MAAM,KAAK,QAAQ,IAAI,GAAI;AAC3C,oBAAM,cAAc,KAAK,aAAa;AAEtC,mBAAK,IAAI,MAAM,gBAAgB,WAAW,OAAO,EAAE,aAAa,gBAAgB,EAAE,EAAE;AAEpF,uBAAS,IAAI,aAAa,IAAI,GAAG,IAAI,IAAI,KAAK,gBAAgB,IAAI,KAAK,eAAe;AAClF,oBAAI,IAAI,eAAe;AACnB,qCAAmB,KAAK,GAAG,CAAC,EAAE;AAAA,gBAClC,OAAO;AACH,wBAAM,cAAc,IAAI,KAAK,IAAI,GAAI;AAErC,wBAAM,QAAQ,IAAI,OAAO,YAAY,SAAS,CAAC,CAAC;AAEhD,wBAAM,UAAU,IAAI,OAAO,YAAY,WAAW,CAAC,CAAC;AACpD,wBAAM,gBAAgB,GAAG,MAAM,MAAM,EAAE,CAAC,IAAI,QAAQ,MAAM,EAAE,CAAC;AAE7D,qCAAmB,KAAK,GAAG,OAAO,CAAC,CAAC,IAAI,aAAa,EAAE;AAAA,gBAC3D;AAAA,cACJ;AAEA,mBAAK,IAAI,MAAM,kBAAkB,KAAK,UAAU,kBAAkB,CAAC,EAAE;AACrE,mBAAK,IAAI,MAAM,gBAAgB,WAAW,EAAE;AAE5C,4BAAc,GAAG,mBAAmB,KAAK,GAAG,CAAC,IAAI,WAAW;AAG5D,kBAAI,MAAM;AACV,kBAAI,MAAM;AACV,kBAAI,YAAY;AAEhB,oBAAM,KAAK,IAAI,GAAG,SAAS;AAC3B,oBAAM,KAAK,IAAI,GAAG,SAAS;AAC3B,mBAAK,IAAI,MAAM,cAAc,GAAG,UAAU,GAAG,EAAE;AAE/C,0BAAY,KAAK,MAAM,MAAM,CAAC;AAC9B,yBAAW,KAAK,OAAO,GAAG,CAAC;AAE3B,uBAAS,QAAQ,GAAG,QAAQ,GAAG,SAAS;AACpC,sBAAM,KAAK,MAAM,MAAM,SAAS;AAChC,2BAAW,KAAK,OAAO,GAAG,CAAC;AAAA,cAC/B;AAAA,YACJ;AAAA,UACJ,SAAS,OAAO;AACZ,iBAAK,IAAI,MAAM,gCAAgC,KAAe,EAAE;AAAA,UACpE;AACA;AAAA,QACJ;AAAA,QACA;AACI;AAAA,MACR;AAAA,IACJ;AAEA,WAAO,EAAE,YAAY,YAAY;AAAA,EACrC;AACJ;",
  "names": []
}
