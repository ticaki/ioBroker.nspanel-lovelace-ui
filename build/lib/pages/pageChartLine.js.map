{
  "version": 3,
  "sources": ["../../../src/lib/pages/pageChartLine.ts"],
  "sourcesContent": ["import { isChartDetailsExternal, PageChart } from './pageChart';\nimport { type PageInterface } from '../classes/PageInterface';\nimport type * as pages from '../types/pages';\n\nexport class PageChartLine extends PageChart {\n    constructor(config: PageInterface, options: pages.PageBase) {\n        // Aufruf des Konstruktors der Basisklasse\n        super(config, options);\n    }\n\n    async init(): Promise<void> {\n        const config = structuredClone(this.config);\n        // search states for mode auto\n        const tempConfig: Partial<pages.cardChartDataItemOptions> =\n            this.enums || this.dpInit\n                ? await this.basePanel.statesControler.getDataItemsFromAuto(this.dpInit, config, undefined, this.enums)\n                : config;\n        // create Dataitems\n        //this.log.debug(JSON.stringify(tempConfig));\n        const tempItem: Partial<pages.cardChartDataItems> = await this.basePanel.statesControler.createDataItems(\n            tempConfig,\n            this,\n        );\n        if (tempItem) {\n            tempItem.card = this.card as 'cardChart';\n            this.log.debug(`init Card: ${this.card}`);\n        }\n        this.items = tempItem as pages.cardChartDataItems;\n        if (this.items && this.items.data && this.items.data.dbData) {\n            const dbDetails = await this.items.data.dbData.getObject();\n            if (isChartDetailsExternal(dbDetails)) {\n                this.dbDetails = dbDetails;\n                this.getChartData = this.getChartDataDB;\n            }\n        }\n        await super.init();\n    }\n\n    // Eventuelles \u00FCberschreiben der getChartData-Methode\n    async getChartDataDB(\n        ticksChart: string[] = ['~'],\n        valuesChart = '~',\n    ): Promise<{ ticksChart: string[]; valuesChart: string }> {\n        if (this.dbDetails) {\n            const items = this.dbDetails;\n\n            // AdapterVersion\n            const hoursRangeFromNow = items.hours || 24;\n            const stateValue = items.state || '';\n            const instance = items.instance || '';\n            const maxXAxisLabels = items.maxLabels || 4;\n            const maxXAxisTicks = items.maxTicks || 2;\n            const xAxisTicksInterval = maxXAxisTicks > 0 ? maxXAxisTicks * 60 : 60;\n            const xAxisLabelInterval = maxXAxisLabels > 0 ? maxXAxisLabels * 60 : 120;\n            const maxX = 1440; // 24h = 1440min\n\n            const tempScale: number[] = [];\n\n            try {\n                const dbDaten = await this.getDataFromDB(stateValue, hoursRangeFromNow, instance);\n                if (dbDaten && Array.isArray(dbDaten) && dbDaten.length > 0) {\n                    this.log.debug(`Data from DB: ${JSON.stringify(dbDaten)}`);\n\n                    let ticksAndLabels = '';\n                    let coordinates = '';\n\n                    const ticksAndLabelsList = [];\n                    const date = new Date();\n                    date.setMinutes(0, 0, 0);\n                    const ts = Math.round(date.getTime() / 1000);\n                    const tsYesterday = ts - hoursRangeFromNow * 3600;\n\n                    for (let x = tsYesterday, i = 0; x < ts; x += xAxisTicksInterval * 60, i += xAxisTicksInterval) {\n                        if (i % xAxisLabelInterval) {\n                            ticksAndLabelsList.push(i);\n                        } else {\n                            const currentDate = new Date(x * 1000);\n                            // Hours part from the timestamp\n                            const hours = `0${currentDate.getHours()}`;\n                            // Minutes part from the timestamp\n                            const minutes = `0${currentDate.getMinutes()}`;\n                            const formattedTime = `${hours.slice(-2)}:${minutes.slice(-2)}`;\n                            ticksAndLabelsList.push(`${String(i)}^${formattedTime}`);\n                        }\n                    }\n                    ticksAndLabels = ticksAndLabelsList.join('+');\n\n                    const list = [];\n                    const offSetTime = Math.round(dbDaten[0].ts / 1000);\n                    const lastTs = Math.round(dbDaten[dbDaten.length - 1].ts / 1000);\n                    const counter = dbDaten.length > 1 ? Math.max((lastTs - offSetTime) / maxX, 1) : 1;\n                    for (let i = 0; i < dbDaten.length; i++) {\n                        const time = Math.round((dbDaten[i].ts / 1000 - offSetTime) / counter);\n                        const value = Math.round(dbDaten[i].val * 10);\n                        if (value != null && value != 0) {\n                            list.push(`${time}:${value}`);\n                            tempScale.push(value);\n                        }\n                    }\n\n                    coordinates = list.join('~');\n                    valuesChart = `${ticksAndLabels}~${coordinates}`;\n\n                    this.log.debug(`Ticks & Label: ${ticksAndLabels}`);\n                    this.log.debug(`Coordinates: ${coordinates}`);\n\n                    // create ticks\n                    if (tempScale.length > 0) {\n                        // Round min down to nearest 10 and max up to nearest 10\n                        const rawMax = Math.max(...tempScale);\n                        const rawMin = Math.min(...tempScale);\n                        const roundedMin = Math.floor(rawMin / 10) * 10;\n                        const roundedMax = Math.ceil(rawMax / 10) * 10;\n\n                        // ensure at least a minimal span to avoid zero intervall\n                        const span = Math.max(roundedMax - roundedMin, 10);\n                        const intervall = Math.max(Number((span / 5).toFixed()), 10);\n\n                        this.log.debug(\n                            `Scale Min: ${roundedMin} (raw ${rawMin}), Max: ${roundedMax} (raw ${rawMax}) Intervall: ${intervall}`,\n                        );\n                        const tempTickChart: string[] = [];\n                        let currentTick = roundedMin - intervall * 2;\n                        while (currentTick < roundedMax + intervall) {\n                            tempTickChart.push(String(currentTick));\n                            currentTick += intervall;\n                        }\n                        ticksChart = tempTickChart;\n                    }\n                } else {\n                    this.log.warn(`No data found for state ${stateValue} in the last ${hoursRangeFromNow} hours`);\n                }\n            } catch (error) {\n                this.log.error(`Error fetching data from DB: ${error as string}`);\n            }\n        }\n\n        return { ticksChart, valuesChart };\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
