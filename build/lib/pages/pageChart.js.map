{
  "version": 3,
  "sources": ["../../../src/lib/pages/pageChart.ts"],
  "sourcesContent": ["import type { ConfigManager } from '../classes/config-manager';\nimport { Page } from '../classes/Page';\nimport { type PageInterface } from '../classes/PageInterface';\nimport { Color } from '../const/Color';\nimport { getIconEntryColor, getPayload } from '../const/tools';\nimport type { NspanelLovelaceUi } from '../types/NspanelLovelaceUi';\nimport type * as pages from '../types/pages';\nimport type { IncomingEvent } from '../types/types';\n\nconst PageChartMessageDefault: pages.PageChartMessage = {\n    event: 'entityUpd',\n    headline: 'Page Chart',\n    navigation: 'button~bSubPrev~~~~~button~bSubNext~~~~',\n    color: '', //Balkenfarbe\n    text: '', //Bezeichnung y Achse\n    ticks: [], //Werte y Achse\n    value: '', //Werte x Achse\n};\n\n/**\n * untested\n */\nexport class PageChart extends Page {\n    items: pages.cardChartDataItems | undefined;\n    index: number = 0;\n    private step: number = 1;\n    private headlinePos: number = 0;\n    private titelPos: number = 0;\n    private nextArrow: boolean = false;\n\n    constructor(config: PageInterface, options: pages.PageBaseConfig) {\n        if (config.card !== 'cardChart') {\n            return;\n        }\n        super(config, options);\n        if (options.config && options.config.card == 'cardChart') {\n            this.config = options.config;\n        } else {\n            throw new Error('Missing config!');\n        }\n        this.index = this.config.index;\n        this.minUpdateInterval = 2000;\n    }\n\n    async init(): Promise<void> {\n        const config = structuredClone(this.config);\n        // search states for mode auto\n        const tempConfig: Partial<pages.cardChartDataItemOptions> =\n            this.enums || this.dpInit\n                ? await this.panel.statesControler.getDataItemsFromAuto(this.dpInit, config, undefined, this.enums)\n                : config;\n        // create Dataitems\n        //this.log.debug(JSON.stringify(tempConfig));\n        const tempItem: Partial<pages.cardChartDataItems> = await this.panel.statesControler.createDataItems(\n            tempConfig,\n            this,\n        );\n        if (tempItem) {\n            tempItem.card = 'cardChart';\n        }\n        this.items = tempItem as pages.cardChartDataItems;\n        await super.init();\n    }\n\n    /**\n     *\n     * @returns // TODO: remove this\n     */\n    public async update(): Promise<void> {\n        if (!this.visibility) {\n            return;\n        }\n        const message: Partial<pages.PageChartMessage> = {};\n        const config = this.adapter.config.pageChartdata[this.index];\n        if (this.items && config != null) {\n            const items = this.items;\n            const chartData = await this.getChartData();\n\n            message.headline = (items.data.headline && (await items.data.headline.getTranslatedString())) ?? this.name;\n            message.navigation = this.getNavigation();\n            message.color = await getIconEntryColor(items.data.color, true, Color.White);\n            message.text = (items.data.text && (await items.data.text.getString())) ?? '';\n            message.value = chartData.values;\n            message.ticks = chartData.ticks;\n            /*message.ticks = [];\n            const ticks = items.data.ticks && (await items.data.ticks.getObject());\n            if (ticks && Array.isArray(ticks)) {\n                message.ticks = ticks;\n            } else if (message.value) {\n                const timeValueRegEx = /~\\d+:(\\d+)/g;\n                const sorted: number[] = [...(message.value.matchAll(timeValueRegEx) || [])]\n                    .map(x => parseFloat(x[1]))\n                    .sort((x, y) => (x < y ? -1 : 1));\n                const minValue = sorted[0];\n                const maxValue = sorted[sorted.length - 1];\n                const tick = Math.max(Number(((maxValue - minValue) / 5).toFixed()), 10);\n                let currentTick = minValue - tick;\n                while (currentTick < maxValue + tick) {\n                    message.ticks.push(String(currentTick));\n                    currentTick += tick;\n                }\n            } */\n        }\n        if (message.value) {\n            this.log.debug(message.value);\n        }\n        if (message.ticks) {\n            this.log.debug(`Ticks: ${message.ticks.join(',')}`);\n        }\n        this.sendToPanel(this.getMessage(message), false);\n    }\n\n    static async getChartPageConfig(\n        adapter: NspanelLovelaceUi,\n        index: number,\n        configManager: ConfigManager,\n    ): Promise<pages.PageBaseConfig> {\n        const config = adapter.config.pageChartdata[index];\n        let stateExistValue = '';\n        let stateExistTicks = '';\n        if (config) {\n            if (await configManager.existsState(config.setStateForValues)) {\n                stateExistValue = config.setStateForValues;\n            }\n            if (await configManager.existsState(config.setStateForTicks)) {\n                stateExistTicks = config.setStateForTicks;\n            }\n\n            const result: pages.PageBaseConfig = {\n                uniqueID: config.pageName,\n                alwaysOn: config.alwaysOnDisplay ? 'always' : 'none',\n                config: {\n                    card: 'cardChart',\n                    index: index,\n                    data: {\n                        headline: { type: 'const', constVal: config.headline || '' },\n                        text: { type: 'const', constVal: config.txtlabelYAchse || '' },\n                        color: { true: { color: { type: 'const', constVal: config.chart_color } } },\n                        ticks: { type: 'triggered', dp: stateExistTicks },\n                        value: { type: 'triggered', dp: stateExistValue },\n                    },\n                },\n                pageItems: [],\n            };\n            return result;\n        }\n        throw new Error('No config for cardChart found');\n    }\n    private async getChartData(): Promise<{ ticks: string[]; values: string }> {\n        let ticks: string[] = [];\n        let values = '';\n\n        const config = this.adapter.config.pageChartdata[this.index];\n\n        let instanceDataSource = '';\n        switch (config.selInstanceDataSource) {\n            case 1:\n                instanceDataSource = config.selInstanceHistory;\n                break;\n            case 2:\n                instanceDataSource = config.selInstanceInflux;\n                break;\n            case 3:\n                instanceDataSource = config.selInstanceSQL;\n                break;\n\n            default:\n                break;\n        }\n\n        if (this.items && config != null) {\n            const items = this.items;\n\n            switch (config.selInstanceDataSource) {\n                case 0: {\n                    // oldScriptVersion\n                    const tempTicks = (items.data.ticks && (await items.data.ticks.getObject())) ?? [];\n                    const tempValues = (items.data.value && (await items.data.value.getObject())) ?? '';\n                    if (tempTicks && Array.isArray(tempTicks)) {\n                        ticks = tempTicks;\n                    } else if (typeof tempValues === 'string') {\n                        const timeValueRegEx = /~\\d+:(\\d+)/g;\n                        const sorted: number[] = [...(tempValues.matchAll(timeValueRegEx) || [])]\n                            .map(x => parseFloat(x[1]))\n                            .sort((x, y) => (x < y ? -1 : 1));\n                        const minValue = sorted[0];\n                        const maxValue = sorted[sorted.length - 1];\n                        const tick = Math.max(Number(((maxValue - minValue) / 5).toFixed()), 10);\n                        let currentTick = minValue - tick;\n                        while (currentTick < maxValue + tick) {\n                            ticks.push(String(currentTick));\n                            currentTick += tick;\n                        }\n                    }\n                    if (tempValues && typeof tempValues === 'string') {\n                        values = tempValues;\n                    }\n                    break;\n                }\n                case 1: {\n                    // History\n                    const rangeHours = config.rangeHours;\n                    const maxXAchsisTicks = config.maxXAxisTicks;\n                    const factor = 1;\n\n                    this.adapter.sendTo(\n                        instanceDataSource,\n                        'getHistory',\n                        {\n                            id: config.setStateForValues,\n                            options: {\n                                start: Date.now() - 60 * 60 * 1000 * rangeHours,\n                                end: Date.now(),\n                                count: rangeHours,\n                                limit: rangeHours,\n                                aggregate: 'average',\n                            },\n                        },\n                        function (result) {\n                            let cardChartString = '';\n                            const stepXAchsis = rangeHours / maxXAchsisTicks;\n\n                            for (let i = 0; i < rangeHours; i++) {\n                                const deltaHour = rangeHours - i;\n                                const targetDate = new Date(Date.now() - deltaHour * 60 * 60 * 1000);\n\n                                //Check history items for requested hours\n                                if (result && result.message) {\n                                    for (let j = 0, targetValue = 0; j < result.message.length; j++) {\n                                        const valueDate = new Date(result.message[j].ts);\n                                        const value = Math.round((result.message[j].val / factor) * 10);\n\n                                        if (valueDate > targetDate) {\n                                            if (targetDate.getHours() % stepXAchsis == 0) {\n                                                cardChartString += `${targetValue}^${targetDate.getHours()}:00` + `~`;\n                                            } else {\n                                                cardChartString += `${targetValue}~`;\n                                            }\n                                            break;\n                                        } else {\n                                            targetValue = value;\n                                        }\n                                    }\n                                }\n                            }\n\n                            values = cardChartString.substring(0, cardChartString.length - 1);\n                        },\n                    );\n                    if (typeof values === 'string') {\n                        const timeValueRegEx = /~\\d+:(\\d+)/g;\n                        const sorted: number[] = [...(values.matchAll(timeValueRegEx) || [])]\n                            .map(x => parseFloat(x[1]))\n                            .sort((x, y) => (x < y ? -1 : 1));\n                        const minValue = sorted[0];\n                        const maxValue = sorted[sorted.length - 1];\n                        const tick = Math.max(Number(((maxValue - minValue) / 5).toFixed()), 10);\n                        let currentTick = minValue - tick;\n                        while (currentTick < maxValue + tick) {\n                            ticks.push(String(currentTick));\n                            currentTick += tick;\n                        }\n                    }\n                    break;\n                }\n                case 2: {\n                    // influx\n                    let idMeasurement = config.txtNameMeasurements;\n                    if (idMeasurement == '' || idMeasurement == undefined) {\n                        idMeasurement = config.setStateForValues;\n                    }\n\n                    const influxDbBucket = '';\n                    const numberOfHoursAgo = config.rangeHours;\n                    const xAxisTicksEveryM = config.maxXAxisTicks;\n                    const xAxisLabelEveryM = config.maxXaxisLabels;\n                    const query = [\n                        `from(bucket: \"${influxDbBucket}\")`,\n                        `|> range(start: -${numberOfHoursAgo}h)`,\n                        `|> filter(fn: (r) => r[\"_measurement\"] == \"${idMeasurement}\")`,\n                        '|> filter(fn: (r) => r[\"_field\"] == \"value\")',\n                        '|> drop(columns: [\"from\", \"ack\", \"q\"])',\n                        '|> aggregateWindow(every: 1h, fn: last, createEmpty: false)',\n                        '|> map(fn: (r) => ({ r with _rtime: int(v: r._time) - int(v: r._start)}))',\n                        '|> yield(name: \"_result\")',\n                    ].join('');\n\n                    console.log(`Query: ${query}`);\n\n                    const result: any = await this.adapter.sendToAsync(instanceDataSource, 'query', query);\n                    if (result.error) {\n                        console.error(result.error);\n                        ticks = [];\n                        values = '';\n                        return { ticks, values };\n                    }\n                    console.log(JSON.stringify(result));\n                    const numResults = result.result.length;\n                    let coordinates = '';\n                    for (let r = 0; r < numResults; r++) {\n                        const list: string[] = [];\n                        const numValues = result.result[r].length;\n\n                        for (let i = 0; i < numValues; i++) {\n                            const time = Math.round(result.result[r][i]._rtime / 1000 / 1000 / 1000 / 60);\n                            const value = Math.round(result.result[r][i]._value * 10);\n                            list.push(`${time}:${value}`);\n                        }\n\n                        coordinates = list.join('~');\n                        console.log(coordinates);\n                    }\n\n                    const ticksAndLabelsList: string[] = [];\n                    const date = new Date();\n                    date.setMinutes(0, 0, 0);\n                    const ts = Math.round(date.getTime() / 1000);\n                    const tsYesterday = ts - numberOfHoursAgo * 3600;\n                    console.log(`Iterate from ${tsYesterday} to ${ts} stepsize=${xAxisTicksEveryM * 60}`);\n                    for (let x = tsYesterday, i = 0; x < ts; x += xAxisTicksEveryM * 60, i += xAxisTicksEveryM) {\n                        if (i % xAxisLabelEveryM) {\n                            ticksAndLabelsList.push(`${i}`);\n                        } else {\n                            const currentDate = new Date(x * 1000);\n                            // Hours part from the timestamp\n                            const hours = `0${String(currentDate.getHours())}`;\n                            // Minutes part from the timestamp\n                            const minutes = `0${String(currentDate.getMinutes())}`;\n                            const formattedTime = `${hours.slice(-2)}:${minutes.slice(-2)}`;\n\n                            ticksAndLabelsList.push(`${String(i)}^${formattedTime}`);\n                        }\n                    }\n                    console.log(`Ticks & Label: ${ticksAndLabelsList.join(', ')}`);\n                    console.log(`Coordinates: ${coordinates}`);\n                    ticks = ticksAndLabelsList;\n                    values = coordinates;\n                    break;\n                }\n                case 3: {\n                    break;\n                }\n                case 4: {\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        return { ticks, values };\n    }\n\n    private getMessage(_message: Partial<pages.PageChartMessage>): string {\n        let result: pages.PageChartMessage = PageChartMessageDefault;\n        result = Object.assign(result, _message) as pages.PageChartMessage;\n        return getPayload(\n            'entityUpd',\n            result.headline,\n            result.navigation,\n            result.color,\n            result.text,\n            result.ticks.join(':'),\n            result.value,\n        );\n    }\n\n    protected async onStateTrigger(_id: string): Promise<void> {\n        if (this.unload) {\n            return;\n        }\n        this.adapter.setTimeout(() => this.update(), 50);\n    }\n\n    async onButtonEvent(_event: IncomingEvent): Promise<void> {\n        //if (event.page && event.id && this.pageItems) {\n        //    this.pageItems[event.id as any].setPopupAction(event.action, event.opt);\n        //}\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
