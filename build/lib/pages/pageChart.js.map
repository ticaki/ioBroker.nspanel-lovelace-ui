{
  "version": 3,
  "sources": ["../../../src/lib/pages/pageChart.ts"],
  "sourcesContent": ["import type { ConfigManager } from '../classes/config-manager';\nimport { Page } from '../classes/Page';\nimport { type PageInterface } from '../classes/PageInterface';\nimport { Color } from '../const/Color';\nimport { getIconEntryColor, getPayload } from '../const/tools';\nimport type * as pages from '../types/pages';\nimport type { IncomingEvent } from '../types/types';\n\nconst PageChartMessageDefault: pages.PageChartMessage = {\n    event: 'entityUpd',\n    headline: 'Page Chart',\n    navigation: 'button~bSubPrev~~~~~button~bSubNext~~~~',\n    color: '', //Balkenfarbe\n    text: '', //Bezeichnung y Achse\n    ticks: [], //Werte y Achse\n    value: '', //Werte x Achse\n};\n\n/**\n * untested\n */\nexport class PageChart extends Page {\n    items: pages.cardChartDataItems | undefined;\n    //index: number = 0;\n    private checkState: boolean = true;\n    //protected adminConfig;\n\n    constructor(config: PageInterface, options: pages.PageBase) {\n        if (config.card !== 'cardChart' && config.card !== 'cardLChart') {\n            return;\n        }\n        super(config, options);\n        if (options.config && (options.config.card == 'cardChart' || options.config.card == 'cardLChart')) {\n            this.config = options.config;\n        } else {\n            throw new Error('Missing config!');\n        }\n        //this.index = this.config.index;\n        this.minUpdateInterval = 60_000;\n        //this.adminConfig = this.adapter.config.pageChartdata[this.index];\n    }\n\n    async init(): Promise<void> {\n        await super.init();\n    }\n\n    /**\n     *\n     * @returns // TODO: remove this\n     */\n    public async update(): Promise<void> {\n        if (!this.visibility) {\n            return;\n        }\n        const message: Partial<pages.PageChartMessage> = {};\n        message.navigation = this.getNavigation();\n        message.headline = `Error`;\n        message.ticks = ['~'];\n        message.value = '~';\n\n        if (this.checkState) {\n            if (this.items) {\n                const items = this.items;\n                const { valuesChart, ticksChart } = await this.getChartData();\n\n                message.headline =\n                    (items.data.headline && (await items.data.headline.getTranslatedString())) ?? this.name;\n                message.color = await getIconEntryColor(items.data.color, true, Color.White);\n                message.text = (items.data.text && (await items.data.text.getString())) ?? '';\n                message.value = valuesChart;\n                message.ticks = ticksChart;\n            }\n            if (message.value) {\n                this.log.debug(`Value: ${message.value}`);\n            }\n            if (message.ticks) {\n                this.log.debug(`Ticks: ${message.ticks.join(',')}`);\n            }\n        }\n        this.sendType(true);\n        this.sendToPanel(this.getMessage(message), false);\n    }\n\n    static async getChartPageConfig(\n        configManager: ConfigManager,\n        index: number,\n        gridItem: pages.PageBase,\n        messages: string[],\n        page: ScriptConfig.PageChart,\n    ): Promise<{ gridItem: pages.PageBase; messages: string[] }> {\n        const adapter = configManager.adapter;\n        const config = adapter.config.pageChartdata[index];\n        let stateExistValue = '';\n        let stateExistTicks = '';\n        if (config) {\n            const card = config.selChartType;\n            adapter.log.debug(`get pageconfig Card: ${card}`);\n            if (config.selInstanceDataSource === 1) {\n                // AdapterVersion\n                if (await configManager.existsState(config.setStateForDB)) {\n                    stateExistValue = config.setStateForDB;\n                }\n            } else {\n                // oldScriptVersion\n                if (await configManager.existsState(config.setStateForValues)) {\n                    stateExistValue = config.setStateForValues;\n                }\n            }\n            if (await configManager.existsState(config.setStateForTicks)) {\n                stateExistTicks = config.setStateForTicks;\n            }\n\n            gridItem = {\n                ...gridItem,\n                uniqueID: config.pageName,\n                alwaysOn: page.alwaysOnDisplay || config.alwaysOnDisplay ? 'always' : 'none',\n                hidden: page.hiddenByTrigger || config.hiddenByTrigger,\n                config: {\n                    card: card,\n                    //index: index,\n                    data: {\n                        headline: await configManager.getFieldAsDataItemConfig(page.heading || config.headline || ''),\n                        text: { type: 'const', constVal: config.txtlabelYAchse || '' },\n                        color: { true: { color: { type: 'const', constVal: config.chart_color } } },\n                        ticks: { type: 'triggered', dp: stateExistTicks },\n                        value: { type: 'triggered', dp: stateExistValue },\n                    },\n                },\n                pageItems: [],\n            };\n            return { gridItem, messages };\n        }\n        throw new Error('No config for cardChart found');\n    }\n\n    protected async getChartData(): Promise<{ ticksChart: string[]; valuesChart: string }> {\n        const ticksChart: string[] = ['~'];\n        const valuesChart = '~';\n        this.log.warn('getChartData not implemented in base PageChart class');\n\n        return { ticksChart, valuesChart };\n    }\n\n    protected async getDataFromDB(_id: string, _rangeHours: number, _instance: string): Promise<any[]> {\n        return new Promise((resolve, reject) => {\n            const timeout = this.adapter.setTimeout(() => {\n                reject(\n                    new Error(`PageChart: ${this.name} - DB: ${_instance} - Timeout getting history for state ${_id}`),\n                );\n            }, 15_000);\n            try {\n                this.adapter.sendTo(\n                    _instance,\n                    'getHistory',\n                    {\n                        id: _id,\n                        options: {\n                            start: Date.now() - _rangeHours * 60 * 60 * 1000,\n                            end: Date.now(),\n                            count: _rangeHours,\n                            limit: _rangeHours,\n                            ignoreNull: true,\n                            aggregate: 'average',\n                            round: 1,\n                        },\n                    },\n                    result => {\n                        if (timeout) {\n                            this.adapter.clearTimeout(timeout);\n                        }\n                        if (result && 'result' in result) {\n                            if (Array.isArray(result.result)) {\n                                for (let i = 0; i < result.result.length; i++) {\n                                    this.log.debug(\n                                        `Value: ${result.result[i].val}, ISO-Timestring: ${new Date(result.result[i].ts).toISOString()}`,\n                                    );\n                                }\n                                resolve(result.result);\n                            }\n                        }\n                        reject(new Error('No data found'));\n                    },\n                );\n            } catch (error) {\n                reject(new Error(`Error in getDataFromDB: ${error as string}`));\n            }\n        });\n    }\n\n    private getMessage(_message: Partial<pages.PageChartMessage>): string {\n        let result: pages.PageChartMessage = PageChartMessageDefault;\n        result = { ...result, ..._message } as pages.PageChartMessage;\n        return getPayload(\n            'entityUpd',\n            result.headline,\n            result.navigation,\n            result.color,\n            result.text,\n            result.ticks.join(':'),\n            result.value,\n        );\n    }\n\n    protected async onVisibilityChange(val: boolean): Promise<void> {\n        // breche laufenden Timer immer ab wenn sich die Sichtbarkeit \u00E4ndert\n        if (val) {\n            // Neu: bei Sichtbarkeit immer neu pr\u00FCfen\n            this.checkState = false; // Standardm\u00E4\u00DFig auf false setzen\n            if (!this.items) {\n                this.log.warn('AdminConfig is not set, cannot check states');\n                this.checkState = false;\n            } else {\n                // trys klein halten - die fangen auch alle vertipper ab und suchen ist dann lustig\n                try {\n                    const cfg = this.items.data;\n                    const ds = cfg.instanceDataSource && (await cfg.instanceDataSource?.getNumber());\n                    const sfv = cfg.setStateForValues && (await cfg.setStateForValues?.getString());\n                    const sft = cfg.setStateForTicks && (await cfg.setStateForTicks?.getString());\n                    const sfd = cfg.setStateForDB && (await cfg.setStateForDB?.getString());\n                    const si = cfg.dbInstance && (await cfg.dbInstance?.getString());\n\n                    this.log.debug(\n                        `onVisibilityChange checking states with dataSource: ${ds}, setStateForValues: ${sfv}, setStateForTicks: ${sft}, setStateForDB: ${sfd}, selInstance: ${si}`,\n                    );\n                    if (ds === 0) {\n                        // Datenquelle: direkte States (setStateForValues + setStateForTicks)\n                        if (sfv != null && sfv !== '') {\n                            const state = await this.adapter.getForeignStateAsync(sfv);\n                            if (state && state.val !== null && state.val !== undefined) {\n                                this.log.debug(`State ${sfv} for Values exists and has value: ${state.val}`);\n                                this.checkState = true; // Nur hier auf true setzen, wenn alles passt\n                            } else if (state) {\n                                this.log.warn(`State ${sfv} for Values exists but has no value`);\n                            } else {\n                                this.log.error(`State ${sfv} for Values does not exist`);\n                            }\n                        } else {\n                            this.log.error('No setStateForValues configured');\n                        }\n\n                        if (sft != null && sft !== '') {\n                            const state = await this.adapter.getForeignStateAsync(sft);\n                            if (state && state.val !== null && state.val !== undefined) {\n                                this.log.debug(`State ${sft} for Ticks exists and has value: ${state.val}`);\n                                this.checkState = true;\n                            } else if (state) {\n                                this.log.warn(`State ${sft} for Ticks exists but has no value`);\n                                this.checkState = false;\n                            } else {\n                                this.log.error(`State ${sft} for Ticks does not exist`);\n                                this.checkState = false;\n                            }\n                        } else {\n                            this.log.error('No setStateForTicks configured');\n                            this.checkState = false;\n                        }\n                    } else if (ds === 1) {\n                        // Datenquelle: Adapter-Instance (selInstance.alive + setStateForDB)\n                        if (si != null && si !== '') {\n                            const alive = await this.adapter.getForeignStateAsync(`system.adapter.${si}.alive`);\n                            if (alive && alive.val) {\n                                this.log.debug(`Instance ${si} is alive`);\n                                this.checkState = true;\n                            } else {\n                                this.log.warn(`Instance ${si} is not alive`);\n                                this.checkState = false;\n                            }\n                        } else {\n                            this.log.error('No selInstance configured');\n                            this.checkState = false;\n                        }\n\n                        if (sfd != null && sfd !== '') {\n                            const state = await this.adapter.getForeignStateAsync(sfd);\n                            if (state) {\n                                this.log.debug(`State ${sfd} for DB exists`);\n                                this.checkState = true;\n                            } else {\n                                this.log.warn(`State ${sfd} for DB does not exist`);\n                                this.checkState = false;\n                            }\n                        } else {\n                            this.log.error('No setStateForDB configured');\n                            this.checkState = false;\n                        }\n                    } else {\n                        this.log.error('Unknown instanceDataSource, skipping specific checks');\n                        this.checkState = false;\n                    }\n                } catch (error) {\n                    this.log.error(`Error onVisibilityChange: ${error as string}`);\n                }\n            }\n            // ich glaube nicht das du updaten willst, wenn das unsichtbar wird, auch wenns am anfang von this.update() abgefragt wird\n            await this.update();\n        }\n    }\n\n    protected async onStateTrigger(_id: string): Promise<void> {\n        if (this.unload || this.adapter.unload) {\n            return;\n        }\n        this.adapter.setTimeout(() => this.update(), 50);\n    }\n\n    async onButtonEvent(_event: IncomingEvent): Promise<void> {\n        //if (event.page && event.id && this.pageItems) {\n        //    this.pageItems[event.id as any].setPopupAction(event.action, event.opt);\n        //}\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
