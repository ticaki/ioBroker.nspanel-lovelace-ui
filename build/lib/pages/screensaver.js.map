{
  "version": 3,
  "sources": ["../../../src/lib/pages/screensaver.ts"],
  "sourcesContent": ["import * as Definition from '../const/definition';\nimport * as Color from '../const/Color';\nimport * as NSPanel from '../types/types';\n\n//import dayjs from 'dayjs';\nimport moment from 'moment';\nimport parseFormat from 'moment-parseformat';\nimport { sendTemplates, weatherUpdateTestArray } from '../types/msg-def';\nimport { Page, PageInterface } from './Page';\nimport { Icons } from '../const/icon_mapping';\nimport { PageTypeCards } from '../types/pages';\n\nexport type ScreensaverConfigType = {\n    momentLocale: string;\n    locale: string; //Intl.DateTimeFormat;\n    iconBig1: boolean;\n    iconBig2: boolean;\n};\n\nexport type ScreensaverConfig = {\n    card: Extract<PageTypeCards, 'screensaver' | 'screensaver2'>;\n    mode: NSPanel.ScreensaverModeType;\n    entitysConfig: NSPanel.ScreensaverOptionsType;\n    rotationTime: number;\n};\n\nexport class Screensaver extends Page {\n    private entitysConfig: NSPanel.ScreensaverOptionsType;\n    readonly layout: NSPanel.ScreensaverModeType = 'standard';\n    private config: ScreensaverConfigType;\n    private items: Record<\n        keyof Omit<NSPanel.ScreensaverOptionsType, 'mrIconEntity'>,\n        (NSPanel.ScreenSaverDataItems | undefined)[]\n    > &\n        Record<\n            keyof Pick<NSPanel.ScreensaverOptionsType, 'mrIconEntity'>,\n            (NSPanel.ScreenSaverDataItems | undefined)[]\n        > = {\n        favoritEntity: [],\n        leftEntity: [],\n        bottomEntity: [],\n        alternateEntity: [],\n        indicatorEntity: [],\n        mrIconEntity: [],\n    };\n    private rotationTime: number;\n    private timoutRotation: ioBroker.Timeout | undefined = undefined;\n    private step: number = 0;\n    constructor(config: PageInterface, options: ScreensaverConfig) {\n        switch (options.mode) {\n            case 'standard':\n            case 'alternate': {\n                config.card = 'screensaver';\n                break;\n            }\n            case 'advanced': {\n                config.card = 'screensaver2';\n                break;\n            }\n        }\n        config.alwaysOn = 'none';\n        super(config);\n\n        this.entitysConfig = options.entitysConfig;\n        this.layout = options.mode;\n\n        this.config = this.panel.config;\n        moment.locale(this.config.momentLocale);\n        this.rotationTime = options.rotationTime !== 0 && options.rotationTime < 3 ? 3000 : options.rotationTime * 1000;\n    }\n    async init(): Promise<void> {\n        const config = this.entitysConfig;\n        if (this.controller) {\n            for (const key of Definition.ScreenSaverAllPlaces) {\n                for (const entry of config[key]) {\n                    if (entry == null || entry === undefined) {\n                        this.items[key].push(undefined);\n                        continue;\n                    }\n                    const tempItem = await this.controller.statesControler.createDataItems(entry, this);\n                    switch (key) {\n                        case 'favoritEntity':\n                        case 'leftEntity':\n                        case 'bottomEntity':\n                        case 'indicatorEntity':\n                            this.items[key].push(tempItem);\n                            break;\n                        case 'mrIconEntity':\n                            this.items['mrIconEntity'].push(tempItem);\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    async update(): Promise<void> {\n        if (!this.visibility) {\n            this.log.error('get update command but not visible!');\n            return;\n        }\n\n        const payload: sendTemplates['weatherUpdate'] = { eventType: 'weatherUpdate', value: {} };\n        payload.value[this.layout] = [];\n        const value = payload.value[this.layout];\n        if (value === undefined) return;\n        for (const place of Definition.ScreenSaverPlaces) {\n            // let bottom rotated\n            let maxItems = Definition.ScreenSaverConst[this.layout][place].maxEntries;\n            let i = 0;\n            if (place == 'bottomEntity') {\n                i = maxItems * this.step;\n                maxItems = maxItems * (this.step + 1);\n            }\n            if (place == 'favoritEntity') {\n                this.log.debug('y');\n            }\n            for (i; i < maxItems; i++) {\n                const item: NSPanel.ScreenSaverDataItems | undefined = this.items[place][i];\n                if (\n                    item === null ||\n                    item === undefined ||\n                    item.entityValue === undefined ||\n                    item.entityValue.value === undefined\n                ) {\n                    value.push({ icon: '', iconColor: '', displayName: '', optionalValue: '' });\n                    continue;\n                }\n                //RegisterEntityWatcher(leftEntity.entity);\n\n                let iconColor = String(Color.rgb_dec565(Color.White));\n                let icon = '';\n                if (item.entityIcon && item.entityIcon.true.value) {\n                    const val = await item.entityIcon.true.value.getString();\n                    if (val !== null) icon = Icons.GetIcon(val);\n                }\n                let val: string | number | boolean | null = await item.entityValue.value.getNumber();\n                // if val not null its a number\n\n                if (item.entityValue.value.type == 'number' && val !== null) {\n                    if (item.entityValue.factor) {\n                        const v = await item.entityValue.factor.getNumber();\n                        if (v !== null) val *= v;\n                    }\n                    if (item.entityValue.decimal) {\n                        const v = await item.entityValue.decimal.getNumber();\n                        if (v !== null) val = val.toFixed(v);\n                    }\n                    if (item.entityValue.unit) {\n                        const v = await item.entityValue.unit.getString();\n                        if (v !== null) val += v;\n                    }\n\n                    iconColor = await GetScreenSaverEntityColor(item);\n                } else if (item.entityValue.value.type == 'boolean') {\n                    val = await item.entityValue.value.getBoolean();\n                    iconColor = await GetScreenSaverEntityColor(item);\n                    if (!val && item.entityIcon.false.value) {\n                        const t = await item.entityIcon.false.value.getString();\n                        if (t !== null) icon = Icons.GetIcon(t);\n                    }\n                    const b = val ? 'true' : 'false';\n                    if (item.entityText != undefined) {\n                        const i = item.entityText[b];\n                        if (i !== undefined) {\n                            const t = await i.getString();\n                            if (t !== null) val = this.library.getTranslation(t);\n                        } else {\n                            const i = item.entityText.true;\n                            const t = i !== undefined ? await i.getString() : null;\n                            if (t !== null) val = this.library.getTranslation(t);\n                        }\n                    }\n                } else if (\n                    item.entityValue.value.type == 'string' &&\n                    (val = await item.entityValue.value.getString()) !== null\n                ) {\n                    iconColor = await GetScreenSaverEntityColor(item);\n\n                    const pformat = parseFormat(val);\n\n                    this.log.debug(\n                        'moments.js --> Datum ' + val + ' valid?: ' + moment(val, pformat, true).isValid(),\n                        'info',\n                    );\n                    if (moment(val, pformat, true).isValid()) {\n                        const DatumZeit = moment(val, pformat).unix(); // Conversion to Unix time stamp\n                        const entityDateFormat = item.entityDateFormat ? await item.entityDateFormat.getObject() : null;\n                        val = new Date(DatumZeit * 1000).toLocaleString(\n                            this.config.locale,\n                            entityDateFormat !== null ? entityDateFormat : undefined,\n                        );\n                    }\n                }\n\n                let temp: any = item.entityIcon.true.color ? await item.entityIcon.true.color.getRGBDec() : null;\n                iconColor = temp ? temp : iconColor;\n                temp = item.entityText && item.entityText.true ? await item.entityText.true.getString() : null;\n                const entityText = temp ? this.library.getTranslation(temp) : '';\n                value.push({ icon, iconColor, displayName: entityText, optionalValue: val ? String(val) : '' });\n            }\n        }\n        if (this.layout === 'alternate') {\n            // hack: insert empty entry\n            const lastIndex = payload.value[this.layout]!.length - 1;\n            payload.value[this.layout]!.push(payload.value[this.layout]![lastIndex]);\n            payload.value[this.layout]![lastIndex] = { icon: '', iconColor: '', displayName: '', optionalValue: '' };\n        }\n\n        this.log.debug('HandleScreensaverUpdate payload: ' + JSON.stringify(payload.value[this.layout]));\n\n        this.sendStatusUpdate(payload, this.layout);\n\n        this.HandleScreensaverStatusIcons();\n    }\n\n    sendStatusUpdate(\n        payload: sendTemplates['statusUpdate'] | sendTemplates['weatherUpdate'],\n        layout: NSPanel.ScreensaverModeType,\n    ): void {\n        switch (payload.eventType) {\n            case 'statusUpdate':\n                this.sendToPanel(\n                    this.getPayload(\n                        payload.eventType,\n                        payload.icon1,\n                        payload.icon1Color,\n                        payload.icon2,\n                        payload.icon2Color,\n                        payload.icon1Font,\n                        payload.icon2Font,\n                        '',\n                    ),\n                );\n                break;\n            case 'weatherUpdate': {\n                let value = payload.value[layout];\n                if (!value) return;\n                const result: string[] = [payload.eventType];\n                const check = weatherUpdateTestArray![layout];\n                value = value.filter((item, pos) => check[pos]);\n                value.forEach((item, pos) => {\n                    const test = check[pos];\n                    if (item.icon && !test.icon) item.icon = '';\n                    if (item.iconColor && !test.iconColor) item.iconColor = '';\n                    if (item.displayName && (!('displayName' in test) || !test.displayName)) item.displayName = '';\n                    if (item.optionalValue && !test.icon) item.icon = '';\n                });\n                value.forEach(\n                    (a) =>\n                        a &&\n                        result.push(\n                            this.getPayload(\n                                '',\n                                '',\n                                a.icon,\n                                a.iconColor,\n                                'displayName' in a ? a.displayName : '',\n                                a.optionalValue,\n                            ),\n                        ),\n                );\n                this.sendToPanel(this.getPayloadArray([...result, '']));\n                break;\n            }\n        }\n    }\n    async onVisibilityChange(v: boolean): Promise<void> {\n        this.step = -1;\n        if (v) {\n            this.sendType();\n            this.rotationLoop();\n        } else {\n            if (this.timoutRotation) this.adapter.clearTimeout(this.timoutRotation);\n        }\n    }\n    rotationLoop = async (): Promise<void> => {\n        if (this.unload) return;\n        // only use this if screensaver is activated\n        if (!this.visibility) return;\n        const l = this.entitysConfig.bottomEntity.length;\n        const m = Definition.ScreenSaverConst[this.layout].bottomEntity.maxEntries;\n        if (l <= m * ++this.step) this.step = 0;\n\n        await this.update();\n\n        if (l <= m || this.rotationTime === 0) return;\n        this.timoutRotation = this.adapter.setTimeout(\n            this.rotationLoop,\n            this.rotationTime < 3000 ? 3000 : this.rotationTime,\n        );\n    };\n\n    onStateTrigger = async (): Promise<void> => {\n        this.update();\n    };\n\n    async HandleScreensaverStatusIcons(): Promise<void> {\n        const payload: Partial<sendTemplates['statusUpdate']> = { eventType: 'statusUpdate' };\n        const maxItems = Definition.ScreenSaverConst[this.layout]['mrIconEntity'].maxEntries;\n        for (let i = 0; i < maxItems; i++) {\n            const s: '1' | '2' = i == 0 ? '1' : '2';\n            const item = this.items['mrIconEntity'][i];\n            if (item === null || item === undefined) {\n                payload[`icon${s}`] = '';\n                payload[`icon${s}Color`] = '';\n                payload[`icon${s}Font`] = '';\n                continue;\n            }\n\n            let value: string | boolean | number | null = null;\n            if (item.entityValue && item.entityValue.value) {\n                switch (item.entityValue.value.type) {\n                    case 'string': {\n                        const v = await item.entityValue.value.getString();\n                        if (v !== null) value = v;\n                        break;\n                    }\n                    case 'number': {\n                        value = 0;\n                        const v = await item.entityValue.value.getNumber();\n                        const c = item.entityValue.decimal ? await item.entityValue.decimal.getNumber() : null;\n                        if (v !== null) value = v;\n                        if (c !== null) value = (value || 0).toFixed(c);\n                        break;\n                    }\n                    case 'boolean': {\n                        value = false;\n                        const v = item.entityValue.value ? await item.entityValue.value.getBoolean() : null;\n                        if (v !== null) value = v;\n                        break;\n                    }\n\n                    case 'object':\n                        const s: '1' | '2' = i == 0 ? '1' : '2';\n                        payload[`icon${s}`] = '';\n                        payload[`icon${s}Color`] = '';\n                        payload[`icon${s}Font`] = '';\n                        continue;\n                }\n            }\n            const entity =\n                item.entityValue && item.entityValue.value\n                    ? item.entityValue.value.type == 'string'\n                        ? await item.entityValue.value.getString()\n                        : await item.entityValue.value.getBoolean()\n                    : null;\n            const offcolor = item.entityIcon.false.color\n                ? await item.entityIcon.false.color.getRGBDec()\n                : String(Color.rgb_dec565(Color.White));\n            const onColor = item.entityIcon.true.color ? await item.entityIcon.true.color.getRGBDec() : null;\n            payload[`icon${s}Color`] = offcolor !== null ? offcolor : String(Color.rgb_dec565(Color.White));\n            if (item.entityValue != null || value !== null || onColor != null) {\n                // Pr\u00FCfung ob Entity vom Typ String ist\n                if (entity != null && onColor) {\n                    if (typeof entity == 'string') {\n                        this.log.debug('Entity ist String');\n                        switch (entity.toUpperCase()) {\n                            case 'ON':\n                            case 'OK':\n                            case 'AN':\n                            case 'YES':\n                            case 'TRUE':\n                            case 'ONLINE':\n                                payload[`icon${s}Color`] = onColor;\n                                break;\n                            default:\n                        }\n                        // Alles was kein String ist in Boolean umwandeln\n                    } else {\n                        this.log.debug('Entity ist kein String', 'info');\n                        if (entity) {\n                            payload[`icon${s}Color`] = onColor;\n                        }\n                    }\n                }\n                const entityIconSelect: any | null = item.entityIconSelect\n                    ? await item.entityIconSelect.getObject()\n                    : null;\n\n                // Icon ermitteln\n                const onIcon = item.entityIcon.true.value ? await item.entityIcon.true.value.getString() : null;\n                const offIcon = item.entityIcon.false.value ? await item.entityIcon.false.value.getString() : null;\n                const selectIcon =\n                    typeof entity !== 'boolean' && entity !== null && entityIconSelect\n                        ? (entityIconSelect[entity] as string | undefined)\n                        : undefined;\n\n                if (selectIcon) {\n                    payload[`icon${s}`] = Icons.GetIcon(selectIcon);\n                    this.log.debug('SelectIcon: ' + JSON.stringify(payload), 'info');\n                } else if (entity && onIcon) {\n                    payload[`icon${s}`] = Icons.GetIcon(onIcon);\n                    this.log.debug('Icon if true ' + JSON.stringify(payload), 'info');\n                } else {\n                    if (offIcon) {\n                        payload[`icon${s}`] = Icons.GetIcon(offIcon);\n                        this.log.debug('Icon1 else true ' + JSON.stringify(payload), 'info');\n                    } else if (onIcon) {\n                        payload[`icon${s}`] = Icons.GetIcon(onIcon);\n                        this.log.debug('Icon1 else false ' + JSON.stringify(payload), 'info');\n                    }\n                }\n\n                if (value !== null && value !== undefined) {\n                    payload[`icon${s}`] += String(value);\n                    const unit =\n                        item.entityValue && item.entityValue.unit ? await item.entityValue.unit.getString() : null;\n                    if (unit !== null) payload[`icon${s}`] += unit;\n                }\n            } else {\n                payload[`icon${s}Color`] = String(Color.rgb_dec565(Color.Black));\n            }\n            payload[`icon${s}Font`] = this.config[`iconBig${s}`] ? '1' : '';\n        }\n        this.sendStatusUpdate(payload as sendTemplates['statusUpdate'], this.layout);\n    }\n    async delete(): Promise<void> {\n        await super.delete();\n        if (this.timoutRotation) this.adapter.clearTimeout(this.timoutRotation);\n    }\n}\n\nasync function GetScreenSaverEntityColor(item: NSPanel.ScreenSaverDataItems | null): Promise<string> {\n    if (item && item.entityValue) {\n        let colorReturn: number | string;\n        const entityAsNumber = item.entityValue.value !== undefined ? await item.entityValue.value.getNumber() : null;\n        const entityFactor = item.entityValue.factor !== undefined ? await item.entityValue.factor.getNumber() : null;\n        const entityIconColorScale: NSPanel.IconScaleElement | null =\n            'scale' in item.entityIcon && item.entityIcon.scale !== undefined\n                ? await item.entityIcon.scale.getIconScale()\n                : null;\n        const entityOnColor = item.entityIcon.true.color ? await item.entityIcon.true.color.getRGBDec() : null;\n        const entityOffColor = item.entityIcon.false.color ? await item.entityIcon.false.color.getRGBDec() : null;\n        if (item.entityValue.value) {\n            if (entityIconColorScale !== null) {\n                if (item.entityValue.value.type == 'boolean') {\n                    const iconvalbest =\n                        entityIconColorScale && entityIconColorScale.val_best !== undefined\n                            ? !!entityIconColorScale.val_best\n                            : false;\n                    if (iconvalbest == (await item.entityValue.value.getBoolean())) {\n                        if (entityOnColor !== null) colorReturn = entityOnColor;\n                        else colorReturn = Color.rgb_dec565(Color.colorScale0);\n                    } else {\n                        if (entityOffColor !== null) colorReturn = entityOffColor;\n                        else colorReturn = Color.rgb_dec565(Color.colorScale10);\n                    }\n                } else if (entityIconColorScale !== null && entityAsNumber !== null) {\n                    const iconvalmin: number =\n                        entityIconColorScale.val_min != undefined ? entityIconColorScale.val_min : 0;\n                    const iconvalmax: number =\n                        entityIconColorScale.val_max != undefined ? entityIconColorScale.val_max : 100;\n                    const iconvalbest: number =\n                        entityIconColorScale.val_best != undefined ? entityIconColorScale.val_best : iconvalmin;\n                    let valueScale = entityAsNumber * (entityFactor !== null ? entityFactor : 1);\n\n                    if (iconvalmin == 0 && iconvalmax == 1) {\n                        if (await item.entityValue.value.getBoolean()) {\n                            if (entityOnColor !== null) colorReturn = entityOnColor;\n                            else colorReturn = Color.rgb_dec565(Color.colorScale0);\n                        } else {\n                            if (entityOffColor !== null) colorReturn = entityOffColor;\n                            else colorReturn = Color.rgb_dec565(Color.colorScale10);\n                        }\n                    } else {\n                        if (iconvalbest == iconvalmin) {\n                            valueScale = Color.scale(valueScale, iconvalmin, iconvalmax, 10, 0);\n                        } else {\n                            if (valueScale < iconvalbest) {\n                                valueScale = Color.scale(valueScale, iconvalmin, iconvalbest, 0, 10);\n                            } else if (valueScale > iconvalbest || iconvalbest != iconvalmin) {\n                                valueScale = Color.scale(valueScale, iconvalbest, iconvalmax, 10, 0);\n                            } else {\n                                valueScale = Color.scale(valueScale, iconvalmin, iconvalmax, 10, 0);\n                            }\n                        }\n                        //limit if valueScale is smaller/larger than 0-10\n                        if (valueScale > 10) valueScale = 10;\n                        if (valueScale < 0) valueScale = 0;\n\n                        const valueScaletemp = Math.round(valueScale).toFixed();\n                        colorReturn = Color.HandleColorScale(valueScaletemp);\n                    }\n                } else {\n                    colorReturn = Color.rgb_dec565(Color.White);\n                }\n            } else {\n                const entityAsBoolean =\n                    item.entityValue && item.entityValue.value ? await item.entityValue.value.getBoolean() : null;\n                if (item.entityValue.value.type == 'boolean' || item.entityValue.value.type == 'number') {\n                    if (entityAsBoolean !== null) {\n                        if (entityAsBoolean) {\n                            if (entityOnColor !== null) colorReturn = entityOnColor;\n                            else colorReturn = Color.rgb_dec565(Color.White);\n                        } else {\n                            if (entityOffColor !== null) colorReturn = entityOffColor;\n                            else colorReturn = Color.rgb_dec565(Color.White);\n                        }\n                    } else {\n                        if (entityOnColor !== null) colorReturn = entityOnColor;\n                        else colorReturn = Color.rgb_dec565(Color.White);\n                    }\n                } else {\n                    colorReturn = Color.rgb_dec565(Color.White);\n                }\n            }\n            return String(colorReturn);\n        }\n    }\n    return String(Color.rgb_dec565(Color.White));\n}\n"],
  "mappings": "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",
  "names": ["moment", "val", "i", "parseFormat", "s"]
}
