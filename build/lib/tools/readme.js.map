{
  "version": 3,
  "sources": ["../../../src/lib/tools/readme.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport { requiredScriptDataPoints } from '../const/config-manager-const';\n\nexport async function generateAliasDocumentation(): Promise<void> {\n    const checkPath = '.dev-data';\n    let header = `| Channel role | State ID | common.type | common.role | required | common.write | description |  \\n`;\n    header += `| :---: | :--- | :--- | :--- | :---: | :---: | :--- |  \\n`;\n\n    if (fs.existsSync(checkPath)) {\n        let lastFolder = '';\n        let table = '# Table of contents\\n';\n        let readme = '';\n        table += `* [Remarks](#feature-${'Remarks'.toLowerCase().replace(/[^a-z0-9]+/g, '')})\\n`;\n        for (const f in requiredScriptDataPoints) {\n            const folder = f as keyof typeof requiredScriptDataPoints;\n            const data = requiredScriptDataPoints[folder];\n            readme += `### ${folder}\\n`;\n            readme += header;\n            table += `* [${folder}](#${folder.toLowerCase().replace(/[^a-z0-9]+/g, '')})\\n`;\n\n            for (const k in data.data) {\n                const key = k as keyof typeof data.data;\n                const row = data.data[key];\n                if (row === undefined) {\n                    continue;\n                }\n                readme += `| **${folder == lastFolder ? '\"' : folder}** | ${row.useKey ? key : `~~${key}~~`} | ${row.type}| ${getStringOrArray(row.role)}  | ${row.required ? 'X' : ''} | ${row.writeable ? 'X' : ''} | ${row.description ? row.description : ''} | \\n`;\n                lastFolder = folder;\n            }\n        }\n        table += `## Remarks\\n`;\n        table +=\n            '\\n -(not fully implemented) Crossed out DPs can be called whatever you want, only use the name if you have questions in issues or in the forum. \\n';\n        fs.writeFileSync('ALIAS.md', table + readme);\n    }\n}\n\n/*import ChannelDetector, { PatternControl, type DetectOptions, type Types } from '@iobroker/type-detector';\nimport {NspanelLovelaceUi} from '../types/NspanelLovelaceUi';\n\nexport async function testTypeDetector(adapter: NspanelLovelaceUi): Promise<void> {\n    const detector: ChannelDetector = new ChannelDetector();\n\n    //const keys = Object.keys(objects); // For optimization\n    const usedIds: string[] = []; // To not allow using of same ID in more than one device\n    const ignoreIndicators: string[] = ['UNREACH_STICKY']; // Ignore indicators by name\n    //const allowedTypes: Types[] = ['button', 'rgb', 'dimmer', 'light']; // Supported types. Leave it null if you want to get ALL devices.\n\n    const options: DetectOptions = {\n        objects: adapter.\n        id: 'hm-rpc.0.LEQ1214232.1', // Channel, device or state, that must be detected\n        _keysOptional: keys,\n        _usedIdsOptional: usedIds,\n        ignoreIndicators,\n        // allowedTypes,\n    };\n    const test = adapter.getStatesOfAsync\n    let controls: PatternControl[] | undefined | null = detector.detect(options);\n    if (controls) {\n        const cs = controls.map((control: PatternControl) => {\n            const id = control.states.find((state: DetectorState) => state.id).id;\n            if (id) {\n                console.log(`In ${options.id} was detected \"${control.type}\" with following states:`);\n                control.states\n                    .filter((state: DetectorState) => state.id)\n                    .forEach((state: DetectorState) => {\n                        console.log(`    ${state.name} => ${state.id}`);\n                    });\n\n                return { control, id };\n            }\n        });\n    } else {\n        console.log(`Nothing found for ${options.id}`);\n    }\n}*/\n\nexport function getStringOrArray(item: string | string[]): string {\n    if (Array.isArray(item)) {\n        return item.join(', ') || '';\n    }\n    return item;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,kCAAyC;AAEzC,eAAsB,6BAA4C;AAC9D,QAAM,YAAY;AAClB,MAAI,SAAS;AAAA;AACb,YAAU;AAAA;AAEV,MAAI,GAAG,WAAW,SAAS,GAAG;AAC1B,QAAI,aAAa;AACjB,QAAI,QAAQ;AACZ,QAAI,SAAS;AACb,aAAS,wBAAwB,UAAU,YAAY,EAAE,QAAQ,eAAe,EAAE,CAAC;AAAA;AACnF,eAAW,KAAK,sDAA0B;AACtC,YAAM,SAAS;AACf,YAAM,OAAO,qDAAyB,MAAM;AAC5C,gBAAU,OAAO,MAAM;AAAA;AACvB,gBAAU;AACV,eAAS,MAAM,MAAM,MAAM,OAAO,YAAY,EAAE,QAAQ,eAAe,EAAE,CAAC;AAAA;AAE1E,iBAAW,KAAK,KAAK,MAAM;AACvB,cAAM,MAAM;AACZ,cAAM,MAAM,KAAK,KAAK,GAAG;AACzB,YAAI,QAAQ,QAAW;AACnB;AAAA,QACJ;AACA,kBAAU,OAAO,UAAU,aAAa,MAAM,MAAM,QAAQ,IAAI,SAAS,MAAM,KAAK,GAAG,IAAI,MAAM,IAAI,IAAI,KAAK,iBAAiB,IAAI,IAAI,CAAC,OAAO,IAAI,WAAW,MAAM,EAAE,MAAM,IAAI,YAAY,MAAM,EAAE,MAAM,IAAI,cAAc,IAAI,cAAc,EAAE;AAAA;AAChP,qBAAa;AAAA,MACjB;AAAA,IACJ;AACA,aAAS;AAAA;AACT,aACI;AACJ,OAAG,cAAc,YAAY,QAAQ,MAAM;AAAA,EAC/C;AACJ;AA0CO,SAAS,iBAAiB,MAAiC;AAC9D,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,WAAO,KAAK,KAAK,IAAI,KAAK;AAAA,EAC9B;AACA,SAAO;AACX;",
  "names": []
}
