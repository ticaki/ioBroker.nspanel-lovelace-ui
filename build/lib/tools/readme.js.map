{
  "version": 3,
  "sources": ["../../../src/lib/tools/readme.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport { requiredScriptDataPoints } from '../const/config-manager-const';\n\nimport { promises as fsp } from 'fs';\nimport * as path from 'path';\n\nconst slug = (s: string): string => s.toLowerCase().replace(/[^a-z0-9]+/g, '');\nconst esc = (s: string | undefined): string => (s ?? '').replace(/\\|/g, '\\\\|');\n\n/**\n * Generates ALIAS.md with table of contents and channel/state documentation.\n */\nexport async function generateAliasDocumentation(): Promise<void> {\n    const checkPath = '.dev-data';\n    if (!fs.existsSync(checkPath)) {\n        return;\n    }\n\n    const header =\n        '| Channel role | State ID | common.type | common.role | required | common.write | description |\\n' +\n        '| :---: | :--- | :--- | :--- | :---: | :---: | :--- |\\n';\n\n    let toc = '# Table of contents\\n';\n    let body = '';\n\n    toc += `* [Remarks](#${slug('Remarks')})\\n`;\n\n    const folders = Object.keys(requiredScriptDataPoints).sort();\n\n    for (const folder of folders) {\n        const data = requiredScriptDataPoints[folder as keyof typeof requiredScriptDataPoints];\n        const sectionAnchor = slug(folder);\n\n        toc += `* [${folder}](#${sectionAnchor})\\n`;\n        body += `\\n### ${folder}\\n${header}`;\n\n        const keys = Object.keys(data.data).sort();\n        let firstRow = true;\n\n        for (const key of keys) {\n            const row = data.data[key as keyof typeof data.data];\n            if (!row) {\n                continue;\n            }\n\n            const channelCol = firstRow ? `**${folder}**` : '\"';\n            firstRow = false;\n\n            body += `| ${channelCol} | ${\n                row.useKey ? esc(key) : `~~${esc(key)}~~`\n            } | ${esc(getStringOrArray(row.type))} | ${esc(\n                getStringOrArray(row.role),\n            )} | ${row.required ? 'X' : ''} | ${row.writeable ? 'X' : ''} | ${esc(row.description)} |\\n`;\n        }\n    }\n\n    body =\n        `\\n## Remarks\\n\\n` +\n        `- (not fully implemented) Crossed out DPs can be named arbitrarily. Use the struck key only for questions in issues or in the forum.\\n` +\n        `\\n${body}`;\n\n    const out = `${toc}\\n${body}`;\n    await fsp.writeFile(path.join(process.cwd(), 'ALIAS.md'), out, 'utf8');\n}\n/*export async function generateAliasDocumentation(): Promise<void> {\n    const checkPath = '.dev-data';\n    let header = `| Channel role | State ID | common.type | common.role | required | common.write | description |  \\n`;\n    header += `| :---: | :--- | :--- | :--- | :---: | :---: | :--- |  \\n`;\n\n    if (fs.existsSync(checkPath)) {\n        let lastFolder = '';\n        let table = '# Table of contents\\n';\n        let readme = '';\n        table += `* [Remarks](#feature-${'Remarks'.toLowerCase().replace(/[^a-z0-9]+/g, '')})\\n`;\n        for (const f in requiredScriptDataPoints) {\n            const folder = f as keyof typeof requiredScriptDataPoints;\n            const data = requiredScriptDataPoints[folder];\n            readme += `### ${folder}\\n`;\n            readme += header;\n            table += `* [${folder}](#${folder.toLowerCase().replace(/[^a-z0-9]+/g, '')})\\n`;\n\n            for (const k in data.data) {\n                const key = k as keyof typeof data.data;\n                const row = data.data[key];\n                if (row === undefined) {\n                    continue;\n                }\n                readme += `| **${folder == lastFolder ? '\"' : folder}** | ${row.useKey ? key : `~~${key}~~`} | ${getStringOrArray(row.type)}| ${getStringOrArray(row.role)}  | ${row.required ? 'X' : ''} | ${row.writeable ? 'X' : ''} | ${row.description ? row.description : ''} | \\n`;\n                lastFolder = folder;\n            }\n        }\n        table += `## Remarks\\n`;\n        table +=\n            '\\n -(not fully implemented) Crossed out DPs can be called whatever you want, only use the name if you have questions in issues or in the forum. \\n';\n        fs.writeFileSync('ALIAS.md', table + readme);\n    }\n}*/\n\nexport function getStringOrArray(item: string | string[]): string {\n    if (Array.isArray(item)) {\n        return item.join(', ') || '';\n    }\n    return item;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,kCAAyC;AAEzC,gBAAgC;AAChC,WAAsB;AAEtB,MAAM,OAAO,CAAC,MAAsB,EAAE,YAAY,EAAE,QAAQ,eAAe,EAAE;AAC7E,MAAM,MAAM,CAAC,OAAmC,gBAAK,IAAI,QAAQ,OAAO,KAAK;AAK7E,eAAsB,6BAA4C;AAC9D,QAAM,YAAY;AAClB,MAAI,CAAC,GAAG,WAAW,SAAS,GAAG;AAC3B;AAAA,EACJ;AAEA,QAAM,SACF;AAGJ,MAAI,MAAM;AACV,MAAI,OAAO;AAEX,SAAO,gBAAgB,KAAK,SAAS,CAAC;AAAA;AAEtC,QAAM,UAAU,OAAO,KAAK,oDAAwB,EAAE,KAAK;AAE3D,aAAW,UAAU,SAAS;AAC1B,UAAM,OAAO,qDAAyB,MAA+C;AACrF,UAAM,gBAAgB,KAAK,MAAM;AAEjC,WAAO,MAAM,MAAM,MAAM,aAAa;AAAA;AACtC,YAAQ;AAAA,MAAS,MAAM;AAAA,EAAK,MAAM;AAElC,UAAM,OAAO,OAAO,KAAK,KAAK,IAAI,EAAE,KAAK;AACzC,QAAI,WAAW;AAEf,eAAW,OAAO,MAAM;AACpB,YAAM,MAAM,KAAK,KAAK,GAA6B;AACnD,UAAI,CAAC,KAAK;AACN;AAAA,MACJ;AAEA,YAAM,aAAa,WAAW,KAAK,MAAM,OAAO;AAChD,iBAAW;AAEX,cAAQ,KAAK,UAAU,MACnB,IAAI,SAAS,IAAI,GAAG,IAAI,KAAK,IAAI,GAAG,CAAC,IACzC,MAAM,IAAI,iBAAiB,IAAI,IAAI,CAAC,CAAC,MAAM;AAAA,QACvC,iBAAiB,IAAI,IAAI;AAAA,MAC7B,CAAC,MAAM,IAAI,WAAW,MAAM,EAAE,MAAM,IAAI,YAAY,MAAM,EAAE,MAAM,IAAI,IAAI,WAAW,CAAC;AAAA;AAAA,IAC1F;AAAA,EACJ;AAEA,SACI;AAAA;AAAA;AAAA;AAAA;AAAA,EAEK,IAAI;AAEb,QAAM,MAAM,GAAG,GAAG;AAAA,EAAK,IAAI;AAC3B,QAAM,UAAAA,SAAI,UAAU,KAAK,KAAK,QAAQ,IAAI,GAAG,UAAU,GAAG,KAAK,MAAM;AACzE;AAmCO,SAAS,iBAAiB,MAAiC;AAC9D,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,WAAO,KAAK,KAAK,IAAI,KAAK;AAAA,EAC9B;AACA,SAAO;AACX;",
  "names": ["fsp"]
}
