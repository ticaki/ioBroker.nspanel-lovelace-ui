{
  "version": 3,
  "sources": ["../../../src/lib/classes/mqtt.ts"],
  "sourcesContent": ["import mqtt, { type IClientPublishOptions } from 'mqtt'; // import namespace \"mqtt\"\nimport { Level } from 'level';\n\n//@ts-expect-error no types\nimport aedesPersistencelevel from 'aedes-persistence-level';\nimport * as factory from 'aedes-server-factory';\nimport { BaseClass, type AdapterClassDefinition } from '../controller/library';\n\nimport Aedes, { type Client } from 'aedes';\nimport { type Server } from 'net';\nimport { randomUUID } from 'node:crypto';\nimport * as forge from 'node-forge';\nimport type { Controller } from '../controller/controller';\nexport type callbackMessageType = (topic: string, message: string) => Promise<void | boolean>;\nexport type callbackConnectType = () => Promise<void>;\n\n// RSA-Schl\u00FCsselpaar erzeugen (4096 Bit f\u00FCr hohe Sicherheit)\n\nexport class MQTTClientClass extends BaseClass {\n    client: mqtt.MqttClient;\n    data: any = {};\n    ready: boolean = false;\n    public messageCallback: callbackMessageType;\n    clientId: string;\n\n    // Flat registry of subscriptions (topic + callback)\n    private subscriptDB: { topic: string; callback: callbackMessageType }[] = [];\n\n    _onConnect?: { timeout: ioBroker.Timeout | undefined; callback: (timeout: ioBroker.Timeout | undefined) => void };\n    _onDisconnect?: {\n        timeout: ioBroker.Timeout | undefined;\n        callback: (timeout: ioBroker.Timeout | undefined) => void;\n    };\n\n    constructor(\n        adapter: AdapterClassDefinition,\n        ip: string,\n        port: number,\n        username: string,\n        password: string,\n        tls: boolean,\n        callback: callbackMessageType,\n    ) {\n        super(adapter, 'mqttClient');\n        this.clientId = `iobroker_${randomUUID()}`;\n        this.messageCallback = callback;\n\n        this.client = mqtt.connect(`${tls ? 'tls' : 'mqtt'}://${ip}:${port}`, {\n            username,\n            password,\n            clientId: this.clientId,\n            rejectUnauthorized: false,\n        });\n\n        this.client.on('connect', () => {\n            this.log.debug('MQTT connected.');\n            this.ready = true;\n            if (this._onConnect) {\n                this._onConnect.callback(this._onConnect.timeout);\n            }\n            void this.adapter.setState('info.connection', true, true);\n        });\n\n        this.client.on('disconnect', () => {\n            this.ready = false;\n            this.log.info('MQTT disconnected (graceful).');\n            if (this._onDisconnect) {\n                void this._onDisconnect.callback(this._onDisconnect.timeout);\n            }\n            void this.adapter.setState('info.connection', false, true);\n        });\n\n        this.client.on('error', err => {\n            this.ready = false;\n\n            this.log.error(`MQTT error: ${String(err)}`);\n        });\n\n        this.client.on('close', () => {\n            this.ready = false;\n            this.log.info('MQTT connection closed.');\n            if (this._onDisconnect) {\n                void this._onDisconnect.callback(this._onDisconnect.timeout);\n            }\n            void this.adapter.setState('info.connection', false, true);\n        });\n\n        this.client.on('message', (topic, message) => {\n            const _helper = async (topic: string, message: Buffer): Promise<void> => {\n                // NOTE: Simple prefix match with '/#' trimming, unchanged semantics\n                const callbacks = this.subscriptDB.filter(entry => topic.startsWith(entry.topic.replace('/#', '')));\n\n                if (this.adapter.config.debugLogMqtt) {\n                    this.log.debug(\n                        `MQTT message: matched ${callbacks.length} handler(s) | topic=\"${topic}\" | payload=\"${message.toString()}\"`,\n                    );\n                }\n\n                const toRemove: Array<{ topic: string; callback: callbackMessageType }> = [];\n                for (const c of callbacks) {\n                    try {\n                        if (await c.callback(topic, message.toString())) {\n                            toRemove.push({ topic: c.topic, callback: c.callback });\n                        }\n                    } catch (e) {\n                        this.log.warn(\n                            `MQTT handler threw for topic=\"${topic}\": ${String(e)} (handler kept, no unsubscribe)`,\n                        );\n                    }\n                }\n\n                if (toRemove.length > 0) {\n                    // Remove only the finished callback entries.\n                    for (const rem of toRemove) {\n                        const before = this.countCallbacks(rem.topic);\n                        this.removeSubscriptionEntry(rem.topic, rem.callback);\n                        const after = this.countCallbacks(rem.topic);\n\n                        if (after === 0) {\n                            // No remaining callbacks for this topic -> broker unsubscribe\n                            this.unsubscribe(rem.topic); // keeps external log text and behavior of unsubscribe()\n                        } else if (this.adapter.config.debugLogMqtt) {\n                            this.log.debug(\n                                `MQTT keep subscription: topic=\"${rem.topic}\" still has ${after}/${before} handler(s)`,\n                            );\n                        }\n                    }\n                }\n            };\n            void _helper(topic, message);\n        });\n    }\n\n    async waitConnectAsync(timeout: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this._onConnect = {\n                timeout: this.adapter.setTimeout(() => {\n                    reject(new Error(`Timeout for main mqttclient after ${timeout}ms`));\n                }, timeout),\n                callback: (timeoutRef: ioBroker.Timeout | undefined) => {\n                    if (timeoutRef) {\n                        this.adapter.clearTimeout(timeoutRef);\n                    }\n                    this._onConnect = undefined;\n                    resolve();\n                },\n            };\n        });\n    }\n\n    async waitPanelConnectAsync(_topic: string, timeout: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const topic = `${_topic}/tele/INFO1`;\n            this.log.debug(`Wait for panel connect on: ${topic}`);\n            let ref: ioBroker.Timeout | undefined;\n            if (timeout > 0) {\n                ref = this.adapter.setTimeout(() => {\n                    reject(new Error(`Timeout for main mqttclient after ${timeout}ms`));\n                }, timeout);\n            }\n\n            void this.subscribe(topic, async () => {\n                if (ref) {\n                    this.adapter.clearTimeout(ref);\n                }\n                this.log.debug(`Panel connect detected: ${topic}`);\n                resolve();\n                return true; // remove this one-shot listener\n            });\n        });\n    }\n\n    async publish(topic: string, message: string, opt?: IClientPublishOptions): Promise<void> {\n        try {\n            if (!this.client.connected) {\n                if (this.adapter.config.debugLogMqtt) {\n                    this.log.debug(`Publish skipped (not connected): topic=\"${topic}\" payload=\"${message}\"`);\n                }\n                return;\n            }\n            if (this.adapter.config.debugLogMqtt) {\n                this.log.debug(`Publish: topic=\"${topic}\" payload=\"${message}\"`);\n            }\n            await this.client.publishAsync(topic, message, opt);\n        } catch (e) {\n            this.log.error(`Error in publish (topic=\"${topic}\"): ${e as string}`);\n        }\n    }\n\n    unsubscribe(topic: string): void {\n        // Remove a single entry then unsubscribe broker-side; this mirrors original behavior.\n        const index = this.subscriptDB.findIndex(m => m.topic === topic);\n        if (index !== -1) {\n            this.subscriptDB.splice(index, 1);\n            const count = this.countCallbacks(topic);\n            if (count === 0) {\n                this.log.debug(`unsubscribe from: ${topic}`);\n                this.client.unsubscribe(topic);\n            } else if (this.adapter.config.debugLogMqtt) {\n                this.log.debug(`keep subscription: topic=\"${topic}\" still has ${count} handler(s)`);\n            }\n        }\n    }\n    removeByFunction(callback: callbackMessageType): void {\n        // Remove all entries with this callback, then unsubscribe broker-side if needed.\n        const toRemove = this.subscriptDB.filter(m => m.callback === callback);\n        for (const rem of toRemove) {\n            this.removeSubscriptionEntry(rem.topic, rem.callback);\n            const count = this.countCallbacks(rem.topic);\n            if (count === 0) {\n                this.log.debug(`unsubscribe from: ${rem.topic}`);\n                this.client.unsubscribe(rem.topic);\n            } else if (this.adapter.config.debugLogMqtt) {\n                this.log.debug(`keep subscription: topic=\"${rem.topic}\" still has ${count} handler(s)`);\n            }\n        }\n    }\n\n    async subscribe(topic: string, callback: callbackMessageType): Promise<void> {\n        // Prevent duplicate (topic+callback) pairs\n        if (this.subscriptDB.findIndex(m => m.topic === topic && m.callback === callback) !== -1) {\n            if (this.adapter.config.debugLogMqtt) {\n                this.log.debug(`subscribe skipped (duplicate handler): ${topic}`);\n            }\n            return;\n        }\n\n        const firstOnTopic = this.subscriptDB.findIndex(m => m.topic === topic) === -1;\n        this.subscriptDB.push({ topic, callback });\n\n        if (firstOnTopic) {\n            this.log.debug(`subscribe to: ${topic}`);\n            await this.client.subscribeAsync(topic, { qos: 1 });\n        } else if (this.adapter.config.debugLogMqtt) {\n            const count = this.countCallbacks(topic);\n            this.log.debug(`added handler for topic=\"${topic}\" (handlers on topic: ${count})`);\n        }\n    }\n\n    async destroy(): Promise<void> {\n        await this.delete();\n        const endMqttClient = (): Promise<void> =>\n            new Promise(resolve => {\n                this.client.end(false, () => resolve());\n            });\n        await endMqttClient();\n    }\n\n    // ========= Internal helpers (no change to external API/returns) =========\n\n    /**\n     * Count registered callbacks for a given topic.\n     *\n     * @param topic the topic to check\n     */\n    private countCallbacks(topic: string): number {\n        return this.subscriptDB.reduce((acc, m) => (m.topic === topic ? acc + 1 : acc), 0);\n    }\n\n    /**\n     * Remove exactly one (topic, callback) pair from registry (no logging, no broker action).\n     *\n     * @param topic the topic\n     * @param callback the callback\n     */\n    private removeSubscriptionEntry(topic: string, callback: callbackMessageType): void {\n        const idx = this.subscriptDB.findIndex(m => m.topic === topic && m.callback === callback);\n        if (idx !== -1) {\n            this.subscriptDB.splice(idx, 1);\n        }\n    }\n}\n\nexport class MQTTServerClass extends BaseClass {\n    aedes: Aedes;\n    server: Server;\n    controller: Controller | undefined;\n    intervals: (ioBroker.Interval | undefined)[] = [];\n    callbacks: { [key: string]: { callback: () => void; timeout: ioBroker.Timeout | undefined } } = {};\n    ready: boolean = false;\n    test: Promise<void> | undefined = undefined;\n\n    static async createMQTTServer(\n        adapter: AdapterClassDefinition,\n        port: number,\n        username: string,\n        password: string,\n        path: string,\n        testCase: boolean = false,\n    ): Promise<MQTTServerClass> {\n        let mqttKeys: Record<'certPem' | 'privateKey' | 'publicKey', string> | undefined;\n\n        if (\n            (await adapter.fileExistsAsync(adapter.namespace, 'keys/private-key.pem')) &&\n            (await adapter.fileExistsAsync(adapter.namespace, 'keys/public-key.pem')) &&\n            (await adapter.fileExistsAsync(adapter.namespace, 'keys/certificate.pem'))\n        ) {\n            try {\n                const privateKey = (\n                    await adapter.readFileAsync(adapter.namespace, 'keys/private-key.pem')\n                ).file.toString();\n                const publicKey = (\n                    await adapter.readFileAsync(adapter.namespace, 'keys/public-key.pem')\n                ).file.toString();\n                const certificate = (\n                    await adapter.readFileAsync(adapter.namespace, 'keys/certificate.pem')\n                ).file.toString();\n\n                await adapter.writeFileAsync(`${adapter.namespace}.keys`, 'private-key.pem', privateKey);\n                await adapter.writeFileAsync(`${adapter.namespace}.keys`, 'public-key.pem', publicKey);\n                await adapter.writeFileAsync(`${adapter.namespace}.keys`, 'certificate.pem', certificate);\n\n                await adapter.delFileAsync(adapter.namespace, 'keys/private-key.pem');\n                await adapter.delFileAsync(adapter.namespace, 'keys/public-key.pem');\n                await adapter.delFileAsync(adapter.namespace, 'keys/certificate.pem');\n                adapter.log.info(`Moved keys to ${adapter.namespace}.keys`);\n            } catch (err) {\n                adapter.log.error(`Failed to migrate key files: ${err instanceof Error ? err.message : String(err)}`);\n            }\n        }\n        if (\n            (await adapter.fileExistsAsync(`${adapter.namespace}.keys`, 'private-key.pem')) &&\n            (await adapter.fileExistsAsync(`${adapter.namespace}.keys`, 'public-key.pem')) &&\n            (await adapter.fileExistsAsync(`${adapter.namespace}.keys`, 'certificate.pem'))\n        ) {\n            try {\n                mqttKeys = { privateKey: '', publicKey: '', certPem: '' };\n                mqttKeys.privateKey = (\n                    await adapter.readFileAsync(`${adapter.namespace}.keys`, 'private-key.pem')\n                ).file.toString();\n                mqttKeys.publicKey = (\n                    await adapter.readFileAsync(`${adapter.namespace}.keys`, 'public-key.pem')\n                ).file.toString();\n                mqttKeys.certPem = (\n                    await adapter.readFileAsync(`${adapter.namespace}.keys`, 'certificate.pem')\n                ).file.toString();\n                await adapter.extendObject(`${adapter.namespace}`, {\n                    type: 'meta',\n                    native: {\n                        mqttKeys,\n                    },\n                });\n\n                await adapter.delFileAsync(`${adapter.namespace}.keys`, 'private-key.pem');\n                await adapter.delFileAsync(`${adapter.namespace}.keys`, 'public-key.pem');\n                await adapter.delFileAsync(`${adapter.namespace}.keys`, 'certificate.pem');\n                adapter.log.info(`Moved keys to ${adapter.namespace}.keys`);\n            } catch (err) {\n                adapter.log.error(`Failed to migrate key files: ${err instanceof Error ? err.message : String(err)}`);\n            }\n        }\n        const obj = await adapter.getObjectAsync(`${adapter.namespace}`);\n        if (obj?.native?.mqttKeys) {\n            mqttKeys = obj.native.mqttKeys as keyof typeof mqttKeys;\n        }\n\n        if (!(mqttKeys?.privateKey && mqttKeys?.publicKey && mqttKeys?.certPem)) {\n            adapter.log.info(`Create new keys for MQTT server.`);\n            mqttKeys = { privateKey: '', publicKey: '', certPem: '' };\n\n            // Schl\u00FCsselpaar generieren\n            const prekeys = forge.pki.rsa.generateKeyPair(4096);\n            mqttKeys.privateKey = forge.pki.privateKeyToPem(prekeys.privateKey);\n            mqttKeys.publicKey = forge.pki.publicKeyToPem(prekeys.publicKey);\n\n            // Zertifikat erstellen\n            const cert = forge.pki.createCertificate();\n            cert.publicKey = prekeys.publicKey;\n            cert.serialNumber = '01'; // Eine eindeutige Seriennummer als HEX\n            cert.validity.notBefore = new Date();\n            cert.validity.notAfter = new Date();\n            cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1); // 1 Jahr g\u00FCltig\n\n            // Zertifikats-Infos (X.509 Subject & Issuer)\n            const attrs = [\n                { name: 'commonName', value: 'localhost' },\n                { name: 'countryName', value: 'DE' },\n                { name: 'organizationName', value: 'Meine Firma' },\n            ];\n            cert.setSubject(attrs);\n            cert.setIssuer(attrs);\n\n            // Selbstsignieren mit SHA-256\n            cert.sign(prekeys.privateKey, forge.md.sha256.create());\n\n            // PEM-Format exportieren\n            mqttKeys.certPem = forge.pki.certificateToPem(cert);\n\n            // In Dateien speichern\n\n            // Schl\u00FCssel in Objekt speichern\n            await adapter.extendObject(`${adapter.namespace}`, {\n                type: 'meta',\n                native: {\n                    mqttKeys,\n                },\n            });\n        }\n        return new MQTTServerClass(adapter, port, username, password, path, mqttKeys, testCase);\n    }\n\n    constructor(\n        adapter: AdapterClassDefinition,\n        port: number,\n        username: string,\n        password: string,\n        path: string,\n        keyPair: Record<string, string>,\n        testCase: boolean = false,\n    ) {\n        super(adapter, 'mqttServer');\n        const persistence = aedesPersistencelevel(new Level(path));\n\n        this.aedes = new Aedes({ persistence: persistence });\n        if (testCase) {\n            //nothing\n        }\n        this.server = factory.createServer(this.aedes, {\n            tls: {\n                key: Buffer.from(keyPair.privateKey),\n                cert: Buffer.from(keyPair.certPem),\n            },\n        });\n        //this.server = createServer(this.aedes.handle);\n\n        this.server.listen(port, () => {\n            this.ready = true;\n            this.log.info(`MQTT server started and listening on port ${port}`);\n        });\n\n        // Logge explizit Fehler beim Server-Socket (z. B. Port schon belegt)\n        this.server.on('error', err => {\n            this.ready = false;\n            this.log.error(`MQTT server error on port ${port}: ${String(err)}`);\n        });\n        this.aedes.authenticate = (\n            client: Client,\n            un: Readonly<string | undefined>,\n            pw: Readonly<Buffer | undefined>,\n            callback: any,\n        ) => {\n            const confirm = username === un && password === pw?.toString();\n            if (!confirm) {\n                this.log.warn(`Login denied: client=\"${client.id}\", username=\"${un ?? 'undefined'}\"`);\n            } else {\n                this.log.debug(`Client \"${client.id}\" login successful (user=\"${un ?? 'undefined'}\").`);\n            }\n            callback(null, confirm);\n        };\n        this.aedes.on('client', (client: Client) => {\n            for (const key in this.callbacks) {\n                if (this.callbacks[key]) {\n                    if (client.id.startsWith(key)) {\n                        if (this.adapter.config.debugLogMqtt) {\n                            this.log.debug(`Client ${client.id} connected. Call callback.`);\n                        }\n                        if (this.callbacks[key].timeout) {\n                            this.adapter.clearTimeout(this.callbacks[key].timeout);\n                            this.callbacks[key].timeout = undefined;\n                        }\n                        this.callbacks[key].callback();\n                        delete this.callbacks[key];\n                    }\n                }\n            }\n            const interval: ioBroker.Interval | undefined = this.adapter.setInterval(\n                index => {\n                    if (this.controller) {\n                        const result = this.controller.mqttClientConnected(client.id);\n                        if (result) {\n                            this.log.debug(`Client ${client.id} connected.`);\n                        }\n                        if (result || result === undefined) {\n                            this.adapter.clearInterval(this.intervals[index]);\n                            this.intervals[index] = undefined;\n\n                            // clear outdated intervals from top to bottom. Break if one is not undefined\n                            for (let a = this.intervals.length - 1; a >= 0; a--) {\n                                if (this.intervals[a] === undefined) {\n                                    this.intervals.splice(a, 1);\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                },\n                1000,\n                this.intervals.length,\n            );\n            this.intervals.push(interval);\n        });\n    }\n\n    destroy(): void {\n        void this.delete();\n        for (let a = this.intervals.length - 1; a >= 0; a--) {\n            if (this.intervals[a] !== undefined) {\n                this.adapter.clearInterval(this.intervals[a]);\n            }\n        }\n        this.intervals = [];\n        this.aedes.close();\n        this.server.close();\n    }\n}\n"],
  "mappings": "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",
  "names": ["mqtt", "topic", "message", "aedesPersistencelevel", "Aedes"]
}
