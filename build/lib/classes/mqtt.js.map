{
  "version": 3,
  "sources": ["../../../src/lib/classes/mqtt.ts"],
  "sourcesContent": ["import mqtt, { type IClientPublishOptions } from 'mqtt'; // import namespace \"mqtt\"\nimport { Level } from 'level';\n\n//@ts-expect-error no types\nimport aedesPersistencelevel from 'aedes-persistence-level';\nimport * as factory from 'aedes-server-factory';\nimport { BaseClass, type AdapterClassDefinition } from './library';\n\nimport Aedes, { type Client } from 'aedes';\nimport { type Server } from 'net';\nimport { randomUUID } from 'node:crypto';\nimport * as forge from 'node-forge';\nimport type { Controller } from '../controller/controller';\nexport type callbackMessageType = (topic: string, message: string) => Promise<void | boolean>;\nexport type callbackConnectType = () => Promise<void>;\n\n// RSA-Schl\u00FCsselpaar erzeugen (4096 Bit f\u00FCr hohe Sicherheit)\n\nexport class MQTTClientClass extends BaseClass {\n    client: mqtt.MqttClient;\n    data: any = {};\n    ready: boolean = false;\n    public messageCallback: callbackMessageType;\n    clientId: string;\n    private subscriptDB: { topic: string; callback: callbackMessageType }[] = [];\n    _onConnect?: { timeout: ioBroker.Timeout | undefined; callback: (timeout: ioBroker.Timeout | undefined) => void };\n    _onDisconnect?: {\n        timeout: ioBroker.Timeout | undefined;\n        callback: (timeout: ioBroker.Timeout | undefined) => void;\n    };\n\n    constructor(\n        adapter: AdapterClassDefinition,\n        ip: string,\n        port: number,\n        username: string,\n        password: string,\n        tls: boolean,\n        callback: callbackMessageType,\n    ) {\n        super(adapter, 'mqttClient');\n        this.clientId = `iobroker_${randomUUID()}`;\n        this.messageCallback = callback;\n        this.client = mqtt.connect(`${tls ? 'tls' : 'mqtt'}://${ip}:${port}`, {\n            username: username,\n            password: password,\n            clientId: this.clientId,\n            rejectUnauthorized: false,\n        });\n        this.client.on('connect', () => {\n            this.log.info(`Connection is active.`);\n            this.ready = true;\n            if (this._onConnect) {\n                this._onConnect.callback(this._onConnect.timeout);\n            }\n            void this.adapter.setState('info.connection', true, true);\n        });\n        this.client.on('disconnect', () => {\n            this.log.info(`Disconnected.`);\n            this.ready = false;\n            this.log.debug(`disconnected`);\n            if (this._onDisconnect) {\n                void this._onDisconnect.callback(this._onDisconnect.timeout);\n            }\n            void this.adapter.setState('info.connection', false, true);\n        });\n        this.client.on('error', err => {\n            this.ready = false;\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n            this.log.error(`${String(err)}`);\n        });\n\n        this.client.on('close', () => {\n            this.ready = false;\n            this.log.info(`Connection is closed.`);\n            if (this._onDisconnect) {\n                void this._onDisconnect.callback(this._onDisconnect.timeout);\n            }\n            void this.adapter.setState('info.connection', false, true);\n        });\n\n        this.client.on('message', (topic, message) => {\n            const _helper = async (topic: string, message: Buffer): Promise<void> => {\n                const callbacks = this.subscriptDB.filter(i => {\n                    return topic.startsWith(i.topic.replace('/#', ''));\n                });\n                if (this.adapter.config.debugLogMqtt) {\n                    this.log.debug(\n                        `Incoming message for ${callbacks.length} subproceses. topic: ${topic} message: ${message.toString()}`,\n                    );\n                }\n                const remove = [];\n                for (const c of callbacks) {\n                    if (await c.callback(topic, message.toString())) {\n                        remove.push(c);\n                    }\n                }\n                if (remove.length > 0) {\n                    remove.forEach(a => this.unsubscribe(a.topic));\n                }\n            };\n            void _helper(topic, message);\n        });\n    }\n    async waitConnectAsync(timeout: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this._onConnect = {\n                timeout: this.adapter.setTimeout(() => {\n                    reject(new Error(`Timeout for main mqttclient after ${timeout}ms`));\n                }, timeout),\n                callback: (timeout: ioBroker.Timeout | undefined) => {\n                    if (timeout) {\n                        this.adapter.clearTimeout(timeout);\n                    }\n                    this._onConnect = undefined;\n                    resolve();\n                },\n            };\n        });\n    }\n    async waitPanelConnectAsync(_topic: string, timeout: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const topic = `${_topic}/tele/INFO1`;\n            this.log.debug(`wait for panel connect: ${topic}`);\n            let ref: ioBroker.Timeout | undefined = undefined;\n            if (timeout > 0) {\n                ref = this.adapter.setTimeout(() => {\n                    reject(new Error(`Timeout for main mqttclient after ${timeout}ms`));\n                }, timeout);\n            }\n\n            void this.subscript(topic, async (_topic, _message) => {\n                if (ref) {\n                    this.adapter.clearTimeout(ref);\n                }\n                this.log.debug(`done connect: ${topic}`);\n                resolve();\n                return true;\n            });\n        });\n    }\n    async publish(topic: string, message: string, opt?: IClientPublishOptions): Promise<void> {\n        try {\n            if (!this.client.connected) {\n                if (this.adapter.config.debugLogMqtt) {\n                    this.log.debug(`Not connected. Can't publish topic: ${topic} with message: ${message}.`);\n                }\n                return;\n            }\n            if (this.adapter.config.debugLogMqtt) {\n                this.log.debug(`Publish topic: ${topic} with message: ${message}.`);\n            }\n            await this.client.publishAsync(topic, message, opt);\n        } catch (e) {\n            this.log.error(`Error in publish: ${e as string}`);\n        }\n    }\n\n    unsubscribe(topic: string): void {\n        const index = this.subscriptDB.findIndex(m => m.topic === topic);\n        if (index !== -1) {\n            this.subscriptDB.splice(index, 1);\n            this.log.debug(`unsubscribe from: ${topic}`);\n            this.client.unsubscribe(topic);\n        }\n    }\n\n    async subscript(topic: string, callback: callbackMessageType): Promise<void> {\n        if (this.subscriptDB.findIndex(m => m.topic === topic && m.callback === callback) !== -1) {\n            return;\n        }\n        const aNewOne = this.subscriptDB.findIndex(m => m.topic === topic) === -1;\n        this.subscriptDB.push({ topic, callback });\n        if (aNewOne) {\n            this.log.debug(`subscripe to: ${topic}`);\n\n            await this.client.subscribeAsync(topic, { qos: 1 });\n        }\n    }\n    async destroy(): Promise<void> {\n        await this.delete();\n        const endMqttClient = (): Promise<void> => {\n            return new Promise(resolve => {\n                this.client.end(false, () => {\n                    resolve();\n                });\n            });\n        };\n        await endMqttClient();\n    }\n}\n\nexport class MQTTServerClass extends BaseClass {\n    aedes: Aedes;\n    server: Server;\n    controller: Controller | undefined;\n    intervals: (ioBroker.Interval | undefined)[] = [];\n    callbacks: { [key: string]: { callback: () => void; timeout: ioBroker.Timeout | undefined } } = {};\n    ready: boolean = false;\n    test: Promise<void> | undefined = undefined;\n\n    static async createMQTTServer(\n        adapter: AdapterClassDefinition,\n        port: number,\n        username: string,\n        password: string,\n        path: string,\n    ): Promise<MQTTServerClass> {\n        let keys: Record<string, string> = {};\n\n        if (\n            !(await adapter.fileExistsAsync(adapter.namespace, 'keys/private-key.pem')) ||\n            !(await adapter.fileExistsAsync(adapter.namespace, 'keys/public-key.pem')) ||\n            !(await adapter.fileExistsAsync(adapter.namespace, 'keys/certificate.pem'))\n        ) {\n            adapter.log.info(`Create new keys for MQTT server.`);\n            const prekeys = forge.pki.rsa.generateKeyPair(4096);\n            keys.privateKey = forge.pki.privateKeyToPem(prekeys.privateKey);\n            keys.publicKey = forge.pki.publicKeyToPem(prekeys.publicKey);\n\n            // Zertifikat erstellen\n            const cert = forge.pki.createCertificate();\n            cert.publicKey = prekeys.publicKey;\n            cert.serialNumber = '01'; // Eine eindeutige Seriennummer als HEX\n            cert.validity.notBefore = new Date();\n            cert.validity.notAfter = new Date();\n            cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1); // 1 Jahr g\u00FCltig\n\n            // Zertifikats-Infos (X.509 Subject & Issuer)\n            const attrs = [\n                { name: 'commonName', value: 'localhost' },\n                { name: 'countryName', value: 'DE' },\n                { name: 'organizationName', value: 'Meine Firma' },\n            ];\n            cert.setSubject(attrs);\n            cert.setIssuer(attrs);\n\n            // Selbstsignieren mit SHA-256\n            cert.sign(prekeys.privateKey, forge.md.sha256.create());\n\n            // PEM-Format exportieren\n            keys.certPem = forge.pki.certificateToPem(cert);\n\n            // In Dateien speichern\n\n            // Schl\u00FCssel in Dateien speichern\n            await adapter.writeFileAsync(adapter.namespace, 'keys/private-key.pem', keys.privateKey);\n            await adapter.writeFileAsync(adapter.namespace, 'keys/public-key.pem', keys.publicKey);\n            await adapter.writeFileAsync(adapter.namespace, 'keys/certificate.pem', keys.certPem);\n        } else {\n            keys = {\n                publicKey: (await adapter.readFileAsync(adapter.namespace, 'keys/public-key.pem')).file.toString(),\n                privateKey: (await adapter.readFileAsync(adapter.namespace, 'keys/private-key.pem')).file.toString(),\n                certPem: (await adapter.readFileAsync(adapter.namespace, 'keys/certificate.pem')).file.toString(),\n            };\n        }\n        return new MQTTServerClass(adapter, port, username, password, path, keys);\n    }\n\n    constructor(\n        adapter: AdapterClassDefinition,\n        port: number,\n        username: string,\n        password: string,\n        path: string,\n        keyPair: Record<string, string>,\n    ) {\n        super(adapter, 'mqttServer');\n        const persistence = aedesPersistencelevel(new Level(path));\n\n        this.aedes = new Aedes({ persistence: persistence });\n        this.server = factory.createServer(this.aedes, {\n            tls: {\n                key: Buffer.from(keyPair.privateKey),\n                cert: Buffer.from(keyPair.certPem),\n            },\n        });\n        //this.server = createServer(this.aedes.handle);\n\n        this.server.listen(port, () => {\n            this.ready = true;\n            this.log.info(`Started and listening on port ${port}`);\n        });\n        this.aedes.authenticate = (\n            client: Client,\n            un: Readonly<string | undefined>,\n            pw: Readonly<Buffer | undefined>,\n            callback: any,\n        ) => {\n            const confirm = username === un && password == pw?.toString();\n            if (!confirm) {\n                this.log.warn(`Login denied client: ${client.id}. User name or password wrong! ${pw?.toString()}`);\n            } else {\n                this.log.debug(`Client ${client.id} login successful.`);\n            }\n            callback(null, confirm);\n        };\n        this.aedes.on('client', (client: Client) => {\n            for (const key in this.callbacks) {\n                if (this.callbacks[key]) {\n                    if (client.id.startsWith(key)) {\n                        if (this.adapter.config.debugLogMqtt) {\n                            this.log.debug(`Client ${client.id} connected. Call callback.`);\n                        }\n                        if (this.callbacks[key].timeout) {\n                            this.adapter.clearTimeout(this.callbacks[key].timeout);\n                            this.callbacks[key].timeout = undefined;\n                        }\n                        this.callbacks[key].callback();\n                        delete this.callbacks[key];\n                    }\n                }\n            }\n            const interval: ioBroker.Interval | undefined = this.adapter.setInterval(\n                index => {\n                    if (this.controller) {\n                        const result = this.controller.mqttClientConnected(client.id);\n                        if (result) {\n                            this.log.debug(`Client ${client.id} connected.`);\n                        }\n                        if (result || result === undefined) {\n                            this.adapter.clearInterval(this.intervals[index]);\n                            this.intervals[index] = undefined;\n\n                            // clear outdated intervals from top to bottom. Break if one is not undefined\n                            for (let a = this.intervals.length - 1; a >= 0; a--) {\n                                if (this.intervals[a] === undefined) {\n                                    this.intervals.splice(a, 1);\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                },\n                1000,\n                this.intervals.length,\n            );\n            this.intervals.push(interval);\n        });\n    }\n\n    destroy(): void {\n        void this.delete();\n        for (let a = this.intervals.length - 1; a >= 0; a--) {\n            if (this.intervals[a] !== undefined) {\n                this.adapter.clearInterval(this.intervals[a]);\n            }\n        }\n        this.intervals = [];\n        this.aedes.close();\n        this.server.close();\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAiD;AACjD,mBAAsB;AAGtB,qCAAkC;AAClC,cAAyB;AACzB,qBAAuD;AAEvD,mBAAmC;AAEnC,yBAA2B;AAC3B,YAAuB;AAOhB,MAAM,wBAAwB,yBAAU;AAAA,EAC3C;AAAA,EACA,OAAY,CAAC;AAAA,EACb,QAAiB;AAAA,EACV;AAAA,EACP;AAAA,EACQ,cAAkE,CAAC;AAAA,EAC3E;AAAA,EACA;AAAA,EAKA,YACI,SACA,IACA,MACA,UACA,UACA,KACA,UACF;AACE,UAAM,SAAS,YAAY;AAC3B,SAAK,WAAW,gBAAY,+BAAW,CAAC;AACxC,SAAK,kBAAkB;AACvB,SAAK,SAAS,YAAAA,QAAK,QAAQ,GAAG,MAAM,QAAQ,MAAM,MAAM,EAAE,IAAI,IAAI,IAAI;AAAA,MAClE;AAAA,MACA;AAAA,MACA,UAAU,KAAK;AAAA,MACf,oBAAoB;AAAA,IACxB,CAAC;AACD,SAAK,OAAO,GAAG,WAAW,MAAM;AAC5B,WAAK,IAAI,KAAK,uBAAuB;AACrC,WAAK,QAAQ;AACb,UAAI,KAAK,YAAY;AACjB,aAAK,WAAW,SAAS,KAAK,WAAW,OAAO;AAAA,MACpD;AACA,WAAK,KAAK,QAAQ,SAAS,mBAAmB,MAAM,IAAI;AAAA,IAC5D,CAAC;AACD,SAAK,OAAO,GAAG,cAAc,MAAM;AAC/B,WAAK,IAAI,KAAK,eAAe;AAC7B,WAAK,QAAQ;AACb,WAAK,IAAI,MAAM,cAAc;AAC7B,UAAI,KAAK,eAAe;AACpB,aAAK,KAAK,cAAc,SAAS,KAAK,cAAc,OAAO;AAAA,MAC/D;AACA,WAAK,KAAK,QAAQ,SAAS,mBAAmB,OAAO,IAAI;AAAA,IAC7D,CAAC;AACD,SAAK,OAAO,GAAG,SAAS,SAAO;AAC3B,WAAK,QAAQ;AAEb,WAAK,IAAI,MAAM,GAAG,OAAO,GAAG,CAAC,EAAE;AAAA,IACnC,CAAC;AAED,SAAK,OAAO,GAAG,SAAS,MAAM;AAC1B,WAAK,QAAQ;AACb,WAAK,IAAI,KAAK,uBAAuB;AACrC,UAAI,KAAK,eAAe;AACpB,aAAK,KAAK,cAAc,SAAS,KAAK,cAAc,OAAO;AAAA,MAC/D;AACA,WAAK,KAAK,QAAQ,SAAS,mBAAmB,OAAO,IAAI;AAAA,IAC7D,CAAC;AAED,SAAK,OAAO,GAAG,WAAW,CAAC,OAAO,YAAY;AAC1C,YAAM,UAAU,OAAOC,QAAeC,aAAmC;AACrE,cAAM,YAAY,KAAK,YAAY,OAAO,OAAK;AAC3C,iBAAOD,OAAM,WAAW,EAAE,MAAM,QAAQ,MAAM,EAAE,CAAC;AAAA,QACrD,CAAC;AACD,YAAI,KAAK,QAAQ,OAAO,cAAc;AAClC,eAAK,IAAI;AAAA,YACL,wBAAwB,UAAU,MAAM,wBAAwBA,MAAK,aAAaC,SAAQ,SAAS,CAAC;AAAA,UACxG;AAAA,QACJ;AACA,cAAM,SAAS,CAAC;AAChB,mBAAW,KAAK,WAAW;AACvB,cAAI,MAAM,EAAE,SAASD,QAAOC,SAAQ,SAAS,CAAC,GAAG;AAC7C,mBAAO,KAAK,CAAC;AAAA,UACjB;AAAA,QACJ;AACA,YAAI,OAAO,SAAS,GAAG;AACnB,iBAAO,QAAQ,OAAK,KAAK,YAAY,EAAE,KAAK,CAAC;AAAA,QACjD;AAAA,MACJ;AACA,WAAK,QAAQ,OAAO,OAAO;AAAA,IAC/B,CAAC;AAAA,EACL;AAAA,EACA,MAAM,iBAAiB,SAAgC;AACnD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,WAAK,aAAa;AAAA,QACd,SAAS,KAAK,QAAQ,WAAW,MAAM;AACnC,iBAAO,IAAI,MAAM,qCAAqC,OAAO,IAAI,CAAC;AAAA,QACtE,GAAG,OAAO;AAAA,QACV,UAAU,CAACC,aAA0C;AACjD,cAAIA,UAAS;AACT,iBAAK,QAAQ,aAAaA,QAAO;AAAA,UACrC;AACA,eAAK,aAAa;AAClB,kBAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,MAAM,sBAAsB,QAAgB,SAAgC;AACxE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,YAAM,QAAQ,GAAG,MAAM;AACvB,WAAK,IAAI,MAAM,2BAA2B,KAAK,EAAE;AACjD,UAAI,MAAoC;AACxC,UAAI,UAAU,GAAG;AACb,cAAM,KAAK,QAAQ,WAAW,MAAM;AAChC,iBAAO,IAAI,MAAM,qCAAqC,OAAO,IAAI,CAAC;AAAA,QACtE,GAAG,OAAO;AAAA,MACd;AAEA,WAAK,KAAK,UAAU,OAAO,OAAOC,SAAQ,aAAa;AACnD,YAAI,KAAK;AACL,eAAK,QAAQ,aAAa,GAAG;AAAA,QACjC;AACA,aAAK,IAAI,MAAM,iBAAiB,KAAK,EAAE;AACvC,gBAAQ;AACR,eAAO;AAAA,MACX,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AAAA,EACA,MAAM,QAAQ,OAAe,SAAiB,KAA4C;AACtF,QAAI;AACA,UAAI,CAAC,KAAK,OAAO,WAAW;AACxB,YAAI,KAAK,QAAQ,OAAO,cAAc;AAClC,eAAK,IAAI,MAAM,uCAAuC,KAAK,kBAAkB,OAAO,GAAG;AAAA,QAC3F;AACA;AAAA,MACJ;AACA,UAAI,KAAK,QAAQ,OAAO,cAAc;AAClC,aAAK,IAAI,MAAM,kBAAkB,KAAK,kBAAkB,OAAO,GAAG;AAAA,MACtE;AACA,YAAM,KAAK,OAAO,aAAa,OAAO,SAAS,GAAG;AAAA,IACtD,SAAS,GAAG;AACR,WAAK,IAAI,MAAM,qBAAqB,CAAW,EAAE;AAAA,IACrD;AAAA,EACJ;AAAA,EAEA,YAAY,OAAqB;AAC7B,UAAM,QAAQ,KAAK,YAAY,UAAU,OAAK,EAAE,UAAU,KAAK;AAC/D,QAAI,UAAU,IAAI;AACd,WAAK,YAAY,OAAO,OAAO,CAAC;AAChC,WAAK,IAAI,MAAM,qBAAqB,KAAK,EAAE;AAC3C,WAAK,OAAO,YAAY,KAAK;AAAA,IACjC;AAAA,EACJ;AAAA,EAEA,MAAM,UAAU,OAAe,UAA8C;AACzE,QAAI,KAAK,YAAY,UAAU,OAAK,EAAE,UAAU,SAAS,EAAE,aAAa,QAAQ,MAAM,IAAI;AACtF;AAAA,IACJ;AACA,UAAM,UAAU,KAAK,YAAY,UAAU,OAAK,EAAE,UAAU,KAAK,MAAM;AACvE,SAAK,YAAY,KAAK,EAAE,OAAO,SAAS,CAAC;AACzC,QAAI,SAAS;AACT,WAAK,IAAI,MAAM,iBAAiB,KAAK,EAAE;AAEvC,YAAM,KAAK,OAAO,eAAe,OAAO,EAAE,KAAK,EAAE,CAAC;AAAA,IACtD;AAAA,EACJ;AAAA,EACA,MAAM,UAAyB;AAC3B,UAAM,KAAK,OAAO;AAClB,UAAM,gBAAgB,MAAqB;AACvC,aAAO,IAAI,QAAQ,aAAW;AAC1B,aAAK,OAAO,IAAI,OAAO,MAAM;AACzB,kBAAQ;AAAA,QACZ,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,UAAM,cAAc;AAAA,EACxB;AACJ;AAEO,MAAM,wBAAwB,yBAAU;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAA+C,CAAC;AAAA,EAChD,YAAgG,CAAC;AAAA,EACjG,QAAiB;AAAA,EACjB,OAAkC;AAAA,EAElC,aAAa,iBACT,SACA,MACA,UACA,UACA,MACwB;AACxB,QAAI,OAA+B,CAAC;AAEpC,QACI,CAAE,MAAM,QAAQ,gBAAgB,QAAQ,WAAW,sBAAsB,KACzE,CAAE,MAAM,QAAQ,gBAAgB,QAAQ,WAAW,qBAAqB,KACxE,CAAE,MAAM,QAAQ,gBAAgB,QAAQ,WAAW,sBAAsB,GAC3E;AACE,cAAQ,IAAI,KAAK,kCAAkC;AACnD,YAAM,UAAU,MAAM,IAAI,IAAI,gBAAgB,IAAI;AAClD,WAAK,aAAa,MAAM,IAAI,gBAAgB,QAAQ,UAAU;AAC9D,WAAK,YAAY,MAAM,IAAI,eAAe,QAAQ,SAAS;AAG3D,YAAM,OAAO,MAAM,IAAI,kBAAkB;AACzC,WAAK,YAAY,QAAQ;AACzB,WAAK,eAAe;AACpB,WAAK,SAAS,YAAY,oBAAI,KAAK;AACnC,WAAK,SAAS,WAAW,oBAAI,KAAK;AAClC,WAAK,SAAS,SAAS,YAAY,KAAK,SAAS,UAAU,YAAY,IAAI,CAAC;AAG5E,YAAM,QAAQ;AAAA,QACV,EAAE,MAAM,cAAc,OAAO,YAAY;AAAA,QACzC,EAAE,MAAM,eAAe,OAAO,KAAK;AAAA,QACnC,EAAE,MAAM,oBAAoB,OAAO,cAAc;AAAA,MACrD;AACA,WAAK,WAAW,KAAK;AACrB,WAAK,UAAU,KAAK;AAGpB,WAAK,KAAK,QAAQ,YAAY,MAAM,GAAG,OAAO,OAAO,CAAC;AAGtD,WAAK,UAAU,MAAM,IAAI,iBAAiB,IAAI;AAK9C,YAAM,QAAQ,eAAe,QAAQ,WAAW,wBAAwB,KAAK,UAAU;AACvF,YAAM,QAAQ,eAAe,QAAQ,WAAW,uBAAuB,KAAK,SAAS;AACrF,YAAM,QAAQ,eAAe,QAAQ,WAAW,wBAAwB,KAAK,OAAO;AAAA,IACxF,OAAO;AACH,aAAO;AAAA,QACH,YAAY,MAAM,QAAQ,cAAc,QAAQ,WAAW,qBAAqB,GAAG,KAAK,SAAS;AAAA,QACjG,aAAa,MAAM,QAAQ,cAAc,QAAQ,WAAW,sBAAsB,GAAG,KAAK,SAAS;AAAA,QACnG,UAAU,MAAM,QAAQ,cAAc,QAAQ,WAAW,sBAAsB,GAAG,KAAK,SAAS;AAAA,MACpG;AAAA,IACJ;AACA,WAAO,IAAI,gBAAgB,SAAS,MAAM,UAAU,UAAU,MAAM,IAAI;AAAA,EAC5E;AAAA,EAEA,YACI,SACA,MACA,UACA,UACA,MACA,SACF;AACE,UAAM,SAAS,YAAY;AAC3B,UAAM,kBAAc,+BAAAC,SAAsB,IAAI,mBAAM,IAAI,CAAC;AAEzD,SAAK,QAAQ,IAAI,aAAAC,QAAM,EAAE,YAAyB,CAAC;AACnD,SAAK,SAAS,QAAQ,aAAa,KAAK,OAAO;AAAA,MAC3C,KAAK;AAAA,QACD,KAAK,OAAO,KAAK,QAAQ,UAAU;AAAA,QACnC,MAAM,OAAO,KAAK,QAAQ,OAAO;AAAA,MACrC;AAAA,IACJ,CAAC;AAGD,SAAK,OAAO,OAAO,MAAM,MAAM;AAC3B,WAAK,QAAQ;AACb,WAAK,IAAI,KAAK,iCAAiC,IAAI,EAAE;AAAA,IACzD,CAAC;AACD,SAAK,MAAM,eAAe,CACtB,QACA,IACA,IACA,aACC;AACD,YAAM,UAAU,aAAa,MAAM,aAAY,yBAAI;AACnD,UAAI,CAAC,SAAS;AACV,aAAK,IAAI,KAAK,wBAAwB,OAAO,EAAE,kCAAkC,yBAAI,UAAU,EAAE;AAAA,MACrG,OAAO;AACH,aAAK,IAAI,MAAM,UAAU,OAAO,EAAE,oBAAoB;AAAA,MAC1D;AACA,eAAS,MAAM,OAAO;AAAA,IAC1B;AACA,SAAK,MAAM,GAAG,UAAU,CAAC,WAAmB;AACxC,iBAAW,OAAO,KAAK,WAAW;AAC9B,YAAI,KAAK,UAAU,GAAG,GAAG;AACrB,cAAI,OAAO,GAAG,WAAW,GAAG,GAAG;AAC3B,gBAAI,KAAK,QAAQ,OAAO,cAAc;AAClC,mBAAK,IAAI,MAAM,UAAU,OAAO,EAAE,4BAA4B;AAAA,YAClE;AACA,gBAAI,KAAK,UAAU,GAAG,EAAE,SAAS;AAC7B,mBAAK,QAAQ,aAAa,KAAK,UAAU,GAAG,EAAE,OAAO;AACrD,mBAAK,UAAU,GAAG,EAAE,UAAU;AAAA,YAClC;AACA,iBAAK,UAAU,GAAG,EAAE,SAAS;AAC7B,mBAAO,KAAK,UAAU,GAAG;AAAA,UAC7B;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,WAA0C,KAAK,QAAQ;AAAA,QACzD,WAAS;AACL,cAAI,KAAK,YAAY;AACjB,kBAAM,SAAS,KAAK,WAAW,oBAAoB,OAAO,EAAE;AAC5D,gBAAI,QAAQ;AACR,mBAAK,IAAI,MAAM,UAAU,OAAO,EAAE,aAAa;AAAA,YACnD;AACA,gBAAI,UAAU,WAAW,QAAW;AAChC,mBAAK,QAAQ,cAAc,KAAK,UAAU,KAAK,CAAC;AAChD,mBAAK,UAAU,KAAK,IAAI;AAGxB,uBAAS,IAAI,KAAK,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,oBAAI,KAAK,UAAU,CAAC,MAAM,QAAW;AACjC,uBAAK,UAAU,OAAO,GAAG,CAAC;AAAA,gBAC9B,OAAO;AACH;AAAA,gBACJ;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,QACA;AAAA,QACA,KAAK,UAAU;AAAA,MACnB;AACA,WAAK,UAAU,KAAK,QAAQ;AAAA,IAChC,CAAC;AAAA,EACL;AAAA,EAEA,UAAgB;AACZ,SAAK,KAAK,OAAO;AACjB,aAAS,IAAI,KAAK,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,UAAI,KAAK,UAAU,CAAC,MAAM,QAAW;AACjC,aAAK,QAAQ,cAAc,KAAK,UAAU,CAAC,CAAC;AAAA,MAChD;AAAA,IACJ;AACA,SAAK,YAAY,CAAC;AAClB,SAAK,MAAM,MAAM;AACjB,SAAK,OAAO,MAAM;AAAA,EACtB;AACJ;",
  "names": ["mqtt", "topic", "message", "timeout", "_topic", "aedesPersistencelevel", "Aedes"]
}
