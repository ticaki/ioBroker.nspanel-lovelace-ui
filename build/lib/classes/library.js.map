{
  "version": 3,
  "sources": ["../../../src/lib/classes/library.ts"],
  "sourcesContent": ["import _fs from 'fs';\nimport { genericStateObjects } from '../const/definition';\n\nimport * as LocalTranslations from '../../../templates/translations.json';\nimport type { NspanelLovelaceUi } from '../types/NspanelLovelaceUi';\n// only change this for other adapters\nexport type AdapterClassDefinition = NspanelLovelaceUi;\n\nexport type LibraryStateVal = LibraryStateValJson | undefined;\ntype LibraryStateValJson = {\n    type: ioBroker.ObjectType;\n    stateTyp: string | undefined;\n    val: ioBroker.StateValue | undefined;\n    ts: number;\n    ack: boolean;\n    obj: ioBroker.Object | undefined;\n    init: boolean;\n};\n\n// Generic library module and base classes, do not insert specific adapter code here.\n\n/**\n * Base class with this.log function.\n */\nexport class BaseClass {\n    unload: boolean = false;\n    log: CustomLog;\n    adapter: AdapterClassDefinition;\n    library: Library;\n    name: string = ``;\n    friendlyName: string = ``;\n\n    constructor(adapter: AdapterClassDefinition, name: string = '', logName: string = '') {\n        this.name = name;\n        this.friendlyName = logName ? logName : this.name;\n        this.log = new CustomLog(adapter, this.friendlyName);\n        this.adapter = adapter;\n        this.library = adapter.library;\n    }\n    async delete(): Promise<void> {\n        this.unload = true;\n    }\n}\n\nclass CustomLog {\n    #adapter: AdapterClassDefinition;\n    #prefix: string;\n    constructor(adapter: AdapterClassDefinition, text: string = '') {\n        this.#adapter = adapter;\n        this.#prefix = text;\n    }\n    getName(): string {\n        return this.#prefix;\n    }\n    debug(log: string, log2: string = ''): void {\n        this.#adapter.log.debug(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    info(log: string, log2: string = ''): void {\n        this.#adapter.log.info(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    warn(log: string, log2: string = ''): void {\n        this.#adapter.log.warn(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n    }\n    error(log: string, log2: string = ''): void {\n        this.#adapter.log.error(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] ${log}`);\n        if (this.#adapter.config.testCase) {\n            throw new Error(log2 ? `[${log}] ${log2}` : `[${this.#prefix}] No Erros while testing - ${log}`);\n        }\n    }\n    setLogPrefix(text: string): void {\n        this.#prefix = text;\n    }\n}\n\nexport class Library extends BaseClass {\n    private stateDataBase: { [key: string]: LibraryStateVal } = {};\n    private forbiddenDirs: string[] = [];\n    private translation: { [key: string]: string } = {};\n    private unknownTokens: Record<string, string> = {};\n    private unknownTokensInterval: ioBroker.Interval | undefined;\n    defaults = {\n        updateStateOnChangeOnly: true,\n    };\n\n    constructor(adapter: AdapterClassDefinition, _options: any = null) {\n        super(adapter, 'library');\n        this.stateDataBase = {};\n    }\n\n    async init(): Promise<void> {\n        await this.checkLanguage();\n        if (this.adapter.config.logUnknownTokens) {\n            this.unknownTokensInterval = this.adapter.setInterval(() => {\n                this.log.info(`Unknown tokens: ${JSON.stringify(this.unknownTokens)}`);\n            }, 60_000);\n        }\n    }\n\n    /**\n    /**\n     * Write/create states and channels from a JSON subtree using a definition.\n     *\n     * Parallelization:\n     * - Parent channel is created first (sequential).\n     * - Children (array items or object keys) are processed in parallel with a concurrency limit.\n     *\n     * @param prefix       ioBroker datapoint prefix to write into (e.g., \"adapter.0.foo\")\n     * @param objNode      JSON-path into the definition (used by getObjectDefFromJson)\n     * @param def          Definition JSON (mapping of nodes to Channel/State object definitions)\n     * @param data         Source JSON subtree to materialize under `prefix`\n     * @param expandTree   If true, arrays below a state are expanded into channels instead of being stringified\n     * @param concurrency  Max number of parallel child writes (default: 8)\n     * @returns Promise<void>\n     */\n    async writeFromJson(\n        prefix: string,\n        objNode: string,\n        def: any, // keep as-is if your defs are large/complex; can be tightened later\n        data: unknown,\n        expandTree: boolean = false,\n        concurrency: number = 8,\n    ): Promise<void> {\n        // Type guards\n        if (!def || typeof def !== 'object') {\n            return;\n        }\n        const t = typeof data;\n        if (data === undefined || (t !== 'string' && t !== 'number' && t !== 'boolean' && t !== 'object')) {\n            return;\n        }\n\n        // Resolve object definition for the current node\n        const objectDefinition = objNode ? await this.getObjectDefFromJson(`${objNode}`, def, data as any) : null;\n\n        if (objectDefinition) {\n            objectDefinition.native = {\n                ...(objectDefinition.native || {}),\n                objectDefinitionReference: objNode,\n            };\n        }\n\n        // Simple concurrency limiter (no dependency)\n        const queue: Array<() => Promise<void>> = [];\n        let active = 0;\n        const runLimited = async <T>(task: () => Promise<T>): Promise<T> => {\n            if (active >= concurrency) {\n                await new Promise<void>(resolve => queue.push(async () => resolve()));\n            }\n            active++;\n            try {\n                return await task();\n            } finally {\n                active--;\n                const next = queue.shift();\n                if (next) {\n                    next().catch(() => void 0);\n                }\n            }\n        };\n\n        // Helper to process an array element (index -> channel + recurse)\n        const processArrayItem = (idx: number, item: unknown): Promise<void> =>\n            runLimited(async () => {\n                if (!objectDefinition) {\n                    return;\n                }\n                const defChannel = this.getChannelObject(objectDefinition);\n                const dp = `${prefix}${`00${idx}`.slice(-2)}`; // e.g. foo.00, foo.01\n                await this.writedp(dp, null, defChannel); // create folder\n                await this.writeFromJson(dp, `${objNode}`, def, item, expandTree, concurrency);\n            });\n\n        // Helper to process an object key (key -> recurse)\n        const processObjectKey = (key: string, value: unknown): Promise<void> =>\n            runLimited(async () => {\n                await this.writeFromJson(`${prefix}.${key}`, `${objNode}.${key}`, def, value, expandTree, concurrency);\n            });\n\n        // Branch: objects/arrays\n        if (typeof data === 'object' && data !== null) {\n            // Arrays\n            if (Array.isArray(data)) {\n                if (!objectDefinition) {\n                    return;\n                }\n\n                // When definition says \"state\" and we don't expand: stringify once\n                if (objectDefinition.type === 'state' && !expandTree) {\n                    const serialized = JSON.stringify(data) || '[]';\n                    await this.writeFromJson(prefix, objNode, def, serialized, expandTree, concurrency);\n                    return;\n                }\n\n                // Else: expand array to child channels, process items in parallel (limited)\n                const tasks = data.map((item, idx) => processArrayItem(idx, item));\n                await Promise.all(tasks);\n                return;\n            }\n\n            // Plain object\n            // Ensure parent folder exists if we have a definition\n            if (objectDefinition) {\n                const defChannel = this.getChannelObject(objectDefinition);\n                await this.writedp(prefix, null, defChannel);\n            }\n\n            // Null \u2192 nothing to do\n            if (data === null) {\n                return;\n            }\n\n            // Process keys in parallel (limited)\n            const entries = Object.entries(data as Record<string, unknown>);\n            const tasks = entries.map(([k, v]) => processObjectKey(k, v));\n            await Promise.all(tasks);\n            return;\n        }\n\n        // Primitives (string/number/boolean) \u2014 must be a state\n        if (!objectDefinition) {\n            return;\n        }\n        await this.writedp(prefix, data as ioBroker.StateValue, objectDefinition);\n    }\n\n    /**\n     * Get the ioBroker.Object out of stateDefinition\n     *\n     * @param key is the deep linking key to the definition\n     * @param def is the definition object\n     * @param data  is the definition dataset\n     * @returns ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.StateObject\n     */\n    async getObjectDefFromJson(\n        key: string,\n        def: any,\n        data: any,\n    ): Promise<ioBroker.StateObject | ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.FolderObject | null> {\n        //let result = await jsonata(`${key}`).evaluate(data);\n        let result = this.deepJsonValue(key, def);\n        if (result === null || result === undefined) {\n            const k = key.split('.');\n            if (k && k[k.length - 1].startsWith('_')) {\n                result = genericStateObjects.customString;\n                result = this.cloneObject(result);\n            } else {\n                this.log.debug(`No definition for ${key}!`);\n                result = genericStateObjects.default;\n                result = this.cloneObject(result);\n                switch (typeof data) {\n                    case 'number':\n                    case 'bigint':\n                        {\n                            result.common.type = 'number';\n                            result.common.role = 'value';\n                        }\n                        break;\n                    case 'boolean':\n                        {\n                            result.common.type = 'boolean';\n                            result.common.role = 'indicator';\n                        }\n                        break;\n                    case 'string':\n                        {\n                            result.common.type = 'string';\n                            result.common.role = 'text';\n                        }\n                        break;\n                    case 'symbol':\n                    case 'undefined':\n                    case 'object':\n                    case 'function':\n                        {\n                            result.common.type = 'string';\n                            result.common.role = 'json';\n                        }\n                        break;\n                }\n            }\n        } else {\n            result = this.cloneObject(result);\n        }\n        return result;\n    }\n\n    deepJsonValue(key: string, data: any): any {\n        if (!key || !data || typeof data !== 'object' || typeof key !== 'string') {\n            throw new Error(`Error(222) data or key are missing/wrong type!`);\n        }\n        const k = key.split(`.`);\n        let c = 0,\n            s = data;\n        while (c < k.length) {\n            s = s[k[c++]];\n            if (s === undefined) {\n                return null;\n            }\n        }\n        return s;\n    }\n\n    /**\n     * Get a channel/device definition from property _channel out of a getObjectDefFromJson() result or a default definition.\n     *\n     * @param definition the definition object\n     * @returns ioBroker.ChannelObject | ioBroker.DeviceObject or a default channel obj\n     */\n    getChannelObject(\n        definition: (ioBroker.Object & { _channel?: ioBroker.Object }) | null = null,\n    ): ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.FolderObject {\n        const def = (definition && definition._channel) || null;\n        const result: ioBroker.ChannelObject | ioBroker.DeviceObject | ioBroker.FolderObject = {\n            _id: def ? def._id : '',\n            type: def ? (def.type == 'channel' ? 'channel' : def.type === 'device' ? 'device' : 'folder') : 'folder',\n            common: {\n                name: (def && def.common && def.common.name) || 'no definition',\n            },\n            native: (def && def.native) || {},\n        };\n        return result;\n    }\n\n    /**\n     * Write/create the specified datapoint with a value.\n     *\n     * Behavior:\n     * - Creates/extends the ioBroker object when it does not exist in the in-memory DB.\n     * - Channels/Devices are created/updated but never written as states.\n     * - For states, writes only when:\n     *   - `val !== undefined` and\n     *   - (`defaults.updateStateOnChangeOnly` is true) OR (old value differs) OR (`forceWrite` is true) OR (`!node.ack`)\n     * - Values are converted to the target ioBroker common.type (if available).\n     * - Skips write operations for disallowed directories (as per `isDirAllowed`).\n     *\n     * @param dp         Datapoint id (will be normalized via `cleandp`).\n     * @param val        New value (channels/devices use `undefined` and will not be written).\n     * @param obj        Object definition for creation/extension (Channel/Device/State); required if the node is new.\n     * @param ack        Acknowledged flag for state write.\n     * @param forceWrite Force write even if `val` equals old value.\n     * @returns Promise<void>\n     * @throws Error if a new state must be created but `obj` is missing.\n     */\n    async writedp(\n        dp: string,\n        val: ioBroker.StateValue | undefined,\n        obj:\n            | ioBroker.ChannelObject\n            | ioBroker.DeviceObject\n            | ioBroker.FolderObject\n            | ioBroker.StateObject\n            | null = null,\n        ack: boolean = true,\n        forceWrite: boolean = false,\n    ): Promise<void> {\n        // Normalize id and check DB\n        dp = this.cleandp(dp);\n        let node = this.readdb(dp);\n        const disallowed = !this.isDirAllowed(dp);\n\n        // Create/extend object if not known yet\n        if (node === undefined) {\n            if (!obj) {\n                throw new Error('writedp: trying to create a state without object information.');\n            }\n\n            // Ensure full _id (adapter namespace)\n            obj._id = `${this.adapter.name}.${this.adapter.instance}.${dp}`;\n\n            // Translate name if string\n            if (typeof obj.common.name === 'string') {\n                obj.common.name = await this.getTranslationObj(obj.common.name);\n            }\n\n            // Persist object unless path is disallowed\n            if (!disallowed) {\n                // Preserve/merge `states` explicitly if provided\n                if (obj.type === 'state' && obj.common.states) {\n                    const existing = await this.adapter.getObjectAsync(dp);\n                    if (existing) {\n                        existing.common.states = obj.common.states;\n                        await this.adapter.setObject(dp, existing);\n                    }\n                }\n                await this.adapter.extendObject(dp, obj);\n            }\n\n            const stateType = obj.type !== 'state' ? undefined : obj?.common?.type;\n            node = this.setdb(dp, obj.type, undefined, stateType, true, Date.now(), obj);\n        } else if (node.init && obj) {\n            // Object already known in DB but marked as init \u2192 extend/update once\n            if (typeof obj.common.name === 'string') {\n                obj.common.name = await this.getTranslationObj(obj.common.name);\n            }\n\n            if (!disallowed) {\n                if (obj.type === 'state' && obj.common.states) {\n                    const existing = await this.adapter.getObjectAsync(dp);\n                    if (existing) {\n                        existing.common.states = obj.common.states;\n                        await this.adapter.setObject(dp, existing);\n                    }\n                }\n                await this.adapter.extendObject(dp, obj);\n                node.init = false;\n            }\n        }\n\n        // If the object exists and is NOT a state \u2192 nothing to write\n        if (obj && obj.type !== 'state') {\n            return;\n        }\n\n        // Update in-memory DB value unless it is a state with undefined value\n        if (node && !(node.type === 'state' && val === undefined)) {\n            this.setdb(dp, node.type, val, node.stateTyp, false, undefined, undefined, node.init);\n        }\n\n        // Decide whether to write the state value\n        if (\n            node &&\n            val !== undefined &&\n            (this.defaults.updateStateOnChangeOnly || node.val != val || forceWrite || !node.ack)\n        ) {\n            // Convert to target type if necessary\n            const targetType = obj?.common?.type ?? node.stateTyp;\n            if (targetType && typeof val !== targetType) {\n                val = this.convertToType(val, targetType as 'string' | 'number' | 'boolean' | 'array' | 'json');\n            }\n\n            if (!disallowed) {\n                await this.adapter.setState(dp, {\n                    val: val,\n                    ts: Date.now(),\n                    ack,\n                });\n            }\n        }\n    }\n\n    setForbiddenDirs(dirs: any[]): void {\n        this.forbiddenDirs = this.forbiddenDirs.concat(dirs);\n    }\n\n    isDirAllowed(dp: string): boolean {\n        if (dp && dp.split('.').length <= 2) {\n            return true;\n        }\n        for (const a of this.forbiddenDirs) {\n            if (dp.search(new RegExp(a, 'g')) != -1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    getStates(str: string): { [key: string]: LibraryStateVal } {\n        const result: { [key: string]: LibraryStateVal } = {};\n        for (const dp in this.stateDataBase) {\n            if (dp.search(new RegExp(str, 'g')) != -1) {\n                result[dp] = this.stateDataBase[dp];\n            }\n        }\n        return result;\n    }\n\n    async cleanUpTree(hold: string[], filter: string[] | null, deep: number): Promise<void> {\n        let del = [];\n        for (const dp in this.stateDataBase) {\n            if (filter && filter.filter(a => dp.startsWith(a) || a.startsWith(dp)).length == 0) {\n                continue;\n            }\n            if (hold.filter(a => dp.startsWith(a) || a.startsWith(dp)).length > 0) {\n                continue;\n            }\n            delete this.stateDataBase[dp];\n            del.push(dp.split('.').slice(0, deep).join('.'));\n        }\n        del = del.filter((item, pos, arr) => {\n            return arr.indexOf(item) == pos;\n        });\n        for (const a of del) {\n            await this.adapter.delObjectAsync(a, { recursive: true });\n            this.log.debug(`Clean up tree delete: ${a}`);\n        }\n    }\n\n    /**\n     * Remove forbidden chars from datapoint string.\n     *\n     * @param string Datapoint string to clean\n     * @param lowerCase lowerCase() first param.\n     * @param removePoints remove . from dp\n     * @returns void\n     */\n    cleandp(string: string, lowerCase: boolean = false, removePoints: boolean = false): string {\n        if (!string && typeof string != 'string') {\n            return string;\n        }\n\n        string = string.replace(this.adapter.FORBIDDEN_CHARS, '_');\n        // hardliner\n        if (removePoints) {\n            string = string.replace(/[^0-9A-Za-z_-]/gu, '_');\n        } else {\n            string = string.replace(/[^0-9A-Za-z._-]/gu, '_');\n        }\n        return lowerCase ? string.toLowerCase() : string;\n    }\n\n    /**\n     * Convert an arbitrary value to the requested target type and return an ioBroker.StateValue.\n     *\n     * Rules:\n     * - 'string': primitives -> String(value); arrays/objects -> JSON string.\n     * - 'number': numbers stay; booleans -> 1/0; strings parsed with comma support (\"1,23\" -> 1.23); NaN -> 0.\n     * - 'boolean': booleans stay; numbers -> value !== 0; strings -> common truthy/falsey keywords; otherwise Boolean(value).\n     * - 'array' | 'json': always JSON string of the input.\n     *\n     * @param value Input value to convert (may be primitive, array, or object)\n     * @param type  Target type: 'string' | 'number' | 'boolean' | 'array' | 'json'\n     * @returns Converted value as ioBroker.StateValue (string | number | boolean | null)\n     * @throws Error if `type` is 'undefined'\n     */\n    convertToType(\n        value: ioBroker.StateValue | unknown[] | Record<string, unknown> | null,\n        type: 'string' | 'number' | 'boolean' | 'array' | 'json' | 'undefined' | 'object' | 'mixed',\n    ): ioBroker.StateValue {\n        if (value === null) {\n            return null;\n        }\n        if (type === 'undefined') {\n            throw new Error('convertToType: type \"undefined\" not allowed');\n        }\n        if (value === undefined) {\n            value = '';\n        }\n        if (type === 'mixed') {\n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n                return value as ioBroker.StateValue;\n            }\n            type = Array.isArray(value) ? 'array' : 'json';\n        }\n        if (type === 'object') {\n            type = 'json';\n        }\n\n        // Helper: stringify objects/arrays safely\n        const toJsonString = (v: unknown): string => JSON.stringify(v);\n\n        switch (type) {\n            case 'string': {\n                if (typeof value === 'string') {\n                    return value;\n                }\n                if (typeof value === 'object') {\n                    return toJsonString(value);\n                }\n                return String(value);\n            }\n\n            case 'number': {\n                if (typeof value === 'number' && Number.isFinite(value)) {\n                    return value;\n                }\n                if (typeof value === 'boolean') {\n                    return value ? 1 : 0;\n                }\n                if (typeof value === 'string') {\n                    const n = Number(value.trim().replace(',', '.'));\n                    return Number.isFinite(n) ? n : 0;\n                }\n                // objects/arrays \u2192 cannot parse meaningfully \u2192 0\n                return 0;\n            }\n\n            case 'boolean': {\n                if (typeof value === 'boolean') {\n                    return value;\n                }\n                if (typeof value === 'number') {\n                    return value !== 0;\n                }\n                if (typeof value === 'string') {\n                    const s = value.trim().toLowerCase();\n                    if (['true', '1', 'on', 'yes', 'y'].includes(s)) {\n                        return true;\n                    }\n                    if (['false', '0', 'off', 'no', 'n', ''].includes(s)) {\n                        return false;\n                    }\n                    return Boolean(s);\n                }\n                // objects/arrays \u2192 truthiness\n                return Boolean(value);\n            }\n            case 'array':\n            case 'json': {\n                // Always return JSON string for array/json targets\n                return toJsonString(value);\n            }\n        }\n    }\n\n    readdb(dp: string): LibraryStateVal {\n        return this.stateDataBase[this.cleandp(dp)];\n    }\n\n    setdb(\n        dp: string,\n        type: ioBroker.ObjectType | LibraryStateVal,\n        val: ioBroker.StateValue | undefined = undefined,\n        stateType: string | undefined = undefined,\n        ack: boolean = true,\n        ts: number = Date.now(),\n        obj: ioBroker.Object | undefined = undefined,\n        init: boolean = false,\n    ): LibraryStateVal {\n        if (typeof type == 'object') {\n            type = type as LibraryStateVal;\n            this.stateDataBase[dp] = type;\n        } else {\n            type = type as ioBroker.ObjectType;\n            this.stateDataBase[dp] = {\n                type: type,\n                stateTyp:\n                    stateType !== undefined\n                        ? stateType\n                        : this.stateDataBase[dp] !== undefined && this.stateDataBase[dp].stateTyp !== undefined\n                          ? this.stateDataBase[dp].stateTyp\n                          : undefined,\n                val: val,\n                ack: ack,\n                ts: ts ? ts : Date.now(),\n                obj:\n                    obj !== undefined\n                        ? obj\n                        : this.stateDataBase[dp] !== undefined && this.stateDataBase[dp].obj !== undefined\n                          ? this.stateDataBase[dp].obj\n                          : undefined,\n                init: init,\n            };\n        }\n        return this.stateDataBase[dp];\n    }\n\n    async memberDeleteAsync(data: any[]): Promise<void> {\n        if (this.unknownTokensInterval) {\n            this.adapter.clearInterval(this.unknownTokensInterval);\n        }\n        for (const d of data) {\n            await d.delete();\n        }\n    }\n\n    cloneObject(obj: ioBroker.Object): ioBroker.Object {\n        if (typeof obj !== 'object') {\n            this.log.error(`Error clone object target is type: ${typeof obj}`);\n            return obj;\n        }\n        return JSON.parse(JSON.stringify(obj));\n    }\n\n    cloneGenericObject(obj: object): object {\n        if (typeof obj !== 'object') {\n            this.log.error(`Error clone object target is type: ${typeof obj}`);\n            return obj;\n        }\n        return JSON.parse(JSON.stringify(obj));\n    }\n\n    async fileExistAsync(file: string): Promise<boolean> {\n        if (_fs.existsSync(`./admin/${file}`)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Initialise the database with the states to prevent unnecessary creation and writing.\n     *\n     * @param states States that are to be read into the database during initialisation.\n     * @returns void\n     */\n    async initStates(states: { [key: string]: { val: ioBroker.StateValue; ts: number; ack: boolean } }): Promise<void> {\n        if (!states) {\n            return;\n        }\n        this.stateDataBase = {};\n        const removedChannels: string[] = [];\n        for (const state in states) {\n            const dp = state.replace(`${this.adapter.name}.${this.adapter.instance}.`, '');\n            const del = !this.isDirAllowed(dp);\n            if (!del) {\n                const obj = await this.adapter.getObjectAsync(dp);\n                this.setdb(\n                    dp,\n                    'state',\n                    states[state] ? states[state].val : undefined,\n                    obj && obj.common && obj.common.type ? obj.common.type : undefined,\n                    states[state] && states[state].ack,\n                    states[state] && states[state].ts ? states[state].ts : Date.now(),\n                    obj == null ? undefined : obj,\n                    true,\n                );\n            } else {\n                if (!removedChannels.every(a => !dp.startsWith(a))) {\n                    continue;\n                }\n                const channel = dp.split('.').slice(0, 4).join('.');\n                removedChannels.push(channel);\n                await this.adapter.delObjectAsync(channel, { recursive: true });\n                this.log.debug(`Delete channel with dp:${channel}`);\n            }\n        }\n    }\n\n    /**\n     * Resets states that have not been updated in the database in offset time.\n     *\n     * @param prefix String with which states begin that are reset.\n     * @param offset Time in ms since last update.\n     * @param del Delete the state if it is not updated.\n     * @returns void\n     */\n    async garbageColleting(prefix: string, offset: number = 2000, del = false): Promise<void> {\n        if (!prefix) {\n            return;\n        }\n        if (this.stateDataBase) {\n            for (const id in this.stateDataBase) {\n                if (id.startsWith(prefix)) {\n                    const state = this.stateDataBase[id];\n                    if (!state || state.val == undefined) {\n                        continue;\n                    }\n                    if (state.ts < Date.now() - offset) {\n                        if (del) {\n                            await this.cleanUpTree([], [id], -1);\n                            continue;\n                        }\n                        let newVal: -1 | '' | '{}' | '[]' | false | null | undefined;\n                        switch (state.stateTyp) {\n                            case 'string':\n                                if (typeof state.val == 'string') {\n                                    if (state.val.startsWith('{') && state.val.endsWith('}')) {\n                                        newVal = '{}';\n                                    } else if (state.val.startsWith('[') && state.val.endsWith(']')) {\n                                        newVal = '[]';\n                                    } else {\n                                        newVal = '';\n                                    }\n                                } else {\n                                    newVal = '';\n                                }\n                                break;\n                            case 'bigint':\n                            case 'number':\n                                newVal = -1;\n                                break;\n\n                            case 'boolean':\n                                newVal = false;\n                                break;\n                            case 'symbol':\n                            case 'object':\n                            case 'function':\n                                newVal = null;\n                                break;\n                            case 'undefined':\n                                newVal = undefined;\n                                break;\n                        }\n                        await this.writedp(id, newVal);\n                    }\n                }\n            }\n        }\n    }\n\n    getLocalLanguage(): ioBroker.Languages {\n        if (this.adapter.language) {\n            return this.adapter.language;\n        }\n        return 'en';\n    }\n    getTranslation(key: string | null | undefined): string {\n        if (!key) {\n            return '';\n        }\n        if (this.translation[key] !== undefined) {\n            return this.translation[key];\n        }\n        if (this.adapter.config.logUnknownTokens) {\n            this.unknownTokens[key] = '';\n        }\n        return key;\n    }\n    existTranslation(key: string): boolean {\n        return this.translation[key] !== undefined;\n    }\n\n    async getTranslationObj(key: string): Promise<ioBroker.StringOrTranslated> {\n        const language: ioBroker.Languages[] = ['en', 'de', 'ru', 'pt', 'nl', 'fr', 'it', 'es', 'pl', 'uk', 'zh-cn'];\n        const result: Partial<Record<ioBroker.Languages, string>> = {};\n        for (const l of language) {\n            try {\n                const i = await import(`../../../admin/i18n/${l}/translations.json`);\n                if (i[key] !== undefined) {\n                    result[l] = i[key];\n                }\n            } catch {\n                if (this.adapter.config.logUnknownTokens) {\n                    this.unknownTokens[key] = '';\n                }\n                return key;\n            }\n        }\n        if (result.en == undefined) {\n            if (this.adapter.config.logUnknownTokens) {\n                this.unknownTokens[key] = '';\n            }\n            return key;\n        }\n        return result as ioBroker.StringOrTranslated;\n    }\n\n    async checkLanguage(): Promise<void> {\n        try {\n            this.log.debug(`Load language ${this.adapter.language}`);\n            this.translation = await import(`../../../admin/i18n/${this.adapter.language}/translations.json`);\n        } catch {\n            this.log.warn(`Language ${this.adapter.language} not exist!`);\n        }\n    }\n    sortText(text: string[]): string[] {\n        text.sort((a, b) => {\n            const nameA = a.toUpperCase(); // ignore upper and lowercase\n            const nameB = b.toUpperCase(); // ignore upper and lowercase\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n\n            return 0;\n        });\n        return text;\n    }\n    /**\n     *\n     * @param text string to replace a Date\n     * @param noti appendix to translation key\n     * @param day true = Mo, 12.05 - false = 12.05\n     * @returns Monday first March\n     */\n    convertSpeakDate(text: string, noti: string = '', day = false): string {\n        if (!text || typeof text !== `string`) {\n            return ``;\n        }\n        const b = text.split(`.`);\n        if (day) {\n            b[0] = b[0].split(' ')[2];\n        }\n        return ` ${`${new Date(`${b[1]}/${b[0]}/${new Date().getFullYear()}`).toLocaleString(this.getLocalLanguage(), {\n            weekday: day ? 'long' : undefined,\n            day: 'numeric',\n            month: `long`,\n        })} `.replace(/([0-9]+\\.)/gu, x => {\n            const result = this.getTranslation(x + noti);\n            if (result != x + noti) {\n                return result;\n            }\n            return this.getTranslation(x);\n        })}`;\n    }\n\n    getLocalTranslation(group: keyof typeof LocalTranslations, key: string): string {\n        try {\n            if (group in LocalTranslations) {\n                const result = LocalTranslations[group];\n                if (key in result) {\n                    return result[key as keyof typeof result]['de-DE'];\n                }\n            }\n        } catch {\n            // do nothing\n            return key;\n        }\n        return key;\n    }\n}\n"],
  "mappings": "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",
  "names": ["tasks", "_fs"]
}
