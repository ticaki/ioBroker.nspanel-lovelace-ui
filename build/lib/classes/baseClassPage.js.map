{
  "version": 3,
  "sources": ["../../../src/lib/classes/baseClassPage.ts"],
  "sourcesContent": ["import type { PageInterface } from './PageInterface';\nimport type { PageItem } from '../pages/pageItem';\nimport type { PageItemDataItemsOptions } from '../types/type-pageItem';\nimport type { Panel } from '../controller/panel';\nimport type { PanelSend } from '../controller/panel-message';\nimport type { NspanelLovelaceUi } from '../types/NspanelLovelaceUi';\nimport { BaseClass } from './library';\nimport { genericStateObjects } from '../const/definition';\nimport type { Controller } from '../controller/controller';\nimport type { IClientPublishOptions } from 'mqtt';\n\nexport interface BaseClassTriggerdInterface {\n    name: string;\n    adapter: NspanelLovelaceUi;\n    panelSend: PanelSend;\n    alwaysOn?: 'none' | 'always' | 'action' | 'ignore';\n    panel: Panel;\n    dpInit?: string | RegExp;\n}\n\n/**\n * Basisklasse f\u00FCr alles das auf Statestriggern soll - also jede card / popup\n * \u00FCbernimmt auch die Sichtbarkeitssteuerung das triggern wird pausiert wenn nicht sichtbar\n * mit async onStateTrigger(): Promise<void> {} k\u00F6nnen abgeleitete Klassen auf Triggerereignisse reagieren\n */\nexport class BaseClassTriggerd extends BaseClass {\n    private updateTimeout: ioBroker.Timeout | undefined;\n    private waitForTimeout: ioBroker.Timeout | undefined;\n    private doUpdate: boolean = true;\n    protected minUpdateInterval: number;\n    protected visibility: boolean = false;\n    protected controller: Controller;\n    readonly panelSend: PanelSend;\n    public alwaysOn: 'none' | 'always' | 'action' | 'ignore';\n    private alwaysOnState: ioBroker.Timeout | undefined;\n    private lastMessage: string = '';\n    public panel: Panel;\n    protected filterDuplicateMessages: boolean = true;\n    neverDeactivateTrigger: boolean = false;\n    sleep: boolean = true;\n    parent: BaseClassTriggerd | undefined = undefined;\n    triggerParent: boolean = false;\n    dpInit: string | RegExp = '';\n    protected enums: string | string[] = '';\n    protected device: string = '';\n    protected sendToPanel: (payload: string, ackForType: boolean, opt?: IClientPublishOptions) => void = (\n        payload: string,\n        ackForType: boolean,\n        opt?: IClientPublishOptions,\n    ) => {\n        if (this.filterDuplicateMessages && payload == this.lastMessage) {\n            return;\n        }\n        this.lastMessage = payload;\n\n        this.sendToPanelClass(payload, ackForType, opt);\n    };\n    resetLastMessage(): void {\n        this.lastMessage = '';\n    }\n    private sendToPanelClass: (payload: string, ackForType: boolean, opt?: IClientPublishOptions) => void = () => {};\n\n    constructor(card: BaseClassTriggerdInterface) {\n        super(card.adapter, card.name);\n        this.minUpdateInterval = 400;\n        if (!this.adapter.controller) {\n            throw new Error('No controller! bye bye');\n        }\n        this.controller = this.adapter.controller;\n        this.panelSend = card.panelSend;\n        this.alwaysOn = card.alwaysOn ?? 'none';\n        this.panel = card.panel;\n\n        if (typeof this.panelSend.addMessage === 'function') {\n            this.sendToPanelClass = card.panelSend.addMessage;\n        }\n    }\n\n    async reset(): Promise<void> {}\n\n    readonly onStateTriggerSuperDoNotOverride = async (dp: string, from: BaseClassTriggerd): Promise<boolean> => {\n        if ((!this.visibility && !(this.neverDeactivateTrigger || from.neverDeactivateTrigger)) || this.unload) {\n            return false;\n        }\n        if (this.sleep && !this.neverDeactivateTrigger) {\n            return false;\n        }\n        if (this.waitForTimeout) {\n            return false;\n        }\n        if (this.updateTimeout) {\n            this.doUpdate = true;\n            return false;\n        }\n        if (this.unload) {\n            return false;\n        }\n        this.waitForTimeout = this.adapter.setTimeout(async () => {\n            this.waitForTimeout = undefined;\n            await this.onStateTrigger(dp, from);\n            if (this.alwaysOnState) {\n                this.adapter.clearTimeout(this.alwaysOnState);\n            }\n            if (this.alwaysOn === 'action') {\n                if (this.unload) {\n                    return;\n                }\n                this.alwaysOnState = this.adapter.setTimeout(\n                    () => {\n                        this.panel.sendScreeensaverTimeout(this.panel.timeout);\n                    },\n                    this.panel.timeout * 1000 || 5000,\n                );\n            }\n        }, 20);\n        this.updateTimeout = this.adapter.setTimeout(async () => {\n            if (this.unload) {\n                return;\n            }\n            this.updateTimeout = undefined;\n            if (this.doUpdate) {\n                this.doUpdate = false;\n                await this.onStateTrigger(dp, from);\n            }\n        }, this.minUpdateInterval);\n        return true;\n    };\n    protected async onStateTrigger(_dp: string, _from: BaseClassTriggerd): Promise<void> {\n        this.adapter.log.warn(\n            `<- instance of [${Object.getPrototypeOf(this)}] is triggert but dont react or call super.onStateTrigger()`,\n        );\n    }\n\n    private stopTriggerTimeout(): void {\n        if (this.updateTimeout) {\n            this.adapter.clearTimeout(this.updateTimeout);\n            this.updateTimeout = undefined;\n        }\n    }\n    async delete(): Promise<void> {\n        await this.setVisibility(false);\n        this.parent = undefined;\n        await super.delete();\n        if (this.waitForTimeout) {\n            this.adapter.clearTimeout(this.waitForTimeout);\n        }\n        if (this.alwaysOnState) {\n            this.adapter.clearTimeout(this.alwaysOnState);\n        }\n        this.stopTriggerTimeout();\n    }\n    getVisibility = (): boolean => {\n        return this.visibility;\n    };\n    setVisibility = async (v: boolean): Promise<void> => {\n        if (v !== this.visibility) {\n            this.visibility = v;\n            if (this.visibility) {\n                if (this.unload) {\n                    return;\n                }\n                /*if (this.alwaysOn != 'ignore') {\n                    if (this.alwaysOn != 'none') {\n                        if (this.alwaysOn === 'action') {\n                            if (this.unload) {\n                                return;\n                            }\n                            this.alwaysOnState = this.adapter.setTimeout(\n                                async () => {\n                                    this.panel.sendScreeensaverTimeout(this.panel.timeout);\n                                },\n                                this.panel.timeout * 2 * 1000 || 5000,\n                            );\n                        } else {\n                            this.panel.sendScreeensaverTimeout(0);\n                        }\n                    } else {\n                        this.panel.sendScreeensaverTimeout(this.panel.timeout);\n                    }\n                }*/\n\n                this.log.debug(`Switch page to visible!`);\n                this.resetLastMessage();\n                this.controller && (await this.controller.statesControler.activateTrigger(this));\n\n                this.panel.info.nspanel.currentPage = this.name;\n                await this.library.writedp(\n                    `panels.${this.panel.name}.info.nspanel.currentPage`,\n                    this.name,\n                    genericStateObjects.panel.panels.info.nspanel.currentPage,\n                );\n            } else {\n                if (this.alwaysOnState) {\n                    this.adapter.clearTimeout(this.alwaysOnState);\n                }\n                this.log.debug(`Switch page to invisible!`);\n                if (!this.neverDeactivateTrigger) {\n                    this.stopTriggerTimeout();\n                    this.controller && (await this.controller.statesControler.deactivateTrigger(this));\n                }\n            }\n            if (this.unload) {\n                return;\n            }\n            await this.onVisibilityChange(v);\n            if (this.visibility) {\n                if (this.alwaysOn != 'ignore') {\n                    if (this.alwaysOn != 'none') {\n                        if (this.alwaysOn === 'action') {\n                            if (this.unload) {\n                                return;\n                            }\n                            this.alwaysOnState = this.adapter.setTimeout(\n                                async () => {\n                                    this.panel.sendScreeensaverTimeout(this.panel.timeout);\n                                },\n                                this.panel.timeout * 2 * 1000 || 5000,\n                            );\n                        } else {\n                            this.panel.sendScreeensaverTimeout(0);\n                        }\n                    } else {\n                        this.panel.sendScreeensaverTimeout(this.panel.timeout);\n                    }\n                }\n            }\n        } else {\n            this.visibility = v;\n            // bin mir nicht sicher ob das f\u00FCr alles passt.\n            if (this.unload) {\n                return;\n            }\n            if (this.visibility) {\n                await this.onVisibilityChange(v);\n            }\n        }\n    };\n    /**\n     * Event when visibility is on Change.\n     *\n     * @param val true/false\n     */\n    protected async onVisibilityChange(val: boolean): Promise<void> {\n        val;\n        this.adapter.log.warn(\n            `<- instance of [${this.name}] not react on onVisibilityChange(), or call super.onVisibilityChange()`,\n        );\n    }\n}\nexport class BaseClassPage extends BaseClassTriggerd {\n    pageItemConfig: (PageItemDataItemsOptions | undefined)[] | undefined;\n    pageItems: (PageItem | undefined)[] | undefined;\n    constructor(card: PageInterface, pageItemsConfig: (PageItemDataItemsOptions | undefined)[] | undefined) {\n        super(card);\n        this.pageItemConfig = pageItemsConfig;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
