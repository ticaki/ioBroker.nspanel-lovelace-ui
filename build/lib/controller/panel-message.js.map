{
  "version": 3,
  "sources": ["../../../src/lib/controller/panel-message.ts"],
  "sourcesContent": ["import type { IClientPublishOptions } from 'mqtt';\nimport { SendTopicAppendix } from '../const/definition';\nimport { BaseClass, type AdapterClassDefinition } from '../classes/library';\nimport type { MQTTClientClass, callbackMessageType } from '../classes/mqtt';\nimport type { Panel } from './panel';\n\n/**\n * \u00DCbernimmt das senden von Payloads an die mqtt Klasse - delay zwischen einzelnen Messages\n * 1 * pro Klasse Panel\n */\nexport class PanelSend extends BaseClass {\n    private messageDb: { payload: string; opt?: IClientPublishOptions }[] = [];\n    private messageDbTasmota: { topic: string; payload: string; opt?: IClientPublishOptions }[] = [];\n\n    private messageTimeout: ioBroker.Timeout | undefined;\n    private messageTimeoutTasmota: ioBroker.Timeout | true | undefined;\n    private mqttClient: MQTTClientClass;\n    private topic: string = '';\n    private losingMessageCount = 0;\n\n    _panel: Panel | undefined = undefined;\n\n    constructor(adapter: AdapterClassDefinition, config: { name: string; mqttClient: MQTTClientClass; topic: string }) {\n        super(adapter, config.name);\n        this.mqttClient = config.mqttClient;\n        this.mqttClient.subscript(`${config.topic}/stat/RESULT`, this.onMessage);\n        this.topic = config.topic + SendTopicAppendix;\n    }\n    public set panel(panel: Panel) {\n        this._panel = panel;\n    }\n\n    onMessage: callbackMessageType = async (topic: string, message: string) => {\n        if (!topic.endsWith('/stat/RESULT')) {\n            //this.log.debug(`Receive command ${topic} with ${message}`);\n            return;\n        }\n        const msg = JSON.parse(message);\n        if (msg) {\n            if (msg.CustomSend === 'Done') {\n                if (this.messageTimeout) {\n                    this.adapter.clearTimeout(this.messageTimeout);\n                }\n                this.losingMessageCount = 0;\n                const msg = this.messageDb.shift();\n                if (msg) {\n                    if (msg.payload === 'pageType~pageStartup') {\n                        this.messageDb = [];\n                    }\n                    this.log.debug(`Receive ack for ${JSON.stringify(msg)}`);\n                }\n                this.messageTimeout = this.adapter.setTimeout(this.sendMessageLoop, 2);\n            }\n        }\n    };\n    public get panel(): Panel {\n        if (!this._panel) {\n            throw new Error('Error P1: Panel undefinied!');\n        }\n        return this._panel;\n    }\n\n    readonly addMessage = (payload: string, opt?: IClientPublishOptions): void => {\n        if (\n            this.messageTimeout !== undefined &&\n            this.messageDb.length > 0 &&\n            this.messageDb.some(a => a.payload === payload && a.opt === opt)\n        ) {\n            return;\n        }\n        this.messageDb.push({ payload: payload, opt: opt });\n        if (this.messageTimeout === undefined) {\n            void this.sendMessageLoop();\n        }\n    };\n\n    private readonly sendMessageLoop = async (): Promise<void> => {\n        const msg = this.messageDb[0];\n        if (msg === undefined || this.unload) {\n            this.messageTimeout = undefined;\n            return;\n        }\n        if (this.losingMessageCount++ > 3) {\n            if (this._panel) {\n                this._panel.isOnline = false;\n            }\n        }\n        if (this._panel && !this._panel.isOnline) {\n            this.messageDb = [];\n        }\n        this.addMessageTasmota(this.topic, msg.payload, msg.opt);\n        this.messageTimeout = this.adapter.setTimeout(this.sendMessageLoop, 1000);\n    };\n\n    readonly addMessageTasmota = (topic: string, payload: string, opt?: IClientPublishOptions): void => {\n        if (\n            this.messageDbTasmota.length > 0 &&\n            this.messageDbTasmota.some(a => a.topic === topic && a.payload === payload && a.opt === opt)\n        ) {\n            return;\n        }\n        this.messageDbTasmota.push({ topic: topic, payload: payload, opt: opt });\n\n        if (this.messageTimeoutTasmota === undefined) {\n            void this.sendMessageLoopTasmota();\n        }\n    };\n    private readonly sendMessageLoopTasmota = async (): Promise<void> => {\n        const msg = this.messageDbTasmota.shift();\n        if (msg === undefined || this.unload) {\n            this.messageTimeoutTasmota = undefined;\n            return;\n        }\n        this.log.debug(`send payload: ${JSON.stringify(msg)} to panel.`);\n        this.messageTimeoutTasmota = true;\n        await this.mqttClient.publish(msg.topic, msg.payload, msg.opt);\n        this.messageTimeoutTasmota = this.adapter.setTimeout(this.sendMessageLoopTasmota, 20);\n    };\n\n    async delete(): Promise<void> {\n        await super.delete();\n        if (this.messageTimeout) {\n            this.adapter.clearTimeout(this.messageTimeout);\n        }\n        if (this.messageTimeoutTasmota && this.messageTimeoutTasmota !== true) {\n            this.adapter.clearTimeout(this.messageTimeoutTasmota);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["msg"]
}
