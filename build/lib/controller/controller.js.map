{
  "version": 3,
  "sources": ["../../../src/lib/controller/controller.ts"],
  "sourcesContent": ["import type * as MQTT from '../classes/mqtt';\nimport * as Library from '../classes/library';\nimport { StatesControler } from './states-controller';\nimport * as Panel from './panel';\nimport { genericStateObjects } from '../const/definition';\nimport { SystemNotifications } from '../classes/system-notifications';\nimport { getInternalDefaults } from '../const/tools';\nimport axios from 'axios';\nimport type { TasmotaOnlineResponse, nsPanelState, nsPanelStateVal } from '../types/types';\nimport { Color } from '../const/Color';\n\naxios.defaults.timeout = 10000;\n\n/**\n * Controller Class\n */\nexport class Controller extends Library.BaseClass {\n    mqttClient: MQTT.MQTTClientClass;\n    statesControler: StatesControler;\n    panels: Panel.Panel[] = [];\n    private minuteLoopTimeout: ioBroker.Timeout | undefined;\n    private dateUpdateTimeout: ioBroker.Timeout | undefined;\n    private dailyIntervalTimeout: ioBroker.Interval | undefined;\n    private dataCache: Record<string, { time: number; data: any }> = {};\n\n    systemNotification: SystemNotifications;\n\n    constructor(\n        adapter: Library.AdapterClassDefinition,\n        options: { mqttClient: MQTT.MQTTClientClass; name: string; panels: Partial<Panel.panelConfigPartial>[] },\n    ) {\n        super(adapter, options.name);\n        Color.setTheme(Color.currentTheme);\n        this.adapter.controller = this;\n        this.mqttClient = options.mqttClient;\n        this.statesControler = new StatesControler(this.adapter);\n        this.systemNotification = new SystemNotifications(this.adapter);\n        if (this.adapter.mqttServer) {\n            this.adapter.mqttServer.controller = this;\n        }\n        for (const panelConfig of options.panels) {\n            if (panelConfig === undefined) {\n                continue;\n            }\n            void this.addPanel(panelConfig);\n            /*const index = this.adapter.config.panels.findIndex(panel => panel.topic === panelConfig.topic);\n            if (index === -1) {\n                this.adapter.testSuccessful = false;\n                this.adapter.log.error(`Panel ${panelConfig.name} with topic ${panelConfig.topic} not found in config`);\n                continue;\n            }\n            panelConfig.name = this.adapter.config.panels[index].id;\n            panelConfig.friendlyName = this.adapter.config.panels[index].name;\n            panelConfig.controller = this;\n            this.adapter.log.info(`Create panel ${panelConfig.name} with topic ${panelConfig.topic}`);\n            const panel = new Panel.Panel(adapter, panelConfig as Panel.panelConfigPartial);\n            this.panels.push(panel);*/\n        }\n        this.log.debug(`${this.name} created`);\n    }\n\n    minuteLoop = async (): Promise<void> => {\n        const now = new Date();\n        const minute = now.getMinutes();\n\n        try {\n            // Top-of-hour: Dimmode an alle Panels\n            if (minute === 0) {\n                for (const panel of this.panels) {\n                    panel.sendDimmode();\n                }\n            }\n\n            // Jede 5. Minute bei Minute==1,6,11,...\n            if (minute % 5 === 1) {\n                for (const panel of this.panels) {\n                    panel.requestStatusTasmota();\n                }\n            }\n\n            const currentTime = await this.getCurrentTime();\n            await this.statesControler.setInternalState('///time', currentTime, true);\n        } catch {\n            // Fehler werden geschluckt, damit die Loop nicht stoppt\n        }\n\n        if (this.unload) {\n            return;\n        }\n\n        // N\u00E4chste Ausf\u00FChrung exakt zur n\u00E4chsten Minute (+10 ms Puffer)\n        const next = new Date(now);\n        next.setSeconds(0, 10);\n        next.setMinutes(now.getMinutes() + 1);\n        const diff = next.getTime() - Date.now();\n\n        this.minuteLoopTimeout = this.adapter.setTimeout(() => this.minuteLoop(), diff);\n    };\n\n    /**\n     * Update Date every day at 0:00:01....\n     *\n     * @returns void\n     */\n    dateUpdateLoop = async (): Promise<void> => {\n        // Zeitpunkt: n\u00E4chster Tag 00:00:01\n        const now = new Date();\n        const next = new Date(now);\n        next.setDate(now.getDate() + 1);\n        next.setHours(0, 0, 1, 0);\n\n        const diff = next.getTime() - now.getTime();\n\n        if (this.unload) {\n            return;\n        }\n\n        try {\n            const currentTime = await this.getCurrentTime();\n            this.log.debug(`Set current Date with time: ${new Date(currentTime).toString()}`);\n            await this.statesControler.setInternalState('///date', currentTime, true);\n        } catch (err: any) {\n            this.log.error(`dateUpdateLoop failed: ${err}`);\n        }\n\n        this.dateUpdateTimeout = this.adapter.setTimeout(() => this.dateUpdateLoop(), diff);\n    };\n    getCurrentTime = async (): Promise<number> => {\n        return new Promise(resolve => resolve(Date.now()));\n    };\n\n    /**\n     * Handles internal commands based on the provided id and state.\n     *\n     * @param id - The identifier for the internal command.\n     * @param _state - The state associated with the command.\n     * @returns The value of the internal state or null if not applicable.\n     */\n    onInternalCommand = async (id: string, _state: nsPanelState | undefined): Promise<nsPanelStateVal> => {\n        if (!id.startsWith('///')) {\n            return null;\n        }\n        const token = id.split('///').pop();\n        switch (token) {\n            case 'AdapterStoppedBoolean':\n            case 'AdapterNoConnectionBoolean':\n            case 'AdapterNoConnection':\n            case 'AdapterStopped': {\n                if (this.dataCache[token] && this.dataCache[token].time < Date.now() - 5000) {\n                    delete this.dataCache[token];\n                }\n                let save = false;\n                if (!this.dataCache[token]) {\n                    this.dataCache[token] = { time: Date.now(), data: {} };\n                    save = true;\n                }\n                let list;\n                if (save) {\n                    list = await this.adapter.getObjectViewAsync('system', 'instance', {\n                        startkey: `system.adapter`,\n                        endkey: `system.adapter}`,\n                    });\n                    this.dataCache[token].data[`system#view.instance`] = list;\n                } else {\n                    list = this.dataCache[token].data[`system#view.instance`];\n                }\n                if (!list || !list.token) {\n                    return null;\n                }\n\n                let total = 0;\n                let withProblems = 0;\n                for (const item of list.rows) {\n                    const obj = item.value;\n                    if (!obj.common.enabled || obj.common.mode !== 'daemon') {\n                        continue;\n                    }\n                    if (token === 'AdapterStopped' || token === 'AdapterStoppedBoolean') {\n                        let state;\n                        if (save) {\n                            state = await this.adapter.getForeignStateAsync(`${item.id}.alive`);\n                            this.dataCache[token].data[`${item.id}.alive`] = state;\n                        } else {\n                            state = this.dataCache[token].data[`${item.id}.alive`];\n                        }\n                        if (state && !state.val) {\n                            withProblems++;\n                            if (token === 'AdapterStoppedBoolean') {\n                                return true;\n                            }\n                        }\n                        total++;\n                    } else if (token === 'AdapterNoConnection' || token === 'AdapterNoConnectionBoolean') {\n                        const nID = item.id.split('.').slice(2).join('.');\n                        let state;\n                        if (save) {\n                            state = await this.adapter.getForeignStateAsync(`${nID}.info.connection`);\n                            this.dataCache[token].data[`${nID}.info.connection`] = state;\n                        } else {\n                            state = this.dataCache[token].data[`${nID}.info.connection`];\n                        }\n                        if (state && !state.val) {\n                            withProblems++;\n                            if (token === 'AdapterNoConnectionBoolean') {\n                                return true;\n                            }\n                        }\n                        total++;\n                    }\n                }\n                if (token === 'AdapterNoConnectionBoolean' || token === 'AdapterStoppedBoolean') {\n                    return false;\n                }\n                return `(${withProblems}/${total})`;\n            }\n        }\n        return null;\n    };\n\n    async init(): Promise<void> {\n        await this.statesControler.setInternalState(\n            '///time',\n            await this.getCurrentTime(),\n            true,\n            {\n                name: '',\n                type: 'number',\n                role: 'value.time',\n                read: true,\n                write: false,\n            },\n            this.getCurrentTime,\n        );\n        await this.statesControler.setInternalState(\n            '///date',\n            await this.getCurrentTime(),\n            true,\n            {\n                name: '',\n                type: 'number',\n                role: 'value.time',\n                read: true,\n                write: false,\n            },\n            this.getCurrentTime,\n        );\n        await this.statesControler.setInternalState(\n            `///AdapterNoConnection`,\n            '',\n            true,\n            getInternalDefaults('string', 'text', false),\n            this.onInternalCommand,\n        );\n        await this.statesControler.setInternalState(\n            `///AdapterStopped`,\n            '',\n            true,\n            getInternalDefaults('string', 'text', false),\n            this.onInternalCommand,\n        );\n        await this.statesControler.setInternalState(\n            `///AdapterNoConnectionBoolean`,\n            true,\n            true,\n            getInternalDefaults('boolean', 'indicator', false),\n            this.onInternalCommand,\n        );\n        await this.statesControler.setInternalState(\n            `///AdapterStoppedBoolean`,\n            true,\n            true,\n            getInternalDefaults('boolean', 'indicator', false),\n            this.onInternalCommand,\n        );\n        //const newPanels = [];\n        // erzeuge \u00FCbergeordneten channel\n        await this.library.writedp(`panels`, undefined, genericStateObjects.panel._channel);\n\n        void this.systemNotification.init();\n        /*this.log.debug(`Create ${this.panels.length} panels`);\n        for (const panel of this.panels) {\n            await this.adapter.delay(100);\n            if (await panel.isValid()) {\n                newPanels.push(panel);\n                void panel.init();\n            } else {\n                await panel.delete();\n                this.adapter.testSuccessful = false;\n                this.log.error(`Panel ${panel.name} has a invalid configuration.`);\n            }\n        }\n        this.panels = newPanels;*/\n        void this.minuteLoop();\n        void this.dateUpdateLoop();\n        await this.getTasmotaVersion();\n        await this.getTFTVersion();\n        this.dailyIntervalTimeout = this.adapter.setInterval(this.dailyInterval, 24 * 60 * 60 * 1000);\n    }\n\n    addPanel = async (panel: Partial<Panel.panelConfigPartial>): Promise<void> => {\n        let index = this.panels.findIndex(p => p.topic === panel.topic);\n        if (index !== -1) {\n            this.adapter.testSuccessful = false;\n            this.adapter.log.error(`Panel ${panel.name} with topic ${panel.topic} already exists`);\n            return;\n        }\n        index = this.adapter.config.panels.findIndex(p => p.topic === panel.topic);\n        if (index === -1) {\n            this.adapter.testSuccessful = false;\n            this.adapter.log.error(`Panel ${panel.name} with topic ${panel.topic} not found in config`);\n            return;\n        }\n\n        panel.name = this.adapter.config.panels[index].id;\n        panel.friendlyName = this.adapter.config.panels[index].name;\n        panel.controller = this;\n        // merge adapter navigation\n        const o = await this.adapter.getForeignObjectAsync(this.adapter.namespace);\n        if (panel?.topic && o && o.native && o.native.navigation) {\n            if (o.native.navigation[panel.topic] && o.native.navigation[panel.topic].useNavigation) {\n                panel.navigation = o.native.navigation[panel.topic].data;\n            }\n        }\n        const newPanel = new Panel.Panel(this.adapter, panel as Panel.panelConfigPartial);\n        await this.adapter.delay(100);\n        if (await newPanel.isValid()) {\n            this.panels.push(newPanel);\n            await newPanel.init();\n            this.log.debug(`Panel ${newPanel.name} created`);\n        } else {\n            await newPanel.delete();\n            this.adapter.testSuccessful = false;\n            this.log.error(`Panel ${panel.name} has a invalid configuration.`);\n        }\n    };\n\n    removePanel = async (panel: Panel.Panel): Promise<void> => {\n        const index = this.panels.findIndex(p => p.topic === panel.topic);\n        if (index !== -1) {\n            this.panels.splice(index, 1);\n            await panel.delete();\n            this.log.info(`Panel ${panel.topic} deleted`);\n        } else {\n            this.log.error(`Panel ${panel.topic} not found`);\n        }\n    };\n\n    mqttClientConnected = (id: string): boolean | undefined => {\n        if (id === this.mqttClient.clientId) {\n            return true;\n        }\n        const index = this.panels.findIndex(p => id.startsWith(this.library.cleandp(p.friendlyName)));\n        if (index !== -1) {\n            if (this.panels[index].initDone) {\n                this.panels[index].restartLoops();\n                return true;\n            }\n        }\n        return false;\n    };\n\n    async delete(): Promise<void> {\n        await super.delete();\n        if (this.minuteLoopTimeout) {\n            this.adapter.clearTimeout(this.minuteLoopTimeout);\n        }\n        if (this.dateUpdateTimeout) {\n            this.adapter.clearTimeout(this.dateUpdateTimeout);\n        }\n        if (this.dailyIntervalTimeout) {\n            this.adapter.clearInterval(this.dailyIntervalTimeout);\n        }\n        if (this.systemNotification) {\n            await this.systemNotification.delete();\n        }\n        if (this.statesControler) {\n            await this.statesControler.delete();\n        }\n        for (const a of this.panels) {\n            if (a) {\n                await a.delete();\n            }\n        }\n    }\n\n    async notificationToPanel(): Promise<void> {\n        if (!this.panels) {\n            return;\n        }\n        await this.statesControler.setInternalState('///Notifications', true, true);\n    }\n\n    dailyInterval = async (): Promise<void> => {\n        await this.getTFTVersion();\n        await this.getTasmotaVersion();\n    };\n\n    async getTFTVersion(): Promise<void> {\n        try {\n            const result = await axios.get(\n                'https://raw.githubusercontent.com/ticaki/ioBroker.nspanel-lovelace-ui/main/json/version.json',\n            );\n            if (result.status !== 200) {\n                this.log.warn(`Error getting TFT version: ${result.status}`);\n                return;\n            }\n\n            const version = this.adapter.config.useBetaTFT\n                ? result.data['tft-beta'].split('_')[0]\n                : result.data.tft.split('_')[0];\n            for (const p of this.panels) {\n                if (p) {\n                    p.info.nspanel.onlineVersion = version;\n                }\n            }\n        } catch {\n            // nothing\n        }\n    }\n    async getTasmotaVersion(): Promise<void> {\n        const urlString = 'https://api.github.com/repositories/80286288/releases/latest';\n        try {\n            const response = await axios(urlString, { headers: { 'User-Agent': 'ioBroker' } });\n\n            if (response && response.status === 200) {\n                const data = response.data as TasmotaOnlineResponse;\n\n                const TasmotaTagName = data.tag_name; // Filter JSON by \"tag_name\" and write to variable\n                const TasmotaVersionOnline = TasmotaTagName.replace(/v/i, ''); // Filter unnecessary \"v\" from variable and write to release variable\n                for (const p of this.panels) {\n                    if (p) {\n                        p.info.tasmota.onlineVersion = TasmotaVersionOnline;\n                    }\n                }\n            }\n        } catch {\n            // do nothing\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["axios"]
}
