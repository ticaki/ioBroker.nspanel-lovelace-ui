{
  "version": 3,
  "sources": ["../../../src/lib/controller/states-controller.ts"],
  "sourcesContent": ["// BaseClass extends\n\nimport { Dataitem } from './data-item';\nimport { BaseClass } from './library';\nimport type { nsPanelState, nsPanelStateVal } from '../types/types';\nimport { getRegExp } from '../const/tools';\nimport type { NspanelLovelaceUi } from '../types/NspanelLovelaceUi';\nimport type { StateRole } from '../types/pages';\nimport type { BaseTriggeredPage } from '../classes/baseClassPage';\nimport type { NSPanel } from '../types/NSPanel';\n\ntype getInternalFunctionType = (\n    id: string,\n    state: ioBroker.State | nsPanelState | undefined,\n) => Promise<nsPanelStateVal>;\n/**\n * Verwendet um Lesezugriffe auf die States umzusetzten, die im NSPanel ververwendet werden.\n * Adapter eigenen States sind verboten\n * Speichert Zugriff zwischen das kann mit timespan vereinflusst werden.\n */\nexport class StatesControler extends BaseClass {\n    private triggerDB: {\n        [key: string]: {\n            state: nsPanelState;\n            to: BaseTriggeredPage[];\n            ts: number;\n            subscribed: boolean[];\n            common: ioBroker.StateCommon;\n            internal?: boolean;\n            f?: getInternalFunctionType;\n            triggerAllowed: boolean[];\n            change: ('ne' | 'ts')[];\n        };\n    } = {};\n\n    // Performance-optimized lookup maps\n    private targetToTriggerMap = new Map<BaseTriggeredPage, Set<string>>();\n    private activeTriggerCount = new Map<string, number>();\n    /**\n     * Holds subscriptions created while the subscription system is temporarily blocked.\n     *\n     * - `undefined`: blocking is not active (normal mode, new subscriptions are applied immediately).\n     * - `string[]`: blocking is active; new subscriptions are collected here until the block is lifted.\n     */\n    private blockedSubscriptions: string[] | undefined;\n    private deletePageInterval: ioBroker.Interval | undefined;\n\n    private stateDB: { [key: string]: { state: ioBroker.State; ts: number; common: ioBroker.StateCommon } } = {};\n    objectDatabase: Record<string, ioBroker.Object | null> = {};\n    intervalObjectDatabase: ioBroker.Interval | undefined;\n\n    timespan: number;\n\n    constructor(adapter: NspanelLovelaceUi, name: string = '', timespan: number = 500) {\n        super(adapter, name || 'StatesDB');\n        this.timespan = timespan;\n        this.deletePageInterval = this.adapter.setInterval(async () => {\n            void this.deletePageLoop();\n        }, 180_000);\n        this.intervalObjectDatabase = this.adapter.setInterval(() => {\n            if (this.unload || this.adapter.unload) {\n                return;\n            }\n            this.objectDatabase = {};\n            // ADDED: Cleanup expired stateDB entries to prevent memory leaks\n            this.cleanupStateDB();\n        }, 180_000);\n    }\n    deletePageLoop = async (f?: getInternalFunctionType): Promise<void> => {\n        const removeIds: string[] = [];\n\n        // Performance-optimiert: Verwende for..in statt Object.keys()\n        for (const id in this.triggerDB) {\n            const entry = this.triggerDB[id];\n            const removeIdx: number[] = [];\n\n            if (f && entry.f === f) {\n                removeIds.push(id);\n                continue;\n            }\n\n            // Sammle zu l\u00F6schende Indizes aus entry.to\n            for (let i = 0; i < entry.to.length; i++) {\n                const it = entry.to[i];\n                if (it?.unload || it?.parent?.unload || it?.parent?.basePanel?.unload || it?.parent?.parent?.unload) {\n                    removeIdx.push(i);\n                }\n            }\n\n            if (removeIdx.length > 0) {\n                // FIXED: Sichere Array-Manipulation mit expliziten Array-Namen\n                // Absteigend sortieren, damit Splices Indizes nicht verschieben\n                removeIdx.sort((a, b) => b - a);\n\n                // F\u00FCr alle relevanten Array-Properties den gleichen Index entfernen\n                const arrayProperties = ['to', 'subscribed', 'triggerAllowed', 'change'] as const;\n                for (const idx of removeIdx) {\n                    for (const prop of arrayProperties) {\n                        const arr = entry[prop] as any[];\n                        if (arr && Array.isArray(arr) && idx >= 0 && idx < arr.length) {\n                            arr.splice(idx, 1);\n                        }\n                    }\n                }\n\n                // Update performance maps\n                for (const idx of removeIdx) {\n                    const target = entry.to[idx];\n                    if (target) {\n                        this.removeFromTargetMap(target, id);\n                    }\n                }\n            }\n\n            if (entry.to.length === 0 && !entry.internal) {\n                removeIds.push(id);\n            }\n        }\n\n        // Cleanup for removed IDs\n        this.blockedSubscriptions = [];\n        for (const id of removeIds) {\n            if (!id.startsWith(this.adapter.namespace)) {\n                if (!id.startsWith(this.adapter.namespace)) {\n                    await this.adapter.unsubscribeForeignStatesAsync(id);\n                }\n            }\n\n            delete this.triggerDB[id];\n            this.activeTriggerCount.delete(id);\n        }\n\n        while (this.blockedSubscriptions && this.blockedSubscriptions.length > 0) {\n            for (let idx = this.blockedSubscriptions.length - 1; idx >= 0; idx--) {\n                if (idx >= this.blockedSubscriptions.length) {\n                    continue;\n                }\n                const id = this.blockedSubscriptions[idx];\n                if (!id.startsWith(this.adapter.namespace)) {\n                    await this.adapter.subscribeForeignStatesAsync(id);\n                }\n                this.blockedSubscriptions.splice(idx, 1);\n            }\n        }\n        this.blockedSubscriptions = undefined;\n    };\n\n    async delete(): Promise<void> {\n        await super.delete();\n        if (StatesControler.tempObjectDBTimeout) {\n            this.adapter.clearTimeout(StatesControler.tempObjectDBTimeout);\n        }\n        if (this.intervalObjectDatabase) {\n            this.adapter.clearInterval(this.intervalObjectDatabase);\n        }\n        if (this.deletePageInterval) {\n            this.adapter.clearInterval(this.deletePageInterval);\n        }\n\n        // Cleanup performance maps\n        this.targetToTriggerMap.clear();\n        this.activeTriggerCount.clear();\n    }\n\n    // Performance optimization helper methods\n    private addToTargetMap(target: BaseTriggeredPage, triggerId: string): void {\n        if (!this.targetToTriggerMap.has(target)) {\n            this.targetToTriggerMap.set(target, new Set());\n        }\n        this.targetToTriggerMap.get(target)!.add(triggerId);\n    }\n\n    private removeFromTargetMap(target: BaseTriggeredPage, triggerId: string): void {\n        const triggers = this.targetToTriggerMap.get(target);\n        if (triggers) {\n            triggers.delete(triggerId);\n            if (triggers.size === 0) {\n                this.targetToTriggerMap.delete(target);\n            }\n        }\n    }\n\n    private incrementActiveTrigger(triggerId: string): void {\n        const current = this.activeTriggerCount.get(triggerId) || 0;\n        this.activeTriggerCount.set(triggerId, current + 1);\n    }\n\n    private decrementActiveTrigger(triggerId: string): void {\n        const current = this.activeTriggerCount.get(triggerId) || 0;\n        if (current <= 1) {\n            this.activeTriggerCount.delete(triggerId);\n        } else {\n            this.activeTriggerCount.set(triggerId, current - 1);\n        }\n    }\n\n    /**\n     * Cleanup expired entries from stateDB to prevent memory leaks\n     * OPTIMIERT: Regelm\u00E4\u00DFige Bereinigung des Cache\n     */\n    private cleanupStateDB(): void {\n        const now = Date.now();\n        const expiredIds: string[] = [];\n\n        for (const id in this.stateDB) {\n            const entry = this.stateDB[id];\n            const age = now - entry.ts;\n            // Keep entries 2x timespan\n            if (age > this.timespan * 2) {\n                expiredIds.push(id);\n            }\n        }\n\n        for (const id of expiredIds) {\n            delete this.stateDB[id];\n        }\n\n        if (expiredIds.length > 0 && this.adapter.config.debugLogStates) {\n            this.log.debug(`Cleaned up ${expiredIds.length} expired stateDB entries`);\n        }\n    }\n    /**\n     * Registriert einen Trigger auf einen *fremden* State (nicht im eigenen Namespace)\n     * und initialisiert die Trigger-Datenbank inkl. Abo & aktuellem Wert.\n     *\n     * Hinweise:\n     * - Eigene States (im Adapter-Namespace) sind hier verboten.\n     * - Bei bereits existierendem Eintrag wird der Empf\u00E4nger nur erg\u00E4nzt.\n     *\n     * @param id        Fremd-State-ID\n     * @param from      Ausl\u00F6sende/abonniert-werdende Klasse\n     * @param internal  true = interner Trigger (kein Fremd-Abo erwartet)\n     * @param trigger   ob dieser Empf\u00E4nger durch \u00C4nderungen ausgel\u00F6st werden darf\n     * @param change    optional: 'ts' \u2192 l\u00F6se auch ohne Wert-/Ack-\u00C4nderung (Zeitstempel)\n     */\n    async setTrigger(\n        id: string,\n        from: BaseTriggeredPage,\n        internal: boolean = false,\n        trigger: boolean = true,\n        change?: 'ts',\n    ): Promise<void> {\n        // 1) Eigener Namespace? \u2192 verboten\n        if (\n            id.startsWith(this.adapter.namespace) &&\n            !(id.includes('.alarm.') && (id.endsWith('.approve') || id.endsWith('.status')))\n        ) {\n            this.log.warn(`Id: ${id} refers to the adapter's own namespace, this is not allowed!`);\n            return;\n        }\n\n        const existing = this.triggerDB[id];\n\n        // 2) Bereits vorhanden \u2192 Empf\u00E4nger anh\u00E4ngen (falls nicht schon drin)\n        if (existing) {\n            // OPTIMIERT: Verwende indexOf f\u00FCr bessere Performance als findIndex\n            const idx = existing.to.indexOf(from);\n            if (idx === -1) {\n                existing.to.push(from);\n                existing.subscribed.push(false);\n                existing.triggerAllowed.push(trigger);\n                existing.change.push(change ?? 'ne');\n\n                // Update performance maps\n                this.addToTargetMap(from, id);\n\n                if (this.adapter.config.debugLogStates) {\n                    this.log.debug(`Add a trigger for ${from.name} to ${id}`);\n                }\n            }\n            return;\n        }\n\n        // 3) Neu anlegen: interner Trigger zu fr\u00FCh?\n        if (internal) {\n            this.log.error('setInternal Trigger too early');\n            return;\n        }\n\n        // 4) Platz reservieren (default-Werte), bevor wir I/O machen\n        this.triggerDB[id] = {\n            state: { val: null, ack: false, ts: 0, from: '', lc: 0 },\n            to: [from],\n            ts: Date.now(),\n            subscribed: [false],\n            common: { name: id, type: 'number', role: 'state', write: false, read: true },\n            triggerAllowed: [trigger],\n            change: [change ?? 'ne'],\n            internal: false,\n        };\n\n        try {\n            const obj = await this.getObjectAsync(id);\n            if (!obj || obj.type !== 'state' || !obj.common) {\n                delete this.triggerDB[id];\n                throw new Error(`Got invalid object for ${id}`);\n            }\n            this.triggerDB[id].common = obj.common;\n            if (this.unload || this.adapter.unload) {\n                return;\n            }\n            if (this.blockedSubscriptions) {\n                if (!this.blockedSubscriptions.includes(id)) {\n                    this.blockedSubscriptions.push(id);\n                }\n            } else {\n                if (!id.startsWith(this.adapter.namespace)) {\n                    await this.adapter.subscribeForeignStatesAsync(id);\n                }\n            }\n            if (this.adapter.config.debugLogStates) {\n                this.log.debug(`Set a new trigger for ${from.basePanel.name}.${from.name} to ${id}`);\n            }\n\n            // Add to performance maps\n            this.addToTargetMap(from, id);\n\n            // 5) Fremd-State & -Objekt holen\n            const state = await this.adapter.getForeignStateAsync(id);\n            if (state) {\n                this.triggerDB[id].state = state;\n            }\n\n            // 6) DB bef\u00FCllen, abonnieren, evtl. alten stateDB-Eintrag entfernen\n            // OPTIMIERT: Verwende has() statt !== undefined\n            if (this.stateDB[id]) {\n                delete this.stateDB[id];\n            }\n        } catch (err) {\n            // Rollback bei Fehlern\n            delete this.triggerDB[id];\n            throw err;\n        }\n    }\n\n    /**\n     * Activate the triggers of a pageItem for self or parent. First subscribes to the state.\n     * OPTIMIERT: Verwende performance maps f\u00FCr bessere Effizienz\n     *\n     * @param to Page\n     */\n    async activateTrigger(to: BaseTriggeredPage | undefined): Promise<void> {\n        if (!to) {\n            return;\n        }\n\n        // OPTIMIERT: Verwende Map f\u00FCr direkte Lookup statt Iteration \u00FCber alle IDs\n        const triggerIds = this.targetToTriggerMap.get(to);\n        if (triggerIds) {\n            for (const id of triggerIds) {\n                const entry = this.triggerDB[id];\n                if (!entry) {\n                    continue;\n                }\n\n                const index = entry.to.indexOf(to);\n                if (index === -1) {\n                    continue;\n                }\n                if (entry.subscribed[index]) {\n                    continue;\n                }\n                if (!entry.triggerAllowed[index]) {\n                    continue;\n                }\n\n                const hasActiveSubscription = entry.subscribed.some(a => a);\n                if (!hasActiveSubscription) {\n                    entry.subscribed[index] = true;\n                    this.incrementActiveTrigger(id);\n                    if (!id.startsWith(this.adapter.namespace)) {\n                        await this.adapter.subscribeForeignStatesAsync(id);\n                    }\n                    const state = await this.adapter.getForeignStateAsync(id);\n                    if (state) {\n                        entry.state = state;\n                    }\n                } else {\n                    entry.subscribed[index] = true;\n                    this.incrementActiveTrigger(id);\n                }\n            }\n        }\n\n        // Fallback: Check parent relationships (less common case)\n        for (const id in this.triggerDB) {\n            const entry = this.triggerDB[id];\n            const index = entry.to.findIndex(a => a.parent && a.parent === to);\n            if (index === -1) {\n                continue;\n            }\n            if (entry.subscribed[index]) {\n                continue;\n            }\n            if (!entry.triggerAllowed[index]) {\n                continue;\n            }\n\n            const hasActiveSubscription = entry.subscribed.some(a => a);\n            if (!hasActiveSubscription) {\n                entry.subscribed[index] = true;\n                this.incrementActiveTrigger(id);\n                if (!id.startsWith(this.adapter.namespace)) {\n                    await this.adapter.subscribeForeignStatesAsync(id);\n                }\n                const state = await this.adapter.getForeignStateAsync(id);\n                if (state) {\n                    entry.state = state;\n                }\n            } else {\n                entry.subscribed[index] = true;\n                this.incrementActiveTrigger(id);\n            }\n        }\n    }\n\n    /**\n     * Deactivate the triggers of a pageItem for self or parent page. Last unsubscribes to the state.\n     * OPTIMIERT: Verwende performance maps und effizientere Suche\n     *\n     * @param to Page\n     */\n    async deactivateTrigger(to: BaseTriggeredPage): Promise<void> {\n        if (to.neverDeactivateTrigger) {\n            return;\n        }\n\n        // OPTIMIERT: Verwende direkte Map-Lookup f\u00FCr bessere Performance\n        const triggerIds = this.targetToTriggerMap.get(to);\n        if (triggerIds) {\n            for (const id of triggerIds) {\n                const entry = this.triggerDB[id];\n                if (!entry || entry.internal) {\n                    continue;\n                }\n\n                const index = entry.to.indexOf(to);\n                if (index === -1 || !entry.subscribed[index]) {\n                    continue;\n                }\n\n                // Check if parent has another active page\n                const indexParent = entry.to.findIndex(a => a.parent && a.parent === to);\n                if (indexParent !== -1 && entry.subscribed[indexParent]) {\n                    continue; // parent has another page that is still active\n                }\n\n                entry.subscribed[index] = false;\n                this.decrementActiveTrigger(id);\n\n                if (this.adapter.config.debugLogStates) {\n                    this.log.debug(`Deactivate trigger from ${to.name} to ${id}`);\n                }\n\n                // Check if no subscriptions are left\n                const hasActiveSubscriptions = entry.subscribed.some(a => a);\n                if (!hasActiveSubscriptions) {\n                    if (this.blockedSubscriptions) {\n                        const idx = this.blockedSubscriptions.indexOf(id);\n                        if (idx !== -1) {\n                            this.blockedSubscriptions.splice(idx, 1);\n                        }\n                    }\n                    if (!id.startsWith(this.adapter.namespace)) {\n                        await this.adapter.unsubscribeForeignStatesAsync(id);\n                    }\n                }\n            }\n        }\n\n        // Handle any remaining entries not in the map (edge case)\n        for (const id in this.triggerDB) {\n            const entry = this.triggerDB[id];\n            if (entry.internal) {\n                continue;\n            }\n\n            const index = entry.to.indexOf(to);\n            if (index === -1 || !entry.subscribed[index]) {\n                continue;\n            }\n\n            // Check if already handled by map lookup\n            const triggerIdsForTarget = this.targetToTriggerMap.get(to);\n            if (triggerIdsForTarget && triggerIdsForTarget.has(id)) {\n                continue; // Already handled above\n            }\n\n            const indexParent = entry.to.findIndex(a => a.parent && a.parent === to);\n            if (indexParent !== -1 && entry.subscribed[indexParent]) {\n                continue; // parent has another page that is still active\n            }\n\n            entry.subscribed[index] = false;\n            this.decrementActiveTrigger(id);\n\n            if (this.adapter.config.debugLogStates) {\n                this.log.debug(`Deactivate trigger from ${to.name} to ${id}`);\n            }\n\n            const hasActiveSubscriptions = entry.subscribed.some(a => a);\n            if (!hasActiveSubscriptions) {\n                if (this.blockedSubscriptions) {\n                    const idx = this.blockedSubscriptions.indexOf(id);\n                    if (idx !== -1) {\n                        this.blockedSubscriptions.splice(idx, 1);\n                    }\n                }\n                if (!id.startsWith(this.adapter.namespace)) {\n                    await this.adapter.unsubscribeForeignStatesAsync(id);\n                }\n            }\n        }\n    }\n\n    async getStateVal(id: string): Promise<nsPanelState['val'] | null> {\n        try {\n            const state = await this.getState(id);\n            if (state) {\n                return state.val ?? null;\n            }\n        } catch (e: any) {\n            this.log.error(`Error 1004: ${typeof e === 'string' ? e.replaceAll('Error: ', '') : e}`);\n        }\n        return null;\n    }\n    /**\n     * Read a state from DB or js-controller\n     * OPTIMIERT: Verbesserte Cache-Strategie und Performance\n     *\n     * @param id state id with namespace\n     * @param internal if the state is internal\n     * @returns nsPanelState or null\n     */\n    async getState(id: string, internal: boolean = false): Promise<nsPanelState | null> {\n        // 1) TriggerDB has priority (subscribed or internal states)\n        const triggerEntry = this.triggerDB[id];\n        if (triggerEntry && (triggerEntry.internal || triggerEntry.subscribed.some(a => a))) {\n            let state: nsPanelState | null = null;\n            const f = triggerEntry.f;\n            if (f) {\n                state = {\n                    ...triggerEntry.state,\n                    val: await f(id, undefined),\n                };\n            } else {\n                state = triggerEntry.state;\n            }\n            return state;\n        }\n\n        // 2) Check stateDB cache with timespan validation\n        const cachedEntry = this.stateDB[id];\n        if (cachedEntry) {\n            const age = Date.now() - cachedEntry.ts;\n            if (age < this.timespan) {\n                return cachedEntry.state;\n            }\n            // Cache expired, remove it\n            delete this.stateDB[id];\n        }\n\n        // 3) Handle internal states (with '/')\n        if (id.includes('/')) {\n            internal = true;\n        }\n\n        if (!internal) {\n            try {\n                const state = await this.adapter.getForeignStateAsync(id);\n                if (state != null) {\n                    // Update cache only if we don't have it in stateDB\n                    if (!this.stateDB[id]) {\n                        const obj = await this.getObjectAsync(id);\n                        if (!obj || !obj.common || obj.type !== 'state') {\n                            throw new Error(`Got invalid object for ${id}`);\n                        }\n                        this.stateDB[id] = { state: state, ts: Date.now(), common: obj.common };\n                    } else {\n                        // Update existing cache\n                        this.stateDB[id].state = state;\n                        this.stateDB[id].ts = Date.now();\n                    }\n                    return state;\n                }\n                if (state === null) {\n                    return null;\n                }\n            } catch (e: any) {\n                this.log.error(`Error 1005: ${typeof e === 'string' ? e.replaceAll('Error: ', '') : e}`);\n                return null;\n            }\n        }\n        throw new Error(`State id invalid ${id} no data!`);\n    }\n\n    getType(id: string | undefined): ioBroker.CommonType | undefined {\n        if (!id) {\n            return undefined;\n        }\n        if (this.triggerDB[id] !== undefined && this.triggerDB[id].common) {\n            return this.triggerDB[id].common.type;\n        }\n        if (this.stateDB[id] !== undefined) {\n            return this.stateDB[id].common.type;\n        }\n        return undefined;\n    }\n\n    async getCommonStates(id: string | undefined, force: boolean = false): Promise<Record<string, string> | null> {\n        if (!id) {\n            return null;\n        }\n        let j: string | string[] | Record<string, string> | undefined = undefined;\n        if (force) {\n            const obj = await this.adapter.getForeignObjectAsync(id);\n            if (obj && obj.common && obj.common.states) {\n                j = obj.common.states;\n                if (this.triggerDB[id] !== undefined && this.triggerDB[id].common.states) {\n                    this.triggerDB[id].common.states = j;\n                }\n                if (this.stateDB[id] !== undefined && this.stateDB[id].common.states) {\n                    this.stateDB[id].common.states = j;\n                }\n            }\n        } else if (this.triggerDB[id] !== undefined && this.triggerDB[id].common) {\n            j = this.triggerDB[id].common.states;\n        } else if (this.stateDB[id] !== undefined && this.stateDB[id].common) {\n            j = this.stateDB[id].common.states;\n        }\n\n        if (!j || typeof j === 'string') {\n            return null;\n        }\n        if (Array.isArray(j)) {\n            const a: Record<string, string> = {};\n            j.forEach((e, i) => (a[String(i)] = e));\n            j = a;\n        }\n        return j;\n    }\n\n    isStateValue(v: unknown): v is ioBroker.StateValue {\n        return (\n            v === null || v === undefined || typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean'\n        );\n    }\n\n    /**\n     * Handle incoming state changes from ioBroker.\n     *\n     * Performance-optimized version for high-frequency calls (1000s per minute).\n     * Responsibilities:\n     *  - Update the internal triggerDB entry for the given datapoint.\n     *  - Decide whether the state change should trigger dependent classes.\n     *  - Forward primitive values to library cache and panels if required.\n     *  - Forward system.host changes to systemNotification.\n     *\n     * Notes:\n     *  - Active subscriptions (visible & neverDeactivateTrigger) are checked later, not here.\n     *  - Object values are ignored (only primitive values are cached/forwarded).\n     *\n     * @param dp     Datapoint ID (internal/external state id)\n     * @param state  New ioBroker state object or null/undefined\n     */\n    async onStateChange(dp: string, state: nsPanelState | ioBroker.State | null | undefined): Promise<void> {\n        if (!dp || !state) {\n            return;\n        }\n\n        // Cache adapter namespace for string comparisons\n        const adapterNamespace = this.adapter.namespace;\n        const debugLogEnabled = this.adapter.config.debugLogStates;\n\n        // Pre-calculate common checks to avoid repeated string operations\n        const startsWithUserdata = dp.startsWith('0_userdata.0');\n        const startsWithAlias = dp.startsWith('alias.0');\n        const startsWithNamespace = dp.startsWith(adapterNamespace);\n\n        const entry = this.triggerDB[dp];\n\n        // --- Trigger/ACK-Pfad ------------------------------------------------------\n        if (entry?.state) {\n            // Only create debug log if enabled to avoid string operations\n            if (debugLogEnabled) {\n                this.log.debug(`Trigger from ${dp} with state ${JSON.stringify(state)}`);\n            }\n\n            // Cache old values before updating (avoid object creation if not needed)\n            const oldVal = entry.state.val;\n            const oldAck = entry.state.ack;\n            const oldTs = entry.state.ts;\n            const oldFrom = entry.state.from;\n            const oldLc = entry.state.lc;\n\n            // Update triggerDB entry\n            entry.ts = Date.now();\n            entry.state = state;\n\n            const isSystemOrAlias = startsWithUserdata || startsWithAlias || (!state.ack && startsWithNamespace);\n            const mayTrigger = state.ack || entry.internal || isSystemOrAlias;\n\n            if (mayTrigger) {\n                // Cache array references to avoid repeated property access\n                const to = entry.to;\n                const toLength = to.length;\n\n                // Early exit if no targets\n                if (toLength === 0) {\n                    return;\n                }\n\n                const changes = entry.change || [];\n                const subscribed = entry.subscribed || [];\n                const allowed = entry.triggerAllowed || [];\n                const hasValChange = oldVal !== state.val;\n                const hasAckChange = oldAck !== state.ack;\n\n                // Only create oldState object if we have targets that need it\n                let oldState: nsPanelState | undefined;\n\n                for (let i = 0; i < toLength; i++) {\n                    const target = to[i];\n\n                    // Skip unloaded targets early\n                    if (target.unload) {\n                        continue;\n                    }\n\n                    // Check for changes efficiently\n                    const hasChange = hasValChange || hasAckChange || changes[i] === 'ts';\n                    if (!hasChange) {\n                        if (debugLogEnabled) {\n                            this.log.debug(`Ignore trigger from state ${dp} no change!`);\n                        }\n                        continue;\n                    }\n\n                    // Create oldState only when needed and once\n                    if (!oldState) {\n                        oldState = {\n                            val: oldVal,\n                            ack: oldAck,\n                            from: oldFrom,\n                            ts: oldTs,\n                            lc: oldLc,\n                        };\n                    }\n\n                    // Call target state change handler\n                    await target.onStateChange(dp, { old: oldState, new: state });\n\n                    // Check subscription and trigger permissions efficiently\n                    const isSubscribed = target.neverDeactivateTrigger || subscribed[i];\n                    const isAllowed = allowed[i];\n\n                    if (!isSubscribed || !isAllowed) {\n                        if (debugLogEnabled && i === toLength - 1) {\n                            this.log.debug(`Ignore trigger from state ${dp} not subscribed or not allowed!`);\n                            this.log.debug(\n                                `c: ${target.name} !c.neverDeactivateTrigger: ${!target.neverDeactivateTrigger} && ` +\n                                    `!subscribed[${i}]: ${!subscribed[i]} || !allowed[${i}]: ${!allowed[i]}`,\n                            );\n                        }\n                        continue;\n                    }\n\n                    // Handle parent/direct trigger routing\n                    const parent = target.parent;\n                    if (parent && target.triggerParent && !parent.unload && !parent.sleep) {\n                        await parent.onStateTriggerSuperDoNotOverride?.(dp, target);\n                    } else {\n                        await target.onStateTriggerSuperDoNotOverride?.(dp, target);\n                    }\n                }\n            } else if (debugLogEnabled) {\n                this.log.debug(`Ignore trigger from state ${dp} ack is false!`);\n            }\n        } else if (this.stateDB[dp]) {\n            // Fast path for stateDB updates\n            const stateEntry = this.stateDB[dp];\n            stateEntry.state = state as ioBroker.State;\n            stateEntry.ts = state.ts;\n        }\n\n        // --- Primitive-Update-Pfad (nur Nicht-Objekte) -----------------------------\n        // Early primitive check to avoid unnecessary processing\n        const v = state.val;\n        if (v !== null && v !== undefined && typeof v === 'object') {\n            return;\n        }\n\n        // Handle adapter namespace states efficiently\n        if (!state.ack && startsWithNamespace) {\n            // Cache namespace replacement to avoid repeated string operations\n            const namespacePrefix = `${adapterNamespace}.`;\n            const id = dp.slice(namespacePrefix.length); // More efficient than replace()\n            const libState = this.library.readdb(id);\n\n            if (libState) {\n                this.library.setdb(id, {\n                    ...libState,\n                    val: this.isStateValue(state.val) ? state.val : null,\n                    ts: state.ts,\n                    ack: state.ack,\n                });\n\n                // Forward to panels only if writable and controller exists\n                if (libState.obj?.common?.write && this.adapter.controller) {\n                    const panels = this.adapter.controller.panels;\n                    for (const panel of panels) {\n                        await panel.onStateChange(id, state);\n                    }\n                }\n            }\n        }\n\n        // System host notifications (less frequent, can stay as is)\n        if (dp.startsWith('system.host') && this.adapter.controller) {\n            await this.adapter.controller.systemNotification.onStateChange(dp, state as ioBroker.State);\n        }\n    }\n    async setState(item: Dataitem, val: ioBroker.StateValue, writeable: boolean): Promise<void> {\n        if (item.options.type === 'state' || item.options.type === 'triggered') {\n            if (item.options.dp) {\n                const ack = item.options.dp.startsWith(this.adapter.namespace);\n                this.log.debug(`setState(${item.options.dp}, ${val}, ${ack})`);\n                if (item.trueType() === 'number' && typeof val === 'string') {\n                    val = parseFloat(val);\n                } else if (item.trueType() === 'number' && typeof val === 'boolean') {\n                    val = val ? 1 : 0;\n                } else if (item.trueType() === 'boolean') {\n                    val = !!val;\n                }\n                if (item.trueType() === 'string') {\n                    val = String(val);\n                }\n                if (writeable) {\n                    try {\n                        await this.adapter.setForeignStateAsync(item.options.dp, val, ack);\n                    } catch (e: any) {\n                        this.log.error(\n                            `Cannot write state ${item.options.dp} with value ${val}: ${typeof e === 'string' ? e : e.message}`,\n                        );\n                        // prevent further write attempts\n                        item.writeable = false;\n                        item.common.write = false;\n                        throw e;\n                    }\n                } else {\n                    this.log.error(`Forbidden write attempts on a read-only state! id: ${item.options.dp}`);\n                }\n            }\n        } else if (item.options.type === 'internal' || item.options.type === 'internalState') {\n            if (this.triggerDB[item.options.dp]) {\n                await this.setInternalState(item.options.dp, val, false);\n            }\n        }\n    }\n\n    /**\n     * Set a internal state and trigger\n     *\n     * @param id something like 'cmd/blabla'\n     * @param val Value\n     * @param ack false use value/ true use func\n     * @param common optional for first call\n     * @param func optional for first call\n     * @returns true if set\n     */\n    public async setInternalState(\n        id: string,\n        val: nsPanelStateVal,\n        ack: boolean = false,\n        common: ioBroker.StateCommon | undefined = undefined,\n        func: getInternalFunctionType | undefined = undefined,\n    ): Promise<boolean> {\n        if (this.triggerDB[id] !== undefined) {\n            const f = this.triggerDB[id].f;\n\n            const newState = {\n                ...this.triggerDB[id].state,\n                // if ack and function take value of function otherwise val\n                val: ack && f ? ((await f(id, undefined)) ?? val) : val,\n                ack: ack,\n                ts: Date.now(),\n            };\n\n            // use this to trigger pages\n            await this.onStateChange(id, newState);\n\n            // here we trigger the state command\n            // if we change this onStateTrigger change 'ne' not work correcty\n            f && (await f(id, this.triggerDB[id].state));\n\n            return true;\n\n            // create the db entry\n        } else if (common) {\n            if (this.adapter.config.debugLogStates) {\n                this.log.debug(`Add internal state ${id} with ${JSON.stringify(common)}`);\n            }\n            this.triggerDB[id] = {\n                state: { ts: Date.now(), val: null, ack: ack, from: '', lc: Date.now() },\n                to: [],\n                ts: Date.now(),\n                subscribed: [],\n                common: common,\n                internal: true,\n                f: func,\n                triggerAllowed: [],\n                change: [],\n            };\n        }\n        return false;\n    }\n\n    /**\n     * Create dataitems from a json (deep)\n     *\n     * @param data Json with configuration to create dataitems\n     * @param parent Page etc.\n     * @param target optional target\n     * @param path optional path\n     * @param options so far only constant to use in getState().read\n     * @returns then json with values dataitem or undefined\n     */\n    async createDataItems(\n        data: any,\n        parent: any,\n        target: any = {},\n        path: string = 'data',\n        options?: Record<string, string>,\n    ): Promise<any> {\n        for (const i in data) {\n            const d = data[i];\n            if (d === undefined) {\n                continue;\n            }\n            if (typeof d === 'object' && !('type' in d)) {\n                target[i] = await this.createDataItems(\n                    d,\n                    parent,\n                    (target[i] ?? Array.isArray(d)) ? [] : {},\n                    `${path}.${i}`,\n                    options,\n                );\n            } else if (typeof d === 'object' && 'type' in d) {\n                target[i] =\n                    data[i] !== undefined\n                        ? new Dataitem(\n                              this.adapter,\n                              { ...d, name: `${this.name}.${parent.name}.${i}.${path}`, constants: options },\n                              parent,\n                              this,\n                          )\n                        : undefined;\n                if (target[i] !== undefined && !(await (target[i] as Dataitem).isValidAndInit())) {\n                    target[i] = undefined;\n                }\n            }\n        }\n        if (Object.keys(target).length === 0) {\n            return undefined;\n        }\n        return target;\n    }\n\n    /**\n     * Tempor\u00E4es Datenobject zum speichern aller Enums und Objecte\n     */\n    static TempObjectDB: {\n        data: Record<string, ioBroker.Object> | undefined;\n        keys: string[];\n        enums: Record<string, ioBroker.EnumObject> | undefined;\n    } = {\n        data: undefined,\n        keys: [],\n        enums: undefined,\n    };\n    static tempObjectDBTimeout: ioBroker.Timeout | undefined;\n    static getTempObjectDB(adapter: NspanelLovelaceUi): typeof StatesControler.TempObjectDB {\n        if (StatesControler.tempObjectDBTimeout) {\n            adapter.clearTimeout(StatesControler.tempObjectDBTimeout);\n        }\n        if (!adapter.unload) {\n            StatesControler.tempObjectDBTimeout = adapter.setTimeout(() => {\n                if (adapter.unload) {\n                    return;\n                }\n                StatesControler.tempObjectDBTimeout = undefined;\n                StatesControler.TempObjectDB = { data: undefined, keys: [], enums: undefined };\n            }, 20_000);\n        }\n        return StatesControler.TempObjectDB;\n    }\n    /**\n     * Filterfunktion umso genauer die Filter um so weniger Ressourcen werden verbraucht.\n     *\n     * @param dpInit string RegExp oder '' f\u00FCr aus; string wird mit include verwendet.\n     * @param enums string, string[], RegExp als String \u00FCbergeben oder ein String der mit include verwenden wird.\n     * @returns 2 arrays keys: gefilterte keys und data: alle Objekte...\n     */\n    async getFilteredObjects(dpInit: string | RegExp, enums?: string | string[]): Promise<typeof result> {\n        const tempObjectDB = StatesControler.getTempObjectDB(this.adapter);\n        if (!tempObjectDB.data) {\n            tempObjectDB.data = await this.adapter.getForeignObjectsAsync(`*`);\n            if (!tempObjectDB.data) {\n                throw new Error('getObjects fail. Critical Error!');\n            }\n            tempObjectDB.keys = Object.keys(tempObjectDB.data);\n            const temp = await this.adapter.getEnumsAsync(['rooms', 'functions']);\n            tempObjectDB.enums = { ...temp['enum.rooms'], ...temp['enum.functions'] };\n        }\n        const result: { data: Record<string, ioBroker.Object> | undefined; keys: string[] } = {\n            data: tempObjectDB.data,\n            keys: tempObjectDB.keys,\n        };\n        if (dpInit) {\n            if (typeof dpInit !== 'string') {\n                result.keys = tempObjectDB.keys.filter(a => a.match(dpInit) !== null);\n            } else {\n                result.keys = tempObjectDB.keys.filter(a => a.includes(dpInit));\n            }\n        }\n        if (enums && tempObjectDB.enums) {\n            if (typeof enums === 'string') {\n                enums = [enums];\n            }\n            let r: string[] | undefined;\n            for (const e of enums) {\n                const regexp = getRegExp(e);\n                let t: string[] = [];\n                for (const a in tempObjectDB.enums) {\n                    if ((!regexp && a.includes(e)) || (regexp && a.match(regexp) !== null)) {\n                        if (\n                            tempObjectDB.enums[a] &&\n                            tempObjectDB.enums[a].common &&\n                            tempObjectDB.enums[a].common.members\n                        ) {\n                            t = t.concat(tempObjectDB.enums[a].common.members);\n                        }\n                    }\n                }\n                if (!r) {\n                    r = t;\n                } else {\n                    r = r.filter(a => t.indexOf(a) !== -1);\n                }\n            }\n            result.keys = result.keys.filter(a => r && r.some(b => a.startsWith(b)));\n        }\n        return result;\n    }\n\n    /**\n     * Retrieves the ID of a state automatically based on the provided options.\n     *\n     * @param options - Configuration for the automatic state lookup.\n     * @param options.dpInit - The initial data point, either a string or a regular expression.\n     * @param options.role - The expected role of the state, either a single StateRole or an array of roles.\n     * @param options.enums - One or more enum IDs that the state should belong to.\n     * @param options.regexp - A regular expression to match the state ID.\n     * @param options.triggered - If true, the returned object will be of type \"triggered\" instead of \"state\".\n     * @param options.writeable - If true, only writeable states will be considered.\n     * @param options.commonType - The expected common type of the state, either a single type or an array of types.\n     * @returns A promise that resolves to a `DataItemsOptions` object if a matching state is found,\n     * otherwise `undefined`.\n     */\n    async getIdbyAuto(options: {\n        dpInit: string | RegExp;\n        role?: StateRole | StateRole[];\n        enums?: string | string[];\n        regexp?: RegExp;\n        triggered?: boolean;\n        writeable?: boolean;\n        commonType?: ioBroker.CommonType | ioBroker.CommonType[] | '';\n    }): Promise<NSPanel.DataItemsOptions | undefined> {\n        const { dpInit, role = '', enums = '', regexp, triggered, writeable, commonType = '' } = options;\n\n        const status = { ok: true };\n        let item: NSPanel.DataItemsOptions | undefined;\n        if (triggered) {\n            item = {\n                type: 'triggered',\n                role,\n                dp: '',\n                mode: 'auto',\n                regexp,\n                writeable,\n                commonType,\n            };\n        } else {\n            item = {\n                type: 'state',\n                role,\n                dp: '',\n                mode: 'auto',\n                regexp,\n                writeable,\n                commonType,\n            };\n        }\n        const data = await this.getDataItemsFromAuto(dpInit, { item: item }, '', enums, status, true);\n        if (status.ok && data && data.item && data.item.dp) {\n            return item;\n        }\n        return undefined;\n    }\n\n    async getDataItemsFromAuto(\n        dpInit: string | RegExp,\n        data: any,\n        appendix?: string,\n        enums: string | string[] = '',\n        status?: { ok: boolean },\n        ignoreMultiple: boolean = false,\n    ): Promise<any> {\n        if (dpInit === '' && enums === undefined) {\n            return data;\n        }\n        const tempObjectDB = await this.getFilteredObjects(dpInit, enums);\n        if (tempObjectDB.data) {\n            for (const i in data) {\n                const t = data[i];\n                if (t === undefined) {\n                    continue;\n                }\n                if (typeof t === 'object' && !('type' in t)) {\n                    data[i] = await this.getDataItemsFromAuto(dpInit, t, appendix, enums, status);\n                } else if (typeof t === 'object' && 'type' in t) {\n                    const d = t as NSPanel.DataItemsOptions;\n                    let found = false;\n                    if ((d.type !== 'triggered' && d.type !== 'state') || !d.mode || d.mode !== 'auto') {\n                        continue;\n                    }\n                    if (tempObjectDB.keys.length === 0) {\n                        this.log.warn(`Dont finds states for ${dpInit} dpinit is ${typeof dpInit}`);\n                    }\n                    for (const role of Array.isArray(d.role) ? d.role : [d.role || '']) {\n                        //throw new Error(`${d.dp} has a unkowned role ${d.role}`);\n                        for (const commonType of Array.isArray(d.commonType) ? d.commonType : [d.commonType || '']) {\n                            for (const id of tempObjectDB.keys) {\n                                const obj: ioBroker.Object = tempObjectDB.data[id];\n\n                                if (\n                                    obj &&\n                                    obj.common &&\n                                    obj.type === 'state' &&\n                                    (d.dp === '' || id.includes(d.dp)) &&\n                                    (role === '' || obj.common.role === role) &&\n                                    (!commonType || obj.common.type === commonType) &&\n                                    (!d.writeable || obj.common.write === d.writeable) &&\n                                    (!d.regexp || id.match(d.regexp) !== null)\n                                ) {\n                                    if (found) {\n                                        if (!ignoreMultiple) {\n                                            this.log.warn(\n                                                `Found more as 1 state for role ${role} in ${dpInit} with .dp: ${\n                                                    d.dp ? d.dp.toString() : 'empty'\n                                                } and .regexp: ${d.regexp ? d.regexp.toString() : 'empty'}`,\n                                            );\n                                        }\n                                        break;\n                                    }\n                                    d.dp = id;\n                                    d.mode = 'done';\n                                    found = true;\n                                }\n                            }\n                            if (found) {\n                                break;\n                            }\n                        }\n                        if (found) {\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        if (d.required) {\n                            status && (status.ok = false);\n                            this.log.warn(\n                                `No state found for role ${JSON.stringify(d.role)} in ${dpInit.toString()} with with .dp: ${\n                                    d.dp ? d.dp.toString() : 'empty'\n                                } and .regexp: ${d.regexp ? d.regexp.toString() : 'empty'}`,\n                            );\n                        }\n                        data[i] = undefined;\n                    }\n                }\n            }\n        }\n        return data;\n    }\n\n    async getObjectAsync(id: string): Promise<ioBroker.Object | null> {\n        if (this.objectDatabase[id] !== undefined) {\n            return this.objectDatabase[id];\n        } else if (this.triggerDB[id] != undefined && this.triggerDB[id].internal) {\n            return { _id: '', type: 'state', common: this.triggerDB[id].common, native: {} };\n        }\n        const obj = await this.adapter.getForeignObjectAsync(id);\n        this.objectDatabase[id] = obj ?? null;\n        return obj ?? null;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
