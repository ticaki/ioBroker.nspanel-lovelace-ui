import { RGB } from '../types/Color';
import { PageItemDataitems } from '../types/pageItem';

export const HMIOff: RGB = { red: 68, green: 115, blue: 158 }; // Blue-Off - Original Entity Off
export const HMIOn: RGB = { red: 3, green: 169, blue: 244 }; // Blue-On
export const HMIDark: RGB = { red: 29, green: 29, blue: 29 }; // Original Background Color
export const Off: RGB = { red: 253, green: 128, blue: 0 }; // Orange-Off - nicer color transitions
export const On: RGB = { red: 253, green: 216, blue: 53 };
export const MSRed: RGB = { red: 251, green: 105, blue: 98 };
export const MSYellow: RGB = { red: 255, green: 235, blue: 156 };
export const MSGreen: RGB = { red: 121, green: 222, blue: 121 };
export const Red: RGB = { red: 255, green: 0, blue: 0 };
export const White: RGB = { red: 255, green: 255, blue: 255 };
export const Yellow: RGB = { red: 255, green: 255, blue: 0 };
export const Green: RGB = { red: 0, green: 255, blue: 0 };
export const Blue: RGB = { red: 0, green: 0, blue: 255 };
export const DarkBlue: RGB = { red: 0, green: 0, blue: 136 };
export const Gray: RGB = { red: 136, green: 136, blue: 136 };
export const Black: RGB = { red: 0, green: 0, blue: 0 };
export const Cyan: RGB = { red: 0, green: 255, blue: 255 };
export const Magenta: RGB = { red: 255, green: 0, blue: 255 };
export const colorSpotify: RGB = { red: 30, green: 215, blue: 96 };
export const colorAlexa: RGB = { red: 49, green: 196, blue: 243 };
export const colorSonos: RGB = { red: 216, green: 161, blue: 88 };
export const colorRadio: RGB = { red: 255, green: 127, blue: 0 };
export const BatteryFull: RGB = { red: 96, green: 176, blue: 62 };
export const BatteryEmpty: RGB = { red: 179, green: 45, blue: 25 };

//Menu Icon Colors
export const Menu: RGB = { red: 150, green: 150, blue: 100 };
export const MenuLowInd: RGB = { red: 255, green: 235, blue: 156 };
export const MenuHighInd: RGB = { red: 251, green: 105, blue: 98 };

//Dynamische Indikatoren (Abstufung gr√ºn nach gelb nach rot)
export const colorScale0: RGB = { red: 99, green: 190, blue: 123 };
export const colorScale1: RGB = { red: 129, green: 199, blue: 126 };
export const colorScale2: RGB = { red: 161, green: 208, blue: 127 };
export const colorScale3: RGB = { red: 129, green: 217, blue: 126 };
export const colorScale4: RGB = { red: 222, green: 226, blue: 131 };
export const colorScale5: RGB = { red: 254, green: 235, blue: 132 };
export const colorScale6: RGB = { red: 255, green: 210, blue: 129 };
export const colorScale7: RGB = { red: 251, green: 185, blue: 124 };
export const colorScale8: RGB = { red: 251, green: 158, blue: 117 };
export const colorScale9: RGB = { red: 248, green: 131, blue: 111 };
export const colorScale10: RGB = { red: 248, green: 105, blue: 107 };

//Screensaver Default Theme Colors
export const scbackground: RGB = { red: 0, green: 0, blue: 0 };
export const scbackgroundInd1: RGB = { red: 255, green: 0, blue: 0 };
export const scbackgroundInd2: RGB = { red: 121, green: 222, blue: 121 };
export const scbackgroundInd3: RGB = { red: 255, green: 255, blue: 0 };
export const sctime: RGB = { red: 255, green: 255, blue: 255 };
export const sctimeAMPM: RGB = { red: 255, green: 255, blue: 255 };
export const scdate: RGB = { red: 255, green: 255, blue: 255 };
export const sctMainIcon: RGB = { red: 255, green: 255, blue: 255 };
export const sctMainText: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast1: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast2: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast3: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast4: RGB = { red: 255, green: 255, blue: 255 };
export const sctF1Icon: RGB = { red: 255, green: 235, blue: 156 };
export const sctF2Icon: RGB = { red: 255, green: 235, blue: 156 };
export const sctF3Icon: RGB = { red: 255, green: 235, blue: 156 };
export const sctF4Icon: RGB = { red: 255, green: 235, blue: 156 };
export const sctForecast1Val: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast2Val: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast3Val: RGB = { red: 255, green: 255, blue: 255 };
export const sctForecast4Val: RGB = { red: 255, green: 255, blue: 255 };
export const scbar: RGB = { red: 255, green: 255, blue: 255 };
export const sctMainIconAlt: RGB = { red: 255, green: 255, blue: 255 };
export const sctMainTextAlt: RGB = { red: 255, green: 255, blue: 255 };
export const sctTimeAdd: RGB = { red: 255, green: 255, blue: 255 };

//Auto-Weather-Colors
export const swClearNight: RGB = { red: 150, green: 150, blue: 100 };
export const swCloudy: RGB = { red: 75, green: 75, blue: 75 };
export const swExceptional: RGB = { red: 255, green: 50, blue: 50 };
export const swFog: RGB = { red: 150, green: 150, blue: 150 };
export const swHail: RGB = { red: 200, green: 200, blue: 200 };
export const swLightning: RGB = { red: 200, green: 200, blue: 0 };
export const swLightningRainy: RGB = { red: 200, green: 200, blue: 150 };
export const swPartlycloudy: RGB = { red: 150, green: 150, blue: 150 };
export const swPouring: RGB = { red: 50, green: 50, blue: 255 };
export const swRainy: RGB = { red: 100, green: 100, blue: 255 };
export const swSnowy: RGB = { red: 150, green: 150, blue: 150 };
export const swSnowyRainy: RGB = { red: 150, green: 150, blue: 255 };
export const swSunny: RGB = { red: 255, green: 255, blue: 0 };
export const swWindy: RGB = { red: 150, green: 150, blue: 150 };

const defaultOnColor = HMIOn;
const defaultOffColor = HMIOff;

export function rgb_dec565(rgb: RGB): number {
    //return ((Math.floor(rgb.red / 255 * 31) << 11) | (Math.floor(rgb.green / 255 * 63) << 5) | (Math.floor(rgb.blue / 255 * 31)));
    return ((rgb.red >> 3) << 11) | ((rgb.green >> 2) << 5) | (rgb.blue >> 3);
}

export function rgbHexToObject(rgb: string): RGB {
    const result = { red: 0, green: 0, blue: 0 };
    if (rgb.startsWith('#') && rgb.length == 7) {
        result.red = parseInt(rgb.substring(1, 3), 16);
        result.green = parseInt(rgb.substring(3, 5), 16);
        result.blue = parseInt(rgb.substring(5), 16);
    }
    return result;
}

export function scale(number: number, inMin: number, inMax: number, outMin: number, outMax: number): number {
    return outMax + outMin - (((number - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin);
}

export function HandleColorScale(valueScaletemp: string): number {
    switch (valueScaletemp) {
        case '0':
            return rgb_dec565(colorScale0);
        case '1':
            return rgb_dec565(colorScale1);
        case '2':
            return rgb_dec565(colorScale2);
        case '3':
            return rgb_dec565(colorScale3);
        case '4':
            return rgb_dec565(colorScale4);
        case '5':
            return rgb_dec565(colorScale5);
        case '6':
            return rgb_dec565(colorScale6);
        case '7':
            return rgb_dec565(colorScale7);
        case '8':
            return rgb_dec565(colorScale8);
        case '9':
            return rgb_dec565(colorScale9);
        case '10':
            return rgb_dec565(colorScale10);
        default:
            return rgb_dec565(colorScale10);
    }
}
export function Interpolate(color1: RGB, color2: RGB, fraction: number): RGB {
    const r: number = InterpolateNum(color1.red, color2.red, fraction);
    const g: number = InterpolateNum(color1.green, color2.green, fraction);
    const b: number = InterpolateNum(color1.blue, color2.blue, fraction);
    return { red: Math.round(r), green: Math.round(g), blue: Math.round(b) };
}

export function InterpolateNum(d1: number, d2: number, fraction: number): number {
    return d1 + (d2 - d1) * fraction;
}

export async function GetIconColor(pageItem: PageItemDataitems, value: boolean | number): Promise<string> {
    // dimmer
    const useColor = pageItem.data.useColor && (await pageItem.data.useColor.getBoolean());
    const interpolateColor = pageItem.data.interpolateColor && (await pageItem.data.interpolateColor.getBoolean());
    const onColor =
        pageItem.data.color &&
        'true' in pageItem.data.color &&
        pageItem.data.color.true &&
        (await pageItem.data.color.true.getRGBValue());
    const offColor =
        pageItem.data.color &&
        'true' in pageItem.data.color &&
        pageItem.data.color.true &&
        (await pageItem.data.color.true.getRGBValue());
    if (useColor && interpolateColor && typeof value === 'number') {
        let val: number = typeof value === 'number' ? value : 0;
        const maxValue =
            (pageItem.data.maxValueBrightness && (await pageItem.data.maxValueBrightness.getNumber())) || 100;
        const minValue =
            (pageItem.data.minValueBrightness && (await pageItem.data.minValueBrightness.getNumber())) || 0;
        val = val > maxValue ? maxValue : val;
        val = val < minValue ? minValue : val;

        return String(
            rgb_dec565(
                Interpolate(
                    offColor ? offColor : defaultOffColor,
                    onColor ? onColor : defaultOnColor,
                    scale(100 - val, minValue, maxValue, 0, 1),
                ),
            ),
        );
    }
    if (
        (useColor && typeof value === 'boolean' && value) ||
        (typeof value === 'number' &&
            value >
                (pageItem.data.minValueBrightness !== undefined
                    ? (await pageItem.data.minValueBrightness.getNumber()) ?? 0
                    : 0))
    ) {
        return String(rgb_dec565(onColor ? onColor : defaultOnColor));
    }
    return String(rgb_dec565(offColor ? offColor : defaultOffColor));
}

/**
 * Convert radians to degrees
 * @param rad radians to convert, expects rad in range +/- PI per Math.atan2
 * @returns {number} degrees equivalent of rad
 */
export function rad2deg(rad: number): number {
    return (360 + (180 * rad) / Math.PI) % 360;
}

export function ColorToHex(color: number): string {
    const hexadecimal: string = color.toString(16);
    return hexadecimal.length == 1 ? '0' + hexadecimal : hexadecimal;
}

export function ConvertRGBtoHex(red: number, green: number, blue: number): string {
    return '#' + ColorToHex(red) + ColorToHex(green) + ColorToHex(blue);
}
export function ConvertHexToRgb(hex: string): RGB {
    return {
        red: parseInt(hex.substring(1, 3), 16),
        green: parseInt(hex.substring(3, 5), 16),
        blue: parseInt(hex.substring(5, 7), 16),
    };
}

/**
 * Convert h,s,v values to r,g,b
 * @param hue in range [0, 360]
 * @param saturation in range 0 to 1
 * @param value in range 0 to 1
 * @returns {[number, number, number]} [r, g,b] in range 0 to 255
 */
export function hsv2rgb(hue: number, saturation: number, value: number): [number, number, number] {
    hue /= 60;
    const chroma = value * saturation;
    const x = chroma * (1 - Math.abs((hue % 2) - 1));
    const rgb: [number, number, number] =
        hue <= 1
            ? [chroma, x, 0]
            : hue <= 2
              ? [x, chroma, 0]
              : hue <= 3
                ? [0, chroma, x]
                : hue <= 4
                  ? [0, x, chroma]
                  : hue <= 5
                    ? [x, 0, chroma]
                    : [chroma, 0, x];

    return rgb.map((v) => (v + value - chroma) * 255) as [number, number, number];
}

export function getHue(red: number, green: number, blue: number): number {
    const min = Math.min(Math.min(red, green), blue);
    const max = Math.max(Math.max(red, green), blue);

    if (min == max) {
        return 0;
    }

    let hue = 0;
    if (max == red) {
        hue = (green - blue) / (max - min);
    } else if (max == green) {
        hue = 2 + (blue - red) / (max - min);
    } else {
        hue = 4 + (red - green) / (max - min);
    }

    hue = hue * 60;
    if (hue < 0) hue = hue + 360;

    return Math.round(hue);
}

export function pos_to_color(x: number, y: number): RGB {
    let r = 160 / 2;
    x = Math.round(((x - r) / r) * 100) / 100;
    y = Math.round(((r - y) / r) * 100) / 100;

    r = Math.sqrt(x * x + y * y);
    let sat = 0;
    if (r > 1) {
        sat = 0;
    } else {
        sat = r;
    }

    const hsv = rad2deg(Math.atan2(y, x));
    const rgb = hsv2rgb(hsv, sat, 1);

    return { red: Math.round(rgb[0]), green: Math.round(rgb[1]), blue: Math.round(rgb[2]) };
}

/**
 *
 * @param red
 * @param green
 * @param blue
 * @returns
 */
export function rgb_to_cie(red: number, green: number, blue: number): string {
    //Apply a gamma correction to the RGB values, which makes the color more vivid and more the like the color displayed on the screen of your device
    const vred = red > 0.04045 ? Math.pow((red + 0.055) / (1.0 + 0.055), 2.4) : red / 12.92;
    const vgreen = green > 0.04045 ? Math.pow((green + 0.055) / (1.0 + 0.055), 2.4) : green / 12.92;
    const vblue = blue > 0.04045 ? Math.pow((blue + 0.055) / (1.0 + 0.055), 2.4) : blue / 12.92;

    //RGB values to XYZ using the Wide RGB D65 conversion formula
    const X = vred * 0.664511 + vgreen * 0.154324 + vblue * 0.162028;
    const Y = vred * 0.283881 + vgreen * 0.668433 + vblue * 0.047685;
    const Z = vred * 0.000088 + vgreen * 0.07231 + vblue * 0.986039;

    //Calculate the xy values from the XYZ values
    const ciex = (X / (X + Y + Z)).toFixed(4);
    const ciey = (Y / (X + Y + Z)).toFixed(4);
    const cie = '[' + ciex + ',' + ciey + ']';

    return cie;
}
export function isRGB(F: RGB | any): F is RGB {
    return typeof F == 'object' && 'red' in F && 'blue' in F && 'green' in F;
}
